diff -rup binutils.orig/binutils/NEWS binutils-2.30/binutils/NEWS
--- binutils.orig/binutils/NEWS	2021-10-20 12:39:41.715008273 +0100
+++ binutils-2.30/binutils/NEWS	2021-10-20 12:41:30.895327968 +0100
@@ -1,5 +1,14 @@
 -*- text -*-
 
+* Tools which display names or strings (readelf, strings, nm, objdump)
+  have a new command line option which controls how unicode characters are
+  handled.  By default they are treated as normal for the tool.  Using
+  --unicode=locale will display them according to the current locale.
+  Using --unicode=hex will display them as hex byte values, whilst
+  --unicode=escape will display them as escape sequences.  In addition
+  using --unicode=highlight will display them as unicode escape sequences
+  highlighted in red (if supported by the output device).
+
 * Add support for disassembling netronome Flow Processor (NFP) firmware files.
 
 Changes in 2.30:
diff -rup binutils.orig/binutils/doc/binutils.texi binutils-2.30/binutils/doc/binutils.texi
--- binutils.orig/binutils/doc/binutils.texi	2021-10-20 12:39:41.701008360 +0100
+++ binutils-2.30/binutils/doc/binutils.texi	2021-10-20 13:00:11.801327501 +0100
@@ -762,6 +762,7 @@ nm [@option{-A}|@option{-o}|@option{--pr
    [@option{-D}|@option{--dynamic}] [@option{-f}@var{format}|@option{--format=}@var{format}]
    [@option{-g}|@option{--extern-only}] [@option{-h}|@option{--help}]
    [@option{-l}|@option{--line-numbers}] [@option{--inlines}]
+   [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
    [@option{-n}|@option{-v}|@option{--numeric-sort}]
    [@option{-P}|@option{--portability}] [@option{-p}|@option{--no-sort}]
    [@option{-r}|@option{--reverse-sort}] [@option{-S}|@option{--print-size}]
@@ -1026,6 +1027,21 @@ Use @var{radix} as the radix for printin
 @cindex undefined symbols
 Display only undefined symbols (those external to each object file).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Show the version number of @command{nm} and exit.
@@ -2093,6 +2109,7 @@ objdump [@option{-a}|@option{--archive-h
         [@option{--prefix=}@var{prefix}]
         [@option{--prefix-strip=}@var{level}]
         [@option{--insn-width=}@var{width}]
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-V}|@option{--version}]
         [@option{-H}|@option{--help}]
         @var{objfile}@dots{}
@@ -2697,6 +2714,21 @@ When displaying symbols include those wh
 special in some way and which would not normally be of interest to the
 user.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment.  The @option{--unicode=locale} option displays the sequence
+in the current locale, which may or may not support them.  The options
+@option{--unicode=hex} and @option{--unicode=invalid} display them as
+hex byte sequences enclosed by either angle brackets or curly braces.
+
+The @option{--unicode=escape} option displays them as escape sequences
+(@var{\uxxxx}) and the @option{--unicode=highlight} option displays
+them as escape sequences highlighted in red (if supported by the
+output device).  The colouring is intended to draw attention to the
+presence of unicode sequences where they might not be expected.
+
 @item -V
 @itemx --version
 Print the version number of @command{objdump} and exit.
@@ -2952,6 +2984,7 @@ strings [@option{-afovV}] [@option{-}@va
         [@option{-n} @var{min-len}] [@option{--bytes=}@var{min-len}]
         [@option{-t} @var{radix}] [@option{--radix=}@var{radix}]
         [@option{-e} @var{encoding}] [@option{--encoding=}@var{encoding}]
+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]
         [@option{-}] [@option{--all}] [@option{--print-file-name}]
         [@option{-T} @var{bfdname}] [@option{--target=}@var{bfdname}]
         [@option{-w}] [@option{--include-all-whitespace}]
@@ -3043,6 +3076,28 @@ single-8-bit-byte characters, @samp{b} =
 littleendian.  Useful for finding wide character strings. (@samp{l}
 and @samp{b} apply to, for example, Unicode UTF-16/UCS-2 encodings).
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}
+Controls the display of UTF-8 encoded mulibyte characters in strings.
+The default (@option{--unicode=default}) is to give them no special
+treatment, and instead rely upon the setting of the
+@option{--encoding} option.  The other values for this option
+automatically enable @option{--encoding=S}.
+
+The @option{--unicode=invalid} option treats them as non-graphic
+characters and hence not part of a valid string.  All the remaining
+options treat them as valid string characters.
+
+The @option{--unicode=locale} option displays them in the current
+locale, which may or may not support UTF-8 encoding.  The
+@option{--unicode=hex} option displays them as hex byte sequences
+enclosed between @var{<>} characters.  The @option{--unicode=escape}
+option displays them as escape sequences (@var{\uxxxx}) and the
+@option{--unicode=highlight} option displays them as escape sequences
+highlighted in red (if supported by the output device).  The colouring
+is intended to draw attention to the presence of unicode sequences
+where they might not be expected.
+
 @item -T @var{bfdname}
 @itemx --target=@var{bfdname}
 @cindex object code format
@@ -4603,6 +4658,7 @@ readelf [@option{-a}|@option{--all}]
         [@option{-v}|@option{--version}]
         [@option{-W}|@option{--wide}]
         [@option{-H}|@option{--help}]
+        [@option{-U} @var{method}|@option{--unicode=}@var{method}]
         @var{elffile}@dots{}
 @c man end
 @end smallexample
@@ -4692,6 +4748,28 @@ Displays the entries in dynamic symbol t
 has one.  The output format is the same as the format used by the
 @option{--syms} option.
 
+@item -U @var{[d|i|l|e|x|h]}
+@itemx --unicode=[default|invalid|locale|escape|hex|highlight]
+Controls the display of non-ASCII characters in identifier names.
+The default (@option{--unicode=locale} or @option{--unicode=default}) is
+to treat them as multibyte characters and display them in the current
+locale.  All other versions of this option treat the bytes as UTF-8
+encoded values and attempt to interpret them.  If they cannot be
+interpreted or if the @option{--unicode=invalid} option is used then
+they are displayed as a sequence of hex bytes, encloses in curly
+parethesis characters.
+
+Using the @option{--unicode=escape} option will display the characters
+as as unicode escape sequences (@var{\uxxxx}).  Using the
+@option{--unicode=hex} will display the characters as hex byte
+sequences enclosed between angle brackets.
+
+Using the @option{--unicode=highlight} will display the characters as 
+unicode escape sequences but it will also highlighted them in red,
+assuming that colouring is supported by the output device.  The
+colouring is intended to draw attention to the presence of unicode
+sequences when they might not be expected.
+
 @item -e
 @itemx --headers
 Display all the headers in the file.  Equivalent to @option{-h -l -S}.
diff -rup binutils.orig/binutils/nm.c binutils-2.30/binutils/nm.c
--- binutils.orig/binutils/nm.c	2021-10-20 12:39:41.681008485 +0100
+++ binutils-2.30/binutils/nm.c	2021-10-20 12:52:26.731237376 +0100
@@ -38,6 +38,11 @@
 #include "bucomm.h"
 #include "plugin-api.h"
 #include "plugin.h"
+#include "safe-ctype.h"
+
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
 
 /* When sorting by size, we use this structure to hold the size and a
    pointer to the minisymbol.  */
@@ -194,6 +199,18 @@ static const char *plugin_target = NULL;
 static bfd *lineno_cache_bfd;
 static bfd *lineno_cache_rel_bfd;
 
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 #define OPTION_TARGET 200
 #define OPTION_PLUGIN (OPTION_TARGET + 1)
 #define OPTION_SIZE_SORT (OPTION_PLUGIN + 1)
@@ -224,6 +241,7 @@ static struct option long_options[] =
   {"target", required_argument, 0, OPTION_TARGET},
   {"defined-only", no_argument, &defined_only, 1},
   {"undefined-only", no_argument, &undefined_only, 1},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, &show_version, 1},
   {"with-symbol-versions", no_argument, &with_symbol_versions, 1},
   {0, no_argument, 0, 0}
@@ -271,6 +289,8 @@ usage (FILE *stream, int status)
   -t, --radix=RADIX      Use RADIX for printing symbol values\n\
       --target=BFDNAME   Specify the target object format as BFDNAME\n\
   -u, --undefined-only   Display only undefined symbols\n\
+  -U {d|s|i|x|e|h}       Specify how to treat UTF-8 encoded unicode characters\n\
+      --unicode={default|show|invalid|hex|escape|highlight}\n\
       --with-symbol-versions  Display version strings after symbol names\n\
   -X 32_64               (ignored)\n\
   @FILE                  Read options from FILE\n\
@@ -399,6 +419,189 @@ get_coff_symbol_type (const struct inter
   return bufp;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      {
+      unsigned int j;
+
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      }
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
+/* Convert any UTF-8 encoded characters in NAME into the form specified by
+   unicode_display.  Also converts control characters.  Returns a static
+   buffer if conversion was necessary.
+   Code stolen from objdump.c:sanitize_string().  */
+
+static const char *
+convert_utf8 (const char * in)
+{
+  static char *  buffer = NULL;
+  static size_t  buffer_len = 0;
+  const char *   original = in;
+  char *         out;
+
+  /* Paranoia.  */
+  if (in == NULL)
+    return "";
+
+  /* See if any conversion is necessary.
+     In the majority of cases it will not be needed.  */
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	return original;
+
+      if (ISCNTRL (c))
+	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
+    }
+  while (1);
+
+  /* Copy the input, translating as needed.  */
+  in = original;
+  if (buffer_len < (strlen (in) * 9))
+    {
+      free ((void *) buffer);
+      buffer_len = strlen (in) * 9;
+      buffer = xmalloc (buffer_len + 1);
+    }
+
+  out = buffer;
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	break;
+
+      if (ISCNTRL (c))
+	{
+	  *out++ = '^';
+	  *out++ = c + 0x40;
+	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
+    }
+  while (1);
+
+  *out = 0;
+  return buffer;
+}
+
 /* Print symbol name NAME, read from ABFD, with printf format FORM,
    demangling it if requested.  */
 
@@ -417,6 +618,9 @@ print_symname (const char *form, const c
 	}
     }
 
+  if (unicode_display != unicode_default)
+    name = convert_utf8 (name);
+
   printf (form, name);
 }
 
@@ -1657,7 +1861,7 @@ main (int argc, char **argv)
   bfd_init ();
   set_default_bfd_target ();
 
-  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
+  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uU:vVvX:",
 			   long_options, (int *) 0)) != EOF)
     {
       switch (c)
@@ -1738,6 +1942,24 @@ main (int argc, char **argv)
 	case 'u':
 	  undefined_only = 1;
 	  break;
+
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	  show_version = 1;
 	  break;
diff -rup binutils.orig/binutils/objdump.c binutils-2.30/binutils/objdump.c
--- binutils.orig/binutils/objdump.c	2021-10-20 12:39:41.677008510 +0100
+++ binutils-2.30/binutils/objdump.c	2021-10-20 13:24:11.009293189 +0100
@@ -192,6 +192,18 @@ static const struct objdump_private_desc
     OBJDUMP_PRIVATE_VECTORS
     NULL
   };
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
 
 static void usage (FILE *, int) ATTRIBUTE_NORETURN;
 static void
@@ -225,6 +237,9 @@ usage (FILE *stream, int status)
   -r, --reloc              Display the relocation entries in the file\n\
   -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
   @<file>                  Read options from <file>\n\
+  -U[d|l|i|x|e|h]          Controls the display of UTF-8 unicode characters\n\
+  --unicode=[default|locale|invalid|hex|escape|highlight]\n"));
+      fprintf (stream, _("\
   -v, --version            Display this program's version number\n\
   -i, --info               List object formats and architectures supported\n\
   -H, --help               Display this information\n\
@@ -343,6 +358,7 @@ static struct option long_options[]=
   {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
   {"syms", no_argument, NULL, 't'},
   {"target", required_argument, NULL, 'b'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'V'},
   {"wide", no_argument, NULL, 'w'},
   {"prefix", required_argument, NULL, OPTION_PREFIX},
@@ -362,6 +378,191 @@ nonfatal (const char *msg)
   exit_status = 1;
 }
 
+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
+   The conversion format is controlled by the unicode_display variable.
+   Returns the number of characters added to OUT.
+   Returns the number of bytes consumed from IN in CONSUMED.
+   Always consumes at least one byte and displays at least one character.  */
+   
+static unsigned int
+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
+{
+  char *        orig_out = out;
+  unsigned int  nchars = 0;
+
+  if (unicode_display == unicode_default)
+    goto invalid;
+
+  if (in[0] < 0xc0)
+    goto invalid;
+
+  if ((in[1] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x20) == 0)
+    {
+      nchars = 2;
+      goto valid;
+    }
+
+  if ((in[2] & 0xc0) != 0x80)
+    goto invalid;
+
+  if ((in[0] & 0x10) == 0)
+    {
+      nchars = 3;
+      goto valid;
+    }
+
+  if ((in[3] & 0xc0) != 0x80)
+    goto invalid;
+
+  nchars = 4;
+
+ valid:
+  switch (unicode_display)
+    {
+    case unicode_locale:
+      /* Copy the bytes into the output buffer as is.  */
+      memcpy (out, in, nchars);
+      out += nchars;
+      break;
+
+    case unicode_invalid:
+    case unicode_hex:
+      {
+      unsigned int j;
+
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
+      for (j = 0; j < nchars; j++)
+	out += sprintf (out, "%02x", in [j]);
+      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
+      }
+      break;
+      
+    case unicode_highlight:
+      if (isatty (1))
+	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
+      /* Fall through.  */
+    case unicode_escape:
+      switch (nchars)
+	{
+	case 2:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x1c) >> 2), 
+		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
+	  break;
+
+	case 3:
+	  out += sprintf (out, "\\u%02x%02x",
+		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  out += sprintf (out, "\\u%02x%02x%02x",
+		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
+		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
+		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	out += sprintf (out, "\033[0m"); /* Default colour.  */
+      break;
+
+    default:
+      /* URG */
+      break;
+    }
+
+  * consumed = nchars;
+  return out - orig_out;
+
+ invalid:
+  /* Not a valid UTF-8 sequence.  */
+  *out = *in;
+  * consumed = 1;
+  return 1;
+}
+
+/* Returns a version of IN with any control characters
+   replaced by escape sequences.  Uses a static buffer
+   if necessary.
+
+   If unicode display is enabled, then also handles the
+   conversion of unicode characters.  */
+
+static const char *
+sanitize_string (const char * in)
+{
+  static char *  buffer = NULL;
+  static size_t  buffer_len = 0;
+  const char *   original = in;
+  char *         out;
+
+  /* Paranoia.  */
+  if (in == NULL)
+    return "";
+
+  /* See if any conversion is necessary.  In the majority
+     of cases it will not be needed.  */
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	return original;
+
+      if (ISCNTRL (c))
+	break;
+
+      if (unicode_display != unicode_default && c >= 0xc0)
+	break;
+    }
+  while (1);
+
+  /* Copy the input, translating as needed.  */
+  in = original;
+  if (buffer_len < (strlen (in) * 9))
+    {
+      free ((void *) buffer);
+      buffer_len = strlen (in) * 9;
+      buffer = xmalloc (buffer_len + 1);
+    }
+
+  out = buffer;
+  do
+    {
+      unsigned char c = *in++;
+
+      if (c == 0)
+	break;
+
+      if (ISCNTRL (c))
+	{
+	  *out++ = '^';
+	  *out++ = c + 0x40;
+	}
+      else if (unicode_display != unicode_default && c >= 0xc0)
+	{
+	  unsigned int num_consumed;
+
+	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
+	  in += num_consumed - 1;
+	}
+      else
+	*out++ = c;
+    }
+  while (1);
+
+  *out = 0;
+  return buffer;
+}
+
 /* Returns TRUE if the specified section should be dumped.  */
 
 static bfd_boolean
@@ -458,8 +657,8 @@ dump_section_header (bfd *abfd, asection
     return;
 
   printf ("%3d %-*s %08lx  ", section->index, longest_section_name,
-	  bfd_get_section_name (abfd, section),
-	  (unsigned long) bfd_section_size (abfd, section) / opb);
+	  sanitize_string (bfd_section_name (abfd, section)),
+	  (unsigned long) bfd_section_size (abfd, section) / opb);
   bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));
   printf ("  ");
   bfd_printf_vma (abfd, section->lma);
@@ -892,6 +1091,8 @@ objdump_print_symname (bfd *abfd, struct
   if (bfd_is_und_section (bfd_get_section (sym)))
     hidden = TRUE;
 
+  name = sanitize_string (name);
+
   if (inf != NULL)
     {
       (*inf->fprintf_func) (inf->stream, "%s", name);
@@ -1141,7 +1342,7 @@ objdump_print_addr_with_sym (bfd *abfd,
       bfd_vma secaddr;
 
       (*inf->fprintf_func) (inf->stream, " <%s",
-			    bfd_get_section_name (abfd, sec));
+			    sanitize_string (bfd_section_name (abfd, sec)));
       secaddr = bfd_get_section_vma (abfd, sec);
       if (vma < secaddr)
 	{
@@ -1563,7 +1764,7 @@ show_line (bfd *abfd, asection *section,
 	  && (prev_functionname == NULL
 	      || strcmp (functionname, prev_functionname) != 0))
 	{
-	  printf ("%s():\n", functionname);
+	  printf ("%s():\n", sanitize_string (functionname));
 	  prev_line = -1;
 	}
       if (linenumber > 0
@@ -1572,10 +1773,10 @@ show_line (bfd *abfd, asection *section,
 	{
 	  if (discriminator > 0)
 	    printf ("%s:%u (discriminator %u)\n",
-		    filename == NULL ? "???" : filename,
+		    filename == NULL ? "???" : sanitize_string (filename),
 		    linenumber, discriminator);
 	  else
-	    printf ("%s:%u\n", filename == NULL ? "???" : filename,
+	    printf ("%s:%u\n", filename == NULL ? "???" : sanitize_string (filename),
 		    linenumber);
 	}
       if (unwind_inlines)
@@ -1586,8 +1787,10 @@ show_line (bfd *abfd, asection *section,
 
 	  while (bfd_find_inliner_info (abfd, &filename2, &functionname2,
 					&line2))
-	    printf ("inlined by %s:%u (%s)\n", filename2, line2,
-		    functionname2);
+	    {
+	      printf ("inlined by %s:%u", sanitize_string (filename2), line2);
+	      printf (" (%s)\n", sanitize_string (functionname2));
+	    }
 	}
     }
 
@@ -2081,7 +2284,7 @@ disassemble_bytes (struct disassemble_in
 		      sym_name = bfd_get_section_name (aux->abfd, sym_sec);
 		      if (sym_name == NULL || *sym_name == '\0')
 			sym_name = "*unknown*";
-		      printf ("%s", sym_name);
+		      printf ("%s", sanitize_string (sym_name));
 		    }
 		}
 
@@ -2228,7 +2431,7 @@ disassemble_section (bfd *abfd, asection
 	 && (*rel_pp)->address < rel_offset + addr_offset)
     ++rel_pp;
 
-  printf (_("\nDisassembly of section %s:\n"), section->name);
+  printf (_("\nDisassembly of section %s:\n"), sanitize_string (section->name));
 
   /* Find the nearest symbol forwards from our current position.  */
   paux->require_sec = TRUE;
@@ -2512,7 +2715,7 @@ load_specific_debug_section (enum dwarf_
     {
       free_debug_section (debug);
       printf (_("\nCan't get contents for section '%s'.\n"),
-	      section->name);
+	      sanitize_string (section->name));
       return FALSE;
     }
   /* Ensure any string section has a terminating NUL.  */
@@ -2534,7 +2737,7 @@ load_specific_debug_section (enum dwarf_
         {
           free_debug_section (debug);
           printf (_("\nCan't get contents for section '%s'.\n"),
-	          section->name);
+	          sanitize_string (section->name));
           return FALSE;
         }
 
@@ -2780,14 +2983,14 @@ read_section_stabs (bfd *abfd, const cha
   stabsect = bfd_get_section_by_name (abfd, sect_name);
   if (stabsect == NULL)
     {
-      printf (_("No %s section present\n\n"), sect_name);
+      printf (_("No %s section present\n\n"), sanitize_string (sect_name));
       return FALSE;
     }
 
   if (!bfd_malloc_and_get_section (abfd, stabsect, &contents))
     {
       non_fatal (_("reading %s section of %s failed: %s"),
-		 sect_name, bfd_get_filename (abfd),
+		 sanitize_string (sect_name), bfd_get_filename (abfd),
 		 bfd_errmsg (bfd_get_error ()));
       exit_status = 1;
       free (contents);
@@ -2830,7 +3033,7 @@ print_section_stabs (bfd *abfd,
   stabp = stabs;
   stabs_end = stabp + stab_size;
 
-  printf (_("Contents of %s section:\n\n"), stabsect_name);
+  printf (_("Contents of %s section:\n\n"), sanitize_string (stabsect_name));
   printf ("Symnum n_type n_othr n_desc n_value  n_strx String\n");
 
   /* Loop through all symbols and print them.
@@ -3093,7 +3296,7 @@ dump_section (bfd *abfd, asection *secti
   if (start_offset >= stop_offset)
     return;
 
-  printf (_("Contents of section %s:"), section->name);
+  printf (_("Contents of section %s:"), sanitize_string (section->name));
   if (display_file_offsets)
     printf (_("  (Starting at file offset: 0x%lx)"),
 	    (unsigned long) (section->filepos + start_offset));
@@ -3102,7 +3305,7 @@ dump_section (bfd *abfd, asection *secti
   if (!bfd_get_full_section_contents (abfd, section, &data))
     {
       non_fatal (_("Reading section %s failed because: %s"),
-		 section->name, bfd_errmsg (bfd_get_error ()));
+		 sanitize_string (section->name), bfd_errmsg (bfd_get_error ()));
       return;
     }
 
@@ -3242,6 +3445,24 @@ dump_symbols (bfd *abfd ATTRIBUTE_UNUSED
 		  free (alloc);
 		}
 	    }
+	  else if (unicode_display != unicode_default
+		   && name != NULL && *name != '\0')
+	    {
+	      const char * sanitized_name;
+
+	      /* If we want to sanitize the name, we do it here, and
+		 temporarily clobber it while calling bfd_print_symbol.
+		 FIXME: This is a gross hack.  */
+	      sanitized_name = sanitize_string (name);
+	      if (sanitized_name != name)
+		(*current)->name = sanitized_name;
+	      else
+		sanitized_name = NULL;
+	      bfd_print_symbol (cur_bfd, stdout, *current,
+				bfd_print_symbol_all);
+	      if (sanitized_name != NULL)
+		(*current)->name = name;
+	    }
 	  else
 	    bfd_print_symbol (cur_bfd, stdout, *current,
 			      bfd_print_symbol_all);
@@ -3307,7 +3528,7 @@ dump_reloc_set (bfd *abfd, asection *sec
 	      && (last_functionname == NULL
 		  || strcmp (functionname, last_functionname) != 0))
 	    {
-	      printf ("%s():\n", functionname);
+	      printf ("%s():\n", sanitize_string (functionname));
 	      if (last_functionname != NULL)
 		free (last_functionname);
 	      last_functionname = xstrdup (functionname);
@@ -3321,9 +3542,9 @@ dump_reloc_set (bfd *abfd, asection *sec
                   || (discriminator != last_discriminator)))
 	    {
               if (discriminator > 0)
-                printf ("%s:%u\n", filename == NULL ? "???" : filename, linenumber);
+                printf ("%s:%u\n", filename == NULL ? "???" : sanitize_string (filename), linenumber);
               else
-                printf ("%s:%u (discriminator %u)\n", filename == NULL ? "???" : filename,
+                printf ("%s:%u (discriminator %u)\n", filename == NULL ? "???" : sanitize_string (filename),
                         linenumber, discriminator);
 	      last_line = linenumber;
 	      last_discriminator = discriminator;
@@ -3393,7 +3614,7 @@ dump_reloc_set (bfd *abfd, asection *sec
 	{
 	  if (section_name == NULL)
 	    section_name = "*unknown*";
-	  printf ("[%s]", section_name);
+	  printf ("[%s]", sanitize_string (section_name));
 	}
 
       if (q->addend)
@@ -3443,7 +3664,7 @@ dump_relocs_in_section (bfd *abfd,
   if (relsize < 0)
     bfd_fatal (bfd_get_filename (abfd));
 
-  printf ("RELOCATION RECORDS FOR [%s]:", section->name);
+  printf ("RELOCATION RECORDS FOR [%s]:", sanitize_string (section->name));
 
   if (relsize == 0)
     {
@@ -3835,7 +4056,7 @@ main (int argc, char **argv)
   set_default_bfd_target ();
 
   while ((c = getopt_long (argc, argv,
-			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
+			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::U:",
 			   long_options, (int *) 0))
 	 != EOF)
     {
@@ -4069,6 +4290,23 @@ main (int argc, char **argv)
 	  seenflag = TRUE;
 	  break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'H':
 	  usage (stdout, 0);
 	  /* No need to set seenflag or to break - usage() does not return.  */
diff -rup binutils.orig/binutils/strings.c binutils-2.30/binutils/strings.c
--- binutils.orig/binutils/strings.c	2021-10-20 12:39:41.686008454 +0100
+++ binutils-2.30/binutils/strings.c	2021-10-20 13:32:22.029182908 +0100
@@ -55,6 +55,19 @@
    -T {bfdname}
 		Specify a non-default object file format.
 
+  --unicode={default|locale|invalid|hex|escape|highlight}
+  -U {d|l|i|x|e|h}
+                Determine how to handle UTF-8 unicode characters.  The default
+		is no special treatment.  All other versions of this option
+		only apply if the encoding is valid and enabling the option
+		implies --encoding=S.
+		The 'locale' option displays the characters according to the
+		current locale.  The 'invalid' option treats them as
+		non-string characters.  The 'hex' option displays them as hex
+		byte sequences.  The 'escape' option displays them as escape
+		sequences and the 'highlight' option displays them as
+		coloured escape sequences.
+
   --output-separator=sep_string
   -s sep_string	String used to separate parsed strings in output.
 		Default is newline.
@@ -76,6 +89,22 @@
 #include "safe-ctype.h"
 #include "bucomm.h"
 
+#ifndef streq
+#define streq(a,b) (strcmp ((a),(b)) == 0)
+#endif
+
+typedef enum unicode_display_type
+{
+  unicode_default = 0,
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_default;
+
 #define STRING_ISGRAPHIC(c) \
       (   (c) >= 0 \
        && (c) <= 255 \
@@ -94,7 +123,7 @@ extern int errno;
 static int address_radix;
 
 /* Minimum length of sequence of graphic chars to trigger output.  */
-static int string_min;
+static uint string_min;
 
 /* Whether or not we include all whitespace as a graphic char.   */
 static bfd_boolean include_all_whitespace;
@@ -130,6 +159,7 @@ static struct option long_options[] =
   {"target", required_argument, NULL, 'T'},
   {"output-separator", required_argument, NULL, 's'},
   {"help", no_argument, NULL, 'h'},
+  {"unicode", required_argument, NULL, 'U'},
   {"version", no_argument, NULL, 'v'},
   {NULL, 0, NULL, 0}
 };
@@ -173,7 +203,7 @@ main (int argc, char **argv)
   encoding = 's';
   output_separator = NULL;
 
-  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:Vv0123456789",
+  while ((optc = getopt_long (argc, argv, "adfhHn:wot:e:T:s:U:Vv0123456789",
 			      long_options, (int *) 0)) != EOF)
     {
       switch (optc)
@@ -246,6 +276,23 @@ main (int argc, char **argv)
 	  output_separator = optarg;
           break;
 
+	case 'U':
+	  if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_default;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'V':
 	case 'v':
 	  print_version ("strings");
@@ -260,6 +307,9 @@ main (int argc, char **argv)
 	}
     }
 
+  if (unicode_display != unicode_default)
+    encoding = 'S';
+
   if (numeric_opt != 0)
     {
       string_min = (int) strtoul (argv[numeric_opt - 1] + 1, &s, 0);
@@ -501,11 +551,629 @@ get_char (FILE *stream, file_ptr *addres
 
   return r;
 }
+
+static void
+print_filename_and_address (const char * filename, file_ptr address)
+{
+  if (print_filenames)
+    printf ("%s: ", filename);
+
+  if (! print_addresses)
+    return;
+
+  switch (address_radix)
+    {
+    case 8:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llo ", (unsigned long long) address);
+#else
+	  printf ("%7I64o ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lo ", (unsigned long) address);
+      break;
+
+    case 10:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llu ", (unsigned long long) address);
+#else
+	  printf ("%7I64d ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7ld ", (long) address);
+      break;
+
+    case 16:
+      if (sizeof (address) > sizeof (long))
+	{
+#ifndef __MSVCRT__
+	  printf ("%7llx ", (unsigned long long) address);
+#else
+	  printf ("%7I64x ", (unsigned long long) address);
+#endif
+	}
+      else
+	printf ("%7lx ", (unsigned long) address);
+      break;
+    }
+}
+
+/* Return non-zero if the bytes starting at BUFFER form a valid UTF-8 encoding.
+   If the encoding is valid then returns the number of bytes it uses.  */
+
+static unsigned int
+is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)
+{
+  if (buffer[0] < 0xc0)
+    return 0;
+
+  if (buflen < 2)
+    return 0;
+
+  if ((buffer[1] & 0xc0) != 0x80)
+    return 0;
+
+  if ((buffer[0] & 0x20) == 0)
+    return 2;
+
+  if (buflen < 3)
+    return 0;
+
+  if ((buffer[2] & 0xc0) != 0x80)
+    return 0;
+  
+  if ((buffer[0] & 0x10) == 0)
+    return 3;
+
+  if (buflen < 4)
+    return 0;
+
+  if ((buffer[3] & 0xc0) != 0x80)
+    return 0;
+
+  return 4;
+}
+
+/* Display a UTF-8 encoded character in BUFFER according to the setting
+   of unicode_display.  The character is known to be valid.
+   Returns the number of bytes consumed.  */
+
+static unsigned int
+display_utf8_char (const unsigned char * buffer)
+{
+  unsigned int j;
+  unsigned int utf8_len;
+
+  switch (buffer[0] & 0x30)
+    {
+    case 0x00:
+    case 0x10:
+      utf8_len = 2;
+      break;
+    case 0x20:
+      utf8_len = 3;
+      break;
+    default:
+      utf8_len = 4;
+    }
+      
+  switch (unicode_display)
+    {
+    default:
+      fprintf (stderr, "ICE: unexpected unicode display type\n");
+      break;
+
+    case unicode_escape:
+    case unicode_highlight:
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\x1B[31;47m"); /* Red.  */
+
+      switch (utf8_len)
+	{
+	case 2:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x1c) >> 2), 
+		  ((buffer[0] & 0x03) << 6) | (buffer[1] & 0x3f));
+	  break;
+
+	case 3:
+	  printf ("\\u%02x%02x",
+		  ((buffer[0] & 0x0f) << 4) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3f)));
+	  break;
+
+	case 4:
+	  printf ("\\u%02x%02x%02x",
+		  ((buffer[0] & 0x07) << 6) | ((buffer[1] & 0x3c) >> 2),
+		  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3c) >> 2),
+		  ((buffer[2] & 0x03) << 6) | ((buffer[3] & 0x3f)));
+	  break;
+	default:
+	  /* URG.  */
+	  break;
+	}
+
+      if (unicode_display == unicode_highlight && isatty (1))
+	printf ("\033[0m"); /* Default colour.  */
+      break;
+
+    case unicode_hex:
+      putchar ('<');
+      for (j = 0; j < utf8_len; j++)
+	printf ("%02x", buffer [j]);
+      putchar ('>');
+      break;
+
+    case unicode_locale:
+      printf ("%.1s", buffer);
+      break;
+    }
+
+  return utf8_len;
+}
+
+/* Display strings in BUFFER.  Treat any UTF-8 encoded characters encountered
+   according to the setting of the unicode_display variable.  The buffer
+   contains BUFLEN bytes.
+
+   Display the characters as if they started at ADDRESS and are contained in
+   FILENAME.  */
+
+static void
+print_unicode_buffer (const char *            filename,
+		      file_ptr                address,
+		      const unsigned char *   buffer,
+		      unsigned long           buflen)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || buffer == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_buffer\n");
+      return;
+    }
+
+  if (buflen == 0)
+    return;
+
+  /* We must only display strings that are at least string_min *characters*
+     long.  So we scan the buffer in two stages.  First we locate the start
+     of a potential string.  Then we walk along it until we have found
+     string_min characters.  Then we go back to the start point and start
+     displaying characters according to the unicode_display setting.  */
+
+  unsigned long start_point = 0;
+  unsigned long i = 0;
+  unsigned int char_len = 1;
+  unsigned int num_found = 0;
+
+  for (i = 0; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      /* Find the first potential character of a string.  */
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_found = 0;
+	  continue;
+	}
+
+      if (c > 126)
+	{
+	  if (c < 0xc0)
+	    {
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if ((char_len = is_valid_utf8 (buffer + i, buflen - i)) == 0)
+	    {
+	      char_len = 1;
+	      num_found = 0;
+	      continue;
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    {
+	      /* We have found a valid UTF-8 character, but we treat it as non-graphic.  */
+	      num_found = 0;
+	      continue;
+	    }
+	}
+
+      if (num_found == 0)
+	/* We have found a potential starting point for a string.  */
+	start_point = i;
+
+      ++ num_found;
+
+      if (num_found >= string_min)
+	break;
+    }
+
+  if (num_found < string_min)
+    return;
+
+  print_filename_and_address (filename, address + start_point);
+  
+  /* We have found string_min characters.  Display them and any
+     more that follow.  */
+  for (i = start_point; i < buflen; i += char_len)
+    {
+      int c = buffer[i];
+
+      char_len = 1;
+
+      if (! STRING_ISGRAPHIC (c))
+	break;
+      else if (c < 127)
+	putchar (c);
+      else if (! is_valid_utf8 (buffer + i, buflen - i))
+	break;
+      else if (unicode_display == unicode_invalid)
+	break;
+      else
+	char_len = display_utf8_char (buffer + i);
+    }
+
+  if (output_separator)
+    fputs (output_separator, stdout);
+  else
+    putchar ('\n');
+
+  /* FIXME: Using tail recursion here is lazy programming...  */
+  print_unicode_buffer (filename, address + i, buffer + i, buflen - i);
+}
+
+static int
+get_unicode_byte (FILE *           stream,
+		  unsigned char *  putback,
+		  unsigned int *   num_putback,
+		  unsigned int *   num_read)
+{
+  if (* num_putback > 0)
+    {
+      * num_putback = * num_putback - 1;
+      return putback [* num_putback];
+    }
+
+  * num_read = * num_read + 1;
+
+#if defined(HAVE_GETC_UNLOCKED) && HAVE_DECL_GETC_UNLOCKED
+  return getc_unlocked (stream);
+#else
+  return getc (stream);
+#endif
+}
+
+/* Helper function for print_unicode_stream.  */
+
+static void
+print_unicode_stream_body (const char *     filename,
+			   file_ptr         address,
+			   FILE *           stream,
+			   unsigned char *  putback_buf,
+			   unsigned int     num_putback,
+			   unsigned char *  print_buf)
+{
+  /* It would be nice if we could just read the stream into a buffer
+     and then process if with print_unicode_buffer.  But the input
+     might be huge or it might time-locked (eg stdin).  So instead
+     we go one byte at a time...  */
+
+  file_ptr start_point = 0;
+  unsigned int num_read = 0;
+  unsigned int num_chars = 0;
+  unsigned int num_print = 0;
+  int c;
+
+  /* Find a series of string_min characters.  Put them into print_buf.  */
+  do
+    {
+      if (num_chars >= string_min)
+	break;
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+
+      if (! STRING_ISGRAPHIC (c))
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      if (num_chars == 0)
+	start_point = num_read - 1;
+
+      if (c < 127)
+	{
+	  print_buf[num_print] = c;
+	  num_chars ++;
+	  num_print ++;
+	  continue;
+	}
+
+      if (c < 0xc0)
+	{
+	  num_chars = num_print = 0;
+	  continue;
+	}
+
+      /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+      char utf8[4];
+
+      utf8[0] = c;
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[1] = c;
+
+      if ((utf8[1] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x20) == 0)
+	{
+	  /* A valid 2-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[2] = c;
+
+      if ((utf8[2] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	  continue;
+	}
+      else if ((utf8[0] & 0x10) == 0)
+	{
+	  /* A valid 3-byte UTF-8 encoding.  */
+	  if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      num_chars = num_print = 0;
+	    }
+	  else
+	    {
+	      print_buf[num_print ++] = utf8[0];
+	      print_buf[num_print ++] = utf8[1];
+	      print_buf[num_print ++] = utf8[2];
+	      num_chars ++;
+	    }
+	  continue;
+	}
+
+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+      if (c == EOF)
+	break;
+      utf8[3] = c;
+
+      if ((utf8[3] & 0xc0) != 0x80)
+	{
+	  /* Invalid UTF-8.  */
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[2];
+	  putback_buf[num_putback++] = utf8[1];
+	  num_chars = num_print = 0;
+	}
+      /* We have a valid 4-byte UTF-8 encoding.  */
+      else if (unicode_display == unicode_invalid)
+	{
+	  putback_buf[num_putback++] = utf8[3];
+	  putback_buf[num_putback++] = utf8[1];
+	  putback_buf[num_putback++] = utf8[2];
+	  num_chars = num_print = 0;
+	}
+      else
+	{
+	  print_buf[num_print ++] = utf8[0];
+	  print_buf[num_print ++] = utf8[1];
+	  print_buf[num_print ++] = utf8[2];
+	  print_buf[num_print ++] = utf8[3];
+	  num_chars ++;
+	}
+    }
+  while (1);
+
+  if (num_chars >= string_min)
+    {
+      /* We know that we have string_min valid characters in print_buf,
+	 and there may be more to come in the stream.  Start displaying
+	 them.  */
+
+      print_filename_and_address (filename, address + start_point);
+
+      unsigned int i;
+      for (i = 0; i < num_print;)
+	{
+	  if (print_buf[i] < 127)
+	    putchar (print_buf[i++]);
+	  else
+	    i += display_utf8_char (print_buf + i);
+	}
+
+      /* OK so now we have to start read unchecked bytes.  */
+
+        /* Find a series of string_min characters.  Put them into print_buf.  */
+      do
+	{
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+
+	  if (! STRING_ISGRAPHIC (c))
+	    break;
+
+	  if (c < 127)
+	    {
+	      putchar (c);
+	      continue;
+	    }
+
+	  if (c < 0xc0)
+	    break;
+
+	  /* We *might* have a UTF-8 sequence.  Time to start peeking.  */
+	  unsigned char utf8[4];
+
+	  utf8[0] = c;
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[1] = c;
+
+	  if ((utf8[1] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x20) == 0)
+	    {
+	      /* Valid 2-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[2] = c;
+
+	  if ((utf8[2] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if ((utf8[0] & 0x10) == 0)
+	    {
+	      /* Valid 3-byte UTF-8.  */
+	      if (unicode_display == unicode_invalid)
+		{
+		  putback_buf[num_putback++] = utf8[2];
+		  putback_buf[num_putback++] = utf8[1];
+		  break;
+		}
+	      else
+		{
+		  (void) display_utf8_char (utf8);
+		  continue;
+		}
+	    }
+
+	  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);
+	  if (c == EOF)
+	    break;
+	  utf8[3] = c;
+
+	  if ((utf8[3] & 0xc0) != 0x80)
+	    {
+	      /* Invalid UTF-8.  */
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else if (unicode_display == unicode_invalid)
+	    {
+	      putback_buf[num_putback++] = utf8[3];
+	      putback_buf[num_putback++] = utf8[2];
+	      putback_buf[num_putback++] = utf8[1];
+	      break;
+	    }
+	  else
+	    /* A valid 4-byte UTF-8 encoding.  */
+	    (void) display_utf8_char (utf8);
+	}
+      while (1);
+
+      if (output_separator)
+	fputs (output_separator, stdout);
+      else
+	putchar ('\n');
+    }
+
+  if (c != EOF)
+    /* FIXME: Using tail recursion here is lazy, but it works.  */
+    print_unicode_stream_body (filename, address + num_read, stream, putback_buf, num_putback, print_buf);
+}
+
+/* Display strings read in from STREAM.  Treat any UTF-8 encoded characters
+   encountered according to the setting of the unicode_display variable.
+   The stream is positioned at ADDRESS and is attached to FILENAME.  */
+
+static void
+print_unicode_stream (const char * filename,
+		      file_ptr     address,
+		      FILE *       stream)
+{
+  /* Paranoia checks...  */
+  if (filename == NULL
+      || stream == NULL
+      || unicode_display == unicode_default
+      || encoding != 'S'
+      || encoding_bytes != 1)
+    {
+      fprintf (stderr, "ICE: bad arguments to print_unicode_stream\n");
+      return;
+    }
+
+  /* Allocate space for string_min 4-byte utf-8 characters.  */
+  unsigned char * print_buf = xmalloc ((4 * string_min) + 1);
+  /* We should never have to put back more than 4 bytes.  */
+  unsigned char putback_buf[5];
+  unsigned int num_putback = 0;
+
+  print_unicode_stream_body (filename, address, stream, putback_buf, num_putback, print_buf);
+  free (print_buf);
+}
 
 /* Find the strings in file FILENAME, read from STREAM.
    Assume that STREAM is positioned so that the next byte read
    is at address ADDRESS in the file.
-   Stop reading at address STOP_POINT in the file, if nonzero.
 
    If STREAM is NULL, do not read from it.
    The caller can supply a buffer of characters
@@ -516,20 +1184,29 @@ get_char (FILE *stream, file_ptr *addres
 
 static void
 print_strings (const char *filename, FILE *stream, file_ptr address,
-	       int stop_point, int magiccount, char *magic)
+	       int stop_point, int magiccount, char *magic)
 {
+  if (unicode_display != unicode_default)
+    {
+      if (magic != NULL)
+	print_unicode_buffer (filename, address,
+			      (const unsigned char *) magic, magiccount);
+
+      if (stream != NULL)
+	print_unicode_stream (filename, address, stream);
+      return;
+    }
+
   char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));
 
   while (1)
     {
       file_ptr start;
-      int i;
+      unsigned int i;
       long c;
 
       /* See if the next `string_min' chars are all graphic chars.  */
     tryline:
-      if (stop_point && address >= stop_point)
-	break;
       start = address;
       for (i = 0; i < string_min; i++)
 	{
@@ -659,6 +1336,8 @@ usage (FILE *stream, int status)
   -T --target=<BFDNAME>     Specify the binary file format\n\
   -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\
                             s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\
+  --unicode={default|show|invalid|hex|escape|highlight}\n\
+  -U {d|s|i|x|e|h}          Specify how to treat UTF-8 encoded unicode characters\n\
   -s --output-separator=<string> String used to separate strings in output.\n\
   @<file>                   Read options from <file>\n\
   -h --help                 Display this information\n\
--- binutils.orig/binutils/readelf.c	2021-10-20 12:39:41.715008273 +0100
+++ binutils-2.30/binutils/readelf.c	2021-10-20 14:05:42.242326079 +0100
@@ -287,6 +287,18 @@ typedef enum print_mode
 }
 print_mode;
 
+typedef enum unicode_display_type
+{
+  unicode_locale,
+  unicode_escape,
+  unicode_hex,
+  unicode_highlight,
+  unicode_invalid
+} unicode_display_type;
+
+static unicode_display_type unicode_display = unicode_locale;
+
+  
 /* Versioned symbol info.  */
 enum versioned_symbol_info
 {
@@ -538,11 +550,18 @@ print_symbol (signed int width, const ch
       if (c == 0)
 	break;
 
-      /* Do not print control characters directly as they can affect terminal
-	 settings.  Such characters usually appear in the names generated
-	 by the assembler for local labels.  */
-      if (ISCNTRL (c))
+      if (ISPRINT (c))
+	{
+	  putchar (c);
+	  width_remaining --;
+	  num_printed ++;
+	}
+      else if (ISCNTRL (c))
 	{
+	  /* Do not print control characters directly as they can affect terminal
+	     settings.  Such characters usually appear in the names generated
+	     by the assembler for local labels.  */
+
 	  if (width_remaining < 2)
 	    break;
 
@@ -550,11 +569,135 @@ print_symbol (signed int width, const ch
 	  width_remaining -= 2;
 	  num_printed += 2;
 	}
-      else if (ISPRINT (c))
+      else if (c == 0x7f)
 	{
-	  putchar (c);
-	  width_remaining --;
-	  num_printed ++;
+	  if (width_remaining < 5)
+	    break;
+	  printf ("<DEL>");
+	  width_remaining -= 5;
+	  num_printed += 5;
+	}
+      else if (unicode_display != unicode_locale)
+	{
+	  /* Display unicode characters as something else.  */
+	  unsigned char bytes[4];
+	  bfd_boolean   is_utf8;
+	  unsigned int  nbytes;
+
+	  bytes[0] = c;
+
+	  if (bytes[0] < 0xc0)
+	    {
+	      nbytes = 1;
+	      is_utf8 = FALSE;
+	    }
+	  else
+	    {
+	      bytes[1] = *symbol++;
+
+	      if ((bytes[1] & 0xc0) != 0x80)
+		{
+		  is_utf8 = FALSE;
+		  /* Do not consume this character.  It may only
+		     be the first byte in the sequence that was
+		     corrupt.  */
+		  --symbol;
+		  nbytes = 1;
+		}
+	      else if ((bytes[0] & 0x20) == 0)
+		{
+		  is_utf8 = TRUE;
+		  nbytes = 2;
+		}
+	      else
+		{
+		  bytes[2] = *symbol++;
+
+		  if ((bytes[2] & 0xc0) != 0x80)
+		    {
+		      is_utf8 = FALSE;
+		      symbol -= 2;
+		      nbytes = 1;
+		    }
+		  else if ((bytes[0] & 0x10) == 0)
+		    {
+		      is_utf8 = TRUE;
+		      nbytes = 3;
+		    }
+		  else
+		    {
+		      bytes[3] = *symbol++;
+
+		      nbytes = 4;
+
+		      if ((bytes[3] & 0xc0) != 0x80)
+			{
+			  is_utf8 = FALSE;
+			  symbol -= 3;
+			  nbytes = 1;
+			}
+		      else
+			is_utf8 = TRUE;
+		    }
+		}
+	    }
+
+	  if (unicode_display == unicode_invalid)
+	    is_utf8 = FALSE;
+
+	  if (unicode_display == unicode_hex || ! is_utf8)
+	    {
+	      unsigned int i;
+
+	      if (width_remaining < (nbytes * 2) + 2)
+		break;
+	  
+	      putchar (is_utf8 ? '<' : '{');
+	      for (i = 0; i < nbytes; i++)
+		printf ("%02x", bytes[i]);
+	      putchar (is_utf8 ? '>' : '}');
+	    }
+	  else
+	    {
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\x1B[31;47m"); /* Red.  */
+	      
+	      switch (nbytes)
+		{
+		case 2:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  (bytes[0] & 0x1c) >> 2, 
+			  ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));
+		  break;
+		case 3:
+		  if (width_remaining < 6)
+		    break;
+		  printf ("\\u%02x%02x",
+			  ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));
+		  break;
+		case 4:
+		  if (width_remaining < 8)
+		    break;
+		  printf ("\\u%02x%02x%02x",
+			  ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),
+			  ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),
+			  ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));
+		  
+		  break;
+		default:
+		  /* URG.  */
+		  break;
+		}
+
+	      if (unicode_display == unicode_highlight && isatty (1))
+		printf ("\033[0m"); /* Default colour.  */
+	    }
+	  
+	  if (bytes[nbytes - 1] == 0)
+	    break;
 	}
       else
 	{
@@ -4375,6 +4518,7 @@ static struct option options[] =
   {"dwarf-start",      required_argument, 0, OPTION_DWARF_START},
   {"dwarf-check",      no_argument, 0, OPTION_DWARF_CHECK},
 
+  {"unicode",          required_argument, 0, 'U'},
   {"version",	       no_argument, 0, 'v'},
   {"wide",	       no_argument, 0, 'W'},
   {"help",	       no_argument, 0, 'H'},
@@ -4432,6 +4576,11 @@ usage (FILE * stream)
   fprintf (stream, _("\
   -I --histogram         Display histogram of bucket list lengths\n\
   -W --wide              Allow output width to exceed 80 characters\n\
+  -U --unicode=[locale|escape|hex|highlight|invalid]\n\
+                         Display unicode characters as determined by the current locale\n\
+                          (default), escape sequences, \"<hex sequences>\", highlighted\n\
+                          escape sequences, or treat them as invalid and display as\n\
+                          \"{hex sequences}\"\n\
   @<file>                Read options from <file>\n\
   -H --help              Display this information\n\
   -v --version           Display the version number of readelf\n"));
@@ -4525,7 +4674,7 @@ parse_args (Filedata * filedata, int arg
     usage (stderr);
 
   while ((c = getopt_long
-	  (argc, argv, "ADHINR:SVWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
+	  (argc, argv, "ADHINR:SU:VWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
     {
       switch (c)
 	{
@@ -4659,6 +4808,25 @@ parse_args (Filedata * filedata, int arg
 	  request_dump (filedata, DISASS_DUMP);
 	  break;
 #endif
+	case 'U':
+	  if (optarg == NULL)
+	    error (_("Missing arg to -U/--unicode")); /* Can this happen ?  */
+	  else if (streq (optarg, "default") || streq (optarg, "d"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "locale") || streq (optarg, "l"))
+	    unicode_display = unicode_locale;
+	  else if (streq (optarg, "escape") || streq (optarg, "e"))
+	    unicode_display = unicode_escape;
+	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
+	    unicode_display = unicode_invalid;
+	  else if (streq (optarg, "hex") || streq (optarg, "x"))
+	    unicode_display = unicode_hex;
+	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
+	    unicode_display = unicode_highlight;
+	  else
+	    error (_("unknown argument to -U/--unicode: %s"), optarg);
+	  break;
+
 	case 'v':
 	  print_version (program_name);
 	  break;
