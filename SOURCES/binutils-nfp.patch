# Add support for disassembling NFP binaries.  (#1644391)

diff -rup binutils.orig/bfd/archures.c binutils-2.30/bfd/archures.c
--- binutils.orig/bfd/archures.c	2019-03-07 13:21:14.246464815 +0000
+++ binutils-2.30/bfd/archures.c	2019-03-07 14:44:05.704268413 +0000
@@ -537,6 +537,9 @@ DESCRIPTION
 .#define bfd_mach_wasm32	1
 .  bfd_arch_pru,       {* PRU.  *}
 .#define bfd_mach_pru		0
+.  bfd_arch_nfp,       {* Netronome Flow Processor *}
+.#define bfd_mach_nfp3200	0x3200
+.#define bfd_mach_nfp6000	0x6000
 .  bfd_arch_last
 .  };
 */
@@ -632,6 +635,7 @@ extern const bfd_arch_info_type bfd_ft32
 extern const bfd_arch_info_type bfd_msp430_arch;
 extern const bfd_arch_info_type bfd_mt_arch;
 extern const bfd_arch_info_type bfd_nds32_arch;
+extern const bfd_arch_info_type bfd_nfp_arch;
 extern const bfd_arch_info_type bfd_nios2_arch;
 extern const bfd_arch_info_type bfd_ns32k_arch;
 extern const bfd_arch_info_type bfd_or1k_arch;
@@ -727,6 +731,7 @@ static const bfd_arch_info_type * const
     &bfd_msp430_arch,
     &bfd_mt_arch,
     &bfd_nds32_arch,
+    &bfd_nfp_arch,
     &bfd_nios2_arch,
     &bfd_ns32k_arch,
     &bfd_or1k_arch,
diff -rup binutils.orig/bfd/bfd-in2.h binutils-2.30/bfd/bfd-in2.h
--- binutils.orig/bfd/bfd-in2.h	2019-03-07 13:21:14.244464831 +0000
+++ binutils-2.30/bfd/bfd-in2.h	2019-03-07 14:44:05.704268413 +0000
@@ -2399,6 +2399,9 @@ enum bfd_architecture
 #define bfd_mach_wasm32        1
   bfd_arch_pru,       /* PRU.  */
 #define bfd_mach_pru           0
+  bfd_arch_nfp,       /* Netronome Flow Processor */
+#define bfd_mach_nfp3200       0x3200
+#define bfd_mach_nfp6000       0x6000
   bfd_arch_last
   };
 
diff -rup binutils.orig/bfd/config.bfd binutils-2.30/bfd/config.bfd
--- binutils.orig/bfd/config.bfd	2019-03-07 13:21:14.245464823 +0000
+++ binutils-2.30/bfd/config.bfd	2019-03-07 14:44:05.705268406 +0000
@@ -181,6 +181,7 @@ m88*)		 targ_archs=bfd_m88k_arch ;;
 microblaze*)	 targ_archs=bfd_microblaze_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
 nds32*)		 targ_archs=bfd_nds32_arch ;;
+nfp)		 targ_archs=bfd_nfp_arch ;;
 nios2*)          targ_archs=bfd_nios2_arch ;;
 or1k*|or1knd*)	 targ_archs=bfd_or1k_arch ;;
 pdp11*)		 targ_archs=bfd_pdp11_arch ;;
@@ -1277,6 +1278,12 @@ case "${targ}" in
     targ_selvecs=nds32_elf32_le_vec
     ;;
 
+#ifdef BFD64
+  nfp-*-*)
+    targ_defvec=nfp_elf64_vec
+    ;;
+#endif
+
   ns32k-pc532-mach* | ns32k-pc532-ux*)
     targ_defvec=ns32k_aout_pc532mach_vec
     targ_underscore=yes
diff -rup binutils.orig/bfd/configure binutils-2.30/bfd/configure
--- binutils.orig/bfd/configure	2019-03-07 13:21:14.244464831 +0000
+++ binutils-2.30/bfd/configure	2019-03-07 14:44:05.706268397 +0000
@@ -14526,6 +14526,7 @@ do
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_le_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
+    nfp_elf64_vec)		 tb="$tb elf64-nfp.lo elf64.lo $elf" ;;
     nios2_elf32_be_vec)		 tb="$tb elf32-nios2.lo elf32.lo $elf" ;;
     nios2_elf32_le_vec)		 tb="$tb elf32-nios2.lo elf32.lo $elf" ;;
     ns32k_aout_pc532mach_vec)	 tb="$tb pc532-mach.lo aout-ns32k.lo" ;;
diff -rup binutils.orig/bfd/configure.ac binutils-2.30/bfd/configure.ac
--- binutils.orig/bfd/configure.ac	2019-03-07 13:21:14.264464675 +0000
+++ binutils-2.30/bfd/configure.ac	2019-03-07 14:44:05.706268397 +0000
@@ -584,6 +584,7 @@ do
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_le_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
+    nfp_elf64_vec)		 tb="$tb elf64-nfp.lo elf64.lo $elf" ;;
     nios2_elf32_be_vec)		 tb="$tb elf32-nios2.lo elf32.lo $elf" ;;
     nios2_elf32_le_vec)		 tb="$tb elf32-nios2.lo elf32.lo $elf" ;;
     ns32k_aout_pc532mach_vec)	 tb="$tb pc532-mach.lo aout-ns32k.lo" ;;
diff -rup binutils.orig/bfd/elf-bfd.h binutils-2.30/bfd/elf-bfd.h
--- binutils.orig/bfd/elf-bfd.h	2019-03-07 13:21:14.254464753 +0000
+++ binutils-2.30/bfd/elf-bfd.h	2019-03-07 14:44:05.706268397 +0000
@@ -1668,6 +1668,7 @@ struct bfd_elf_section_data
 #define elf_linked_to_section(sec) (elf_section_data(sec)->linked_to)
 #define elf_section_type(sec)	(elf_section_data(sec)->this_hdr.sh_type)
 #define elf_section_flags(sec)	(elf_section_data(sec)->this_hdr.sh_flags)
+#define elf_section_info(sec)	(elf_section_data(sec)->this_hdr.sh_info)
 #define elf_group_name(sec)	(elf_section_data(sec)->group.name)
 #define elf_group_id(sec)	(elf_section_data(sec)->group.id)
 #define elf_next_in_group(sec)	(elf_section_data(sec)->next_in_group)
diff -rup binutils.orig/bfd/Makefile.am binutils-2.30/bfd/Makefile.am
--- binutils.orig/bfd/Makefile.am	2019-03-07 13:21:14.244464831 +0000
+++ binutils-2.30/bfd/Makefile.am	2019-03-07 14:44:05.703268422 +0000
@@ -140,6 +140,7 @@ ALL_MACHINES = \
 	cpu-msp430.lo \
 	cpu-mt.lo \
 	cpu-nds32.lo \
+	cpu-nfp.lo \
 	cpu-nios2.lo \
 	cpu-ns32k.lo \
 	cpu-or1k.lo \
@@ -230,6 +231,7 @@ ALL_MACHINES_CFILES = \
 	cpu-msp430.c \
 	cpu-mt.c \
 	cpu-nds32.c \
+	cpu-nfp.c \
 	cpu-ns32k.c \
 	cpu-nios2.c \
 	cpu-or1k.c \
@@ -692,6 +694,7 @@ BFD64_BACKENDS = \
 	elf64-mips.lo \
 	elfxx-mips.lo \
 	elf64-mmix.lo \
+	elf64-nfp.lo \
 	elf64-ppc.lo \
 	elf32-riscv.lo \
 	elf64-riscv.lo \
@@ -731,6 +734,7 @@ BFD64_BACKENDS_CFILES = \
 	elf64-ia64-vms.c \
 	elf64-mips.c \
 	elf64-mmix.c \
+	elf64-nfp.c \
 	elf64-ppc.c \
 	elf64-s390.c \
 	elf64-sh64.c \
diff -rup binutils.orig/bfd/Makefile.in binutils-2.30/bfd/Makefile.in
--- binutils.orig/bfd/Makefile.in	2019-03-07 13:21:14.245464823 +0000
+++ binutils-2.30/bfd/Makefile.in	2019-03-07 14:44:05.704268413 +0000
@@ -474,6 +474,7 @@ ALL_MACHINES = \
 	cpu-msp430.lo \
 	cpu-mt.lo \
 	cpu-nds32.lo \
+	cpu-nfp.lo \
 	cpu-nios2.lo \
 	cpu-ns32k.lo \
 	cpu-or1k.lo \
@@ -564,6 +565,7 @@ ALL_MACHINES_CFILES = \
 	cpu-msp430.c \
 	cpu-mt.c \
 	cpu-nds32.c \
+	cpu-nfp.c \
 	cpu-ns32k.c \
 	cpu-nios2.c \
 	cpu-or1k.c \
@@ -1028,6 +1030,7 @@ BFD64_BACKENDS = \
 	elf64-mips.lo \
 	elfxx-mips.lo \
 	elf64-mmix.lo \
+	elf64-nfp.lo \
 	elf64-ppc.lo \
 	elf32-riscv.lo \
 	elf64-riscv.lo \
@@ -1067,6 +1070,7 @@ BFD64_BACKENDS_CFILES = \
 	elf64-ia64-vms.c \
 	elf64-mips.c \
 	elf64-mmix.c \
+	elf64-nfp.c \
 	elf64-ppc.c \
 	elf64-s390.c \
 	elf64-sh64.c \
@@ -1430,6 +1434,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-mt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nds32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nfp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nios2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-ns32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-or1k.Plo@am__quote@
@@ -1563,6 +1568,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-ia64.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-mips.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-mmix.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-nfp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-ppc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-riscv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf64-s390.Plo@am__quote@
diff -rup binutils.orig/bfd/targets.c binutils-2.30/bfd/targets.c
--- binutils.orig/bfd/targets.c	2019-03-07 13:21:14.261464698 +0000
+++ binutils-2.30/bfd/targets.c	2019-03-07 14:49:56.512460817 +0000
@@ -788,6 +788,7 @@ extern const bfd_target nds32_elf32_be_v
 extern const bfd_target nds32_elf32_le_vec;
 extern const bfd_target nds32_elf32_linux_be_vec;
 extern const bfd_target nds32_elf32_linux_le_vec;
+extern const bfd_target nfp_elf64_vec;
 extern const bfd_target nios2_elf32_be_vec;
 extern const bfd_target nios2_elf32_le_vec;
 extern const bfd_target ns32k_aout_pc532mach_vec;
@@ -1274,6 +1275,10 @@ static const bfd_target * const _bfd_tar
 	&nds32_elf32_linux_be_vec,
 	&nds32_elf32_linux_le_vec,
 
+#ifdef BFD64
+	&nfp_elf64_vec,
+#endif
+
 	&nios2_elf32_be_vec,
 	&nios2_elf32_le_vec,
 
diff -rup binutils.orig/binutils/NEWS binutils-2.30/binutils/NEWS
--- binutils.orig/binutils/NEWS	2019-03-07 13:21:13.399471393 +0000
+++ binutils-2.30/binutils/NEWS	2019-03-07 14:44:05.712268349 +0000
@@ -1,5 +1,7 @@
 -*- text -*-
 
+* Add support for disassembling netronome Flow Processor (NFP) firmware files.
+
 Changes in 2.30:
 
 * Add --debug-dump=links option to readelf and --dwarf=links option to objdump
diff -rup binutils.orig/binutils/readelf.c binutils-2.30/binutils/readelf.c
--- binutils.orig/binutils/readelf.c	2019-03-07 13:21:13.417471253 +0000
+++ binutils-2.30/binutils/readelf.c	2019-03-07 14:44:05.715268325 +0000
@@ -131,6 +131,7 @@
 #include "elf/mt.h"
 #include "elf/msp430.h"
 #include "elf/nds32.h"
+#include "elf/nfp.h"
 #include "elf/nios2.h"
 #include "elf/or1k.h"
 #include "elf/pj.h"
@@ -765,6 +766,7 @@ guess_is_rela (unsigned int e_machine)
     case EM_CYGNUS_M32R:
     case EM_SCORE:
     case EM_XGATE:
+    case EM_NFP:
       return FALSE;
 
       /* Targets that use RELA relocations.  */
@@ -1549,6 +1551,13 @@ dump_relocations (Filedata *          fi
 	case EM_TI_PRU:
 	  rtype = elf_pru_reloc_type (type);
 	  break;
+
+	case EM_NFP:
+	  if (EF_NFP_MACH (filedata->file_header.e_flags) == E_NFP_MACH_3200)
+	    rtype = elf_nfp3200_reloc_type (type);
+	  else
+	    rtype = elf_nfp_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -2461,6 +2470,7 @@ get_machine_name (unsigned e_machine)
     case EM_RISCV: 	 	return "RISC-V";
     case EM_LANAI:		return "Lanai 32-bit processor";
     case EM_BPF:		return "Linux BPF";
+    case EM_NFP:		return "Netronome Flow Processor";
 
       /* Large numbers...  */
     case EM_MT:                 return "Morpho Techologies MT processor";
@@ -3423,6 +3433,18 @@ get_machine_flags (Filedata * filedata,
 	  decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
 	  break;
 
+	case EM_NFP:
+	  switch (EF_NFP_MACH (e_flags))
+	    {
+	    case E_NFP_MACH_3200:
+	      strcat (buf, ", NFP-32xx");
+	      break;
+	    case E_NFP_MACH_6000:
+	      strcat (buf, ", NFP-6xxx");
+	      break;
+	    }
+	  break;
+
 	case EM_RISCV:
 	  if (e_flags & EF_RISCV_RVC)
 	    strcat (buf, ", RVC");
@@ -4118,6 +4140,18 @@ get_msp430x_section_type_name (unsigned
 }
 
 static const char *
+get_nfp_section_type_name (unsigned int sh_type)
+{
+  switch (sh_type)
+    {
+    case SHT_NFP_MECONFIG:	return "NFP_MECONFIG";
+    case SHT_NFP_INITREG:	return "NFP_INITREG";
+    case SHT_NFP_UDEBUG:	return "NFP_UDEBUG";
+    default:			return NULL;
+    }
+}
+
+static const char *
 get_v850_section_type_name (unsigned int sh_type)
 {
   switch (sh_type)
@@ -4204,6 +4238,9 @@ get_section_type_name (Filedata * fileda
 	    case EM_MSP430:
 	      result = get_msp430x_section_type_name (sh_type);
 	      break;
+	    case EM_NFP:
+	      result = get_nfp_section_type_name (sh_type);
+	      break;
 	    case EM_V800:
 	    case EM_V850:
 	    case EM_CYGNUS_V850:
diff -rup binutils.orig/config.sub binutils-2.30/config.sub
--- binutils.orig/config.sub	2019-03-07 13:21:14.229464947 +0000
+++ binutils-2.30/config.sub	2019-03-07 14:53:14.241881286 +0000
@@ -293,6 +293,7 @@ case $basic_machine in
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
+	| nfp \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
 	| open8 | or1k | or1knd | or32 \
diff -rup binutils.orig/include/dis-asm.h binutils-2.30/include/dis-asm.h
--- binutils.orig/include/dis-asm.h	2019-03-07 13:21:14.298464411 +0000
+++ binutils-2.30/include/dis-asm.h	2019-03-07 14:44:05.716268317 +0000
@@ -255,6 +255,7 @@ extern disassembler_ftype cris_get_disas
 extern void print_aarch64_disassembler_options (FILE *);
 extern void print_i386_disassembler_options (FILE *);
 extern void print_mips_disassembler_options (FILE *);
+extern void print_nfp_disassembler_options (FILE *);
 extern void print_ppc_disassembler_options (FILE *);
 extern void print_riscv_disassembler_options (FILE *);
 extern void print_arm_disassembler_options (FILE *);
diff -rup binutils.orig/include/elf/common.h binutils-2.30/include/elf/common.h
--- binutils.orig/include/elf/common.h	2019-03-07 13:21:14.295464435 +0000
+++ binutils-2.30/include/elf/common.h	2019-03-07 14:44:05.716268317 +0000
@@ -338,6 +338,7 @@
 #define EM_RISCV 	243 	/* RISC-V */
 #define EM_LANAI	244	/* Lanai 32-bit processor.  */
 #define EM_BPF		247	/* Linux BPF â€“ in-kernel virtual machine.  */
+#define EM_NFP		250	/* Netronome Flow Processor.  */
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
diff -rup binutils.orig/opcodes/configure binutils-2.30/opcodes/configure
--- binutils.orig/opcodes/configure	2019-03-07 13:21:13.445471036 +0000
+++ binutils-2.30/opcodes/configure	2019-03-07 14:44:05.718268301 +0000
@@ -12700,6 +12700,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
+	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
 	bfd_ns32k_arch)		ta="$ta ns32k-dis.lo" ;;
 	bfd_or1k_arch)		ta="$ta or1k-asm.lo or1k-desc.lo or1k-dis.lo or1k-ibld.lo or1k-opc.lo" using_cgen=yes ;;
diff -rup binutils.orig/opcodes/configure.ac binutils-2.30/opcodes/configure.ac
--- binutils.orig/opcodes/configure.ac	2019-03-07 13:21:13.445471036 +0000
+++ binutils-2.30/opcodes/configure.ac	2019-03-07 14:44:05.718268301 +0000
@@ -300,6 +300,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
+	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
 	bfd_ns32k_arch)		ta="$ta ns32k-dis.lo" ;;
 	bfd_or1k_arch)		ta="$ta or1k-asm.lo or1k-desc.lo or1k-dis.lo or1k-ibld.lo or1k-opc.lo" using_cgen=yes ;;
diff -rup binutils.orig/opcodes/disassemble.c binutils-2.30/opcodes/disassemble.c
--- binutils.orig/opcodes/disassemble.c	2019-03-07 13:21:13.438471090 +0000
+++ binutils-2.30/opcodes/disassemble.c	2019-03-07 14:44:05.718268301 +0000
@@ -69,6 +69,7 @@
 #define ARCH_mt
 #define ARCH_msp430
 #define ARCH_nds32
+#define ARCH_nfp
 #define ARCH_nios2
 #define ARCH_ns32k
 #define ARCH_or1k
@@ -306,6 +307,11 @@ disassembler (enum bfd_architecture a,
       disassemble = print_insn_nds32;
       break;
 #endif
+#ifdef ARCH_nfp
+    case bfd_arch_nfp:
+      disassemble = print_insn_nfp;
+      break;
+#endif
 #ifdef ARCH_ns32k
     case bfd_arch_ns32k:
       disassemble = print_insn_ns32k;
@@ -576,6 +582,9 @@ disassembler_usage (FILE *stream ATTRIBU
 #ifdef ARCH_mips
   print_mips_disassembler_options (stream);
 #endif
+#ifdef ARCH_nfp
+  print_nfp_disassembler_options (stream);
+#endif
 #ifdef ARCH_powerpc
   print_ppc_disassembler_options (stream);
 #endif
diff -rup binutils.orig/opcodes/disassemble.h binutils-2.30/opcodes/disassemble.h
--- binutils.orig/opcodes/disassemble.h	2019-03-07 13:21:13.444471043 +0000
+++ binutils-2.30/opcodes/disassemble.h	2019-03-07 14:44:05.718268301 +0000
@@ -77,6 +77,7 @@ extern int print_insn_moxie		(bfd_vma, d
 extern int print_insn_msp430		(bfd_vma, disassemble_info *);
 extern int print_insn_mt                (bfd_vma, disassemble_info *);
 extern int print_insn_nds32		(bfd_vma, disassemble_info *);
+extern int print_insn_nfp		(bfd_vma, disassemble_info *);
 extern int print_insn_ns32k		(bfd_vma, disassemble_info *);
 extern int print_insn_or1k		(bfd_vma, disassemble_info *);
 extern int print_insn_pdp11		(bfd_vma, disassemble_info *);
diff -rup binutils.orig/opcodes/Makefile.am binutils-2.30/opcodes/Makefile.am
--- binutils.orig/opcodes/Makefile.am	2019-03-07 13:21:13.445471036 +0000
+++ binutils-2.30/opcodes/Makefile.am	2019-03-07 14:44:05.717268309 +0000
@@ -209,6 +209,7 @@ TARGET_LIBOPCODES_CFILES = \
 	mt-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
+	nfp-dis.c \
 	nios2-dis.c \
 	nios2-opc.c \
 	ns32k-dis.c \
diff -rup binutils.orig/opcodes/Makefile.in binutils-2.30/opcodes/Makefile.in
--- binutils.orig/opcodes/Makefile.in	2019-03-07 13:21:13.426471183 +0000
+++ binutils-2.30/opcodes/Makefile.in	2019-03-07 14:44:05.717268309 +0000
@@ -511,6 +511,7 @@ TARGET_LIBOPCODES_CFILES = \
 	mt-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
+	nfp-dis.c \
 	nios2-dis.c \
 	nios2-opc.c \
 	ns32k-dis.c \
@@ -920,6 +921,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-asm.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nfp-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nios2-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nios2-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ns32k-dis.Plo@am__quote@
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/bfd/cpu-nfp.c	2019-03-07 14:44:05.706268397 +0000
@@ -0,0 +1,62 @@
+/* BFD library support routines for the NFP.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   Contributed by Francois H. Theron <francois.theron@netronome.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+static const bfd_arch_info_type *
+bfd_nfp_compatible (const bfd_arch_info_type * a,
+		    const bfd_arch_info_type * b)
+{
+  if (a->arch != b->arch)
+    return NULL;
+
+  if (a->mach != b->mach)
+    return NULL;
+
+  return a;
+}
+
+#define N(machine, print, default, next)			\
+{								\
+  32,								\
+  64,								\
+  8,								\
+  bfd_arch_nfp,							\
+  machine,							\
+  "nfp",							\
+  print,							\
+  3,								\
+  default,							\
+  bfd_nfp_compatible,						\
+  bfd_default_scan,						\
+  bfd_arch_default_fill,					\
+  next								\
+}
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  N (bfd_mach_nfp3200, "NFP-32xx", FALSE, NULL)
+};
+
+const bfd_arch_info_type bfd_nfp_arch =
+  N (bfd_mach_nfp6000, "NFP-6xxx", TRUE, &arch_info_struct[0]);
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/bfd/elf64-nfp.c	2019-03-07 14:44:05.706268397 +0000
@@ -0,0 +1,276 @@
+/* NFP-specific support for 64-bit ELF
+   Copyright (C) 2017-2018 Free Software Foundation, Inc.
+   Contributed by Francois H. Theron <francois.theron@netronome.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/nfp.h"
+#include "bfd_stdint.h"
+
+
+static bfd_reloc_status_type
+elf64_nfp_reloc (bfd * abfd ATTRIBUTE_UNUSED,
+		 arelent * reloc_entry,
+		 asymbol * symbol,
+		 void *data ATTRIBUTE_UNUSED,
+		 asection * input_section,
+		 bfd * output_bfd,
+		 char **error_message ATTRIBUTE_UNUSED);
+
+/* We don't actually apply any relocations in this toolset
+   so we make them all do nothing, but at least display useful
+   names.
+   Most of these are mainly used by the NFP toolchain to resolve things
+   before the final ELF file is created.  */
+static reloc_howto_type elf_nfp_howto_table[] =
+{
+  HOWTO (R_NFP_NOTYPE,		/* Type.  */
+	 0,			/* Rightshift.  */
+	 3,			/* Size.  */
+	 0,			/* Bitsize.  */
+	 FALSE,			/* PC_relative.  */
+	 0,			/* Bitpos.  */
+	 complain_overflow_dont,/* Complain_on_overflow.  */
+	 elf64_nfp_reloc,	/* Special_function.  */
+	 "R_NFP_NOTYPE",	/* Name.  */
+	 FALSE,			/* Partial_inplace.  */
+	 0,			/* Src_mask.  */
+	 0,			/* Dst_mask.  */
+	 FALSE),		/* PCrel_offset.  */
+  HOWTO (R_NFP_W32LE, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32LE",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC8_A, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC8_A",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC8_B, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC8_B",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_IMMED8_I, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_IMMED8_I",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SC, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SC",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_IMMED_LO16_I_A, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_IMMED_LO16_I_A",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_IMMED_LO16_I_B, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_IMMED_LO16_I_B",
+	 TRUE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC7_B, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC7_B",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC7_A, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC7_A",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC8_I_B, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC8_I_B",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SRC8_I_A, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SRC8_I_A",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_IMMED_HI16_I_A, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_IMMED_HI16_I_A",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_IMMED_HI16_I_B, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_IMMED_HI16_I_B",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64LE, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64LE",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_SH_INFO, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_SH_INFO",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32BE, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32BE",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64BE, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64BE",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32_29_24, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32_29_24",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32LE_AND, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32LE_AND",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32BE_AND, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32BE_AND",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32LE_OR, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32LE_OR",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W32BE_OR, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W32BE_OR",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64LE_AND, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64LE_AND",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64BE_AND, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64BE_AND",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64LE_OR, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64LE_OR",
+	 FALSE, 0, 0, FALSE),
+  HOWTO (R_NFP_W64BE_OR, 0, 3, 0, FALSE, 0,
+	 complain_overflow_dont, elf64_nfp_reloc,
+	 "R_NFP_W64BE_OR",
+	 FALSE, 0, 0, FALSE)
+};
+
+static bfd_boolean
+elf64_nfp_object_p (bfd * abfd)
+{
+  /* If the e_machine value is one of the unofficial ones, we convert
+     it first and set e_flags accordingly for later consistency.  */
+  if (elf_elfheader (abfd)->e_machine == E_NFP_MACH_3200)
+    {
+      elf_elfheader (abfd)->e_machine = EM_NFP;
+      elf_elfheader (abfd)->e_flags &= ~EF_NFP_SET_MACH (~0);
+      elf_elfheader (abfd)->e_flags |= EF_NFP_SET_MACH (E_NFP_MACH_3200);
+    }
+  else if (elf_elfheader (abfd)->e_machine == E_NFP_MACH_6000)
+    {
+      elf_elfheader (abfd)->e_machine = EM_NFP;
+      elf_elfheader (abfd)->e_flags &= ~EF_NFP_SET_MACH (~0);
+      elf_elfheader (abfd)->e_flags |= EF_NFP_SET_MACH (E_NFP_MACH_6000);
+    }
+
+  if (elf_elfheader (abfd)->e_machine == EM_NFP)
+    {
+      int e_mach = EF_NFP_MACH (elf_elfheader (abfd)->e_flags);
+
+      switch (e_mach)
+	{
+	case E_NFP_MACH_3200:
+	case E_NFP_MACH_6000:
+	  if (!bfd_default_set_arch_mach (abfd, bfd_arch_nfp, e_mach))
+	    return FALSE;
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf64_nfp_section_from_shdr (bfd * abfd,
+			     Elf_Internal_Shdr * hdr,
+			     const char *name, int shindex)
+{
+  switch (hdr->sh_type)
+    {
+    case SHT_NFP_INITREG:
+    case SHT_NFP_MECONFIG:
+    case SHT_NFP_UDEBUG:
+      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+    default:
+      return FALSE;
+    }
+}
+
+bfd_reloc_status_type
+elf64_nfp_reloc (bfd * abfd ATTRIBUTE_UNUSED,
+		 arelent * reloc_entry ATTRIBUTE_UNUSED,
+		 asymbol * symbol ATTRIBUTE_UNUSED,
+		 void *data ATTRIBUTE_UNUSED,
+		 asection * input_section ATTRIBUTE_UNUSED,
+		 bfd * output_bfd ATTRIBUTE_UNUSED,
+		 char **error_message ATTRIBUTE_UNUSED)
+{
+  return bfd_reloc_ok;
+}
+
+static bfd_boolean
+elf64_nfp_info_to_howto (bfd * abfd ATTRIBUTE_UNUSED,
+			 arelent * cache_ptr, Elf_Internal_Rela * dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF64_R_TYPE (dst->r_info);
+  if (r_type >= R_NFP_MAX)
+    {
+      /* xgettext:c-format */
+      _bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+			  abfd, r_type);
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+  cache_ptr->howto = &elf_nfp_howto_table[r_type];
+  return TRUE;
+}
+
+static reloc_howto_type *
+elf64_nfp_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			     bfd_reloc_code_real_type code ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+static reloc_howto_type *
+elf64_nfp_reloc_name_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			     const char *r_name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+#define ELF_ARCH		bfd_arch_nfp
+#define ELF_MACHINE_CODE	EM_NFP
+#define ELF_MACHINE_ALT1	E_NFP_MACH_6000
+#define ELF_MACHINE_ALT2	E_NFP_MACH_3200
+#define ELF_MAXPAGESIZE		1
+#define TARGET_LITTLE_NAME	"elf64-nfp"
+#define TARGET_LITTLE_SYM       nfp_elf64_vec
+
+#define elf_backend_object_p		elf64_nfp_object_p
+#define elf_backend_section_from_shdr   elf64_nfp_section_from_shdr
+#define elf_info_to_howto		elf64_nfp_info_to_howto
+#define bfd_elf64_bfd_reloc_type_lookup	     elf64_nfp_reloc_type_lookup
+#define bfd_elf64_bfd_reloc_name_lookup      elf64_nfp_reloc_name_lookup
+
+#include "elf64-target.h"
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/binutils/testsuite/binutils-all/nfp/objdump.exp	2019-03-07 14:44:05.715268325 +0000
@@ -0,0 +1,52 @@
+#   Copyright (C) 2004-2018 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+if {![istarget nfp*-*-*]} {
+  return
+}
+
+if {![is_remote host] && [which $OBJDUMP] == 0} then {
+  perror "$OBJDUMP does not exist"
+  return
+}
+
+send_user "Version [binutil_version $OBJDUMP]"
+
+set outfile "tmpdir/dump.out"
+
+set testname "NFP dissasembler NFP-6xxx instructions"
+set dumpfile "$srcdir/$subdir/test1.d"
+remote_exec host "${OBJDUMP} -d $srcdir/$subdir/test1_nfp6000.nffw" "" "/dev/null" "$outfile"
+if { [regexp_diff "${outfile}" "${dumpfile}"] } then {
+  fail $testname
+  return
+}
+
+set testname "NFP dissasembler options: no-pc,ctx4"
+set dumpfile "$srcdir/$subdir/test2_no-pc_ctx4.d"
+remote_exec host "${OBJDUMP} -M no-pc,ctx4 -d $srcdir/$subdir/test2_nfp6000.nffw" "" "/dev/null" "$outfile"
+if { [regexp_diff "${outfile}" "${dumpfile}"] } then {
+  fail $testname
+  return
+}
+
+set testname "NFP dissasembler options: ctx8"
+set dumpfile "$srcdir/$subdir/test2_ctx8.d"
+remote_exec host "${OBJDUMP} -M ctx8 -d $srcdir/$subdir/test2_nfp6000.nffw" "" "/dev/null" "$outfile"
+if { [regexp_diff "${outfile}" "${dumpfile}"] } then {
+  fail $testname
+  return
+}
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/binutils/testsuite/binutils-all/nfp/test1.d	2019-03-07 14:47:35.561586781 +0000
@@ -0,0 +1,997 @@
+
+.*:     file format elf64-nfp
+
+
+Disassembly of section \.text\.i32\.me0:
+
+0000000000000000 <\.text\.i32\.me0>:
+   0:	000540f0012cd000 	  \.0  immed\[gprA_0, 0x1234\]
+   8:	0002c0f0012cd280 	  \.1  immed\[n\$reg_0, 0x1234\]
+  10:	000220f0012cd281 	  \.2  immed\[n\$reg_1, 0x1234\]
+  18:	000660f0012cd200 	  \.3  immed\[\*l\$index0, 0x1234\]
+  20:	0007c0f0012cd220 	  \.4  immed\[\*l\$index1, 0x1234\]
+  28:	000fa0f0012cd230 	  \.5  immed\[\*l\$index1\+\+, 0x1234\]
+  30:	000f40f0012cd231 	  \.6  immed\[\*l\$index1--, 0x1234\]
+  38:	0008c8f0012cd200 	  \.7  immed\[\*l\$index2, 0x1234\]
+  40:	0000a8f0012cd210 	  \.8  immed\[\*l\$index2\+\+, 0x1234\]
+  48:	000048f0012cd211 	  \.9  immed\[\*l\$index2--, 0x1234\]
+  50:	000968f0012cd220 	 \.10  immed\[\*l\$index3, 0x1234\]
+  58:	0007e0f0012cd203 	 \.11  immed\[\*l\$index0\[3\], 0x1234\]
+  60:	000540f0012cd225 	 \.12  immed\[\*l\$index1\[5\], 0x1234\]
+  68:	000b28f0012cd207 	 \.13  immed\[\*l\$index2\[7\], 0x1234\]
+  70:	000de8f0012cd229 	 \.14  immed\[\*l\$index3\[9\], 0x1234\]
+  78:	000000f00ff003ff 	 \.15  immed\[gprB_0, 0xffff\]
+  80:	000d60f220000bff 	 \.16  immed_b1\[gprB_2, 0xff\]
+  88:	000f60f6200007ff 	 \.17  immed_b3\[gprB_1, 0xff\]
+  90:	000080f080000f00 	 \.18  immed\[gprB_3, 0xffffffff\]
+  98:	000100f086600f77 	 \.19  immed\[gprB_3, 0xffff9988\]
+  a0:	000940f0012cd180 	 \.20  immed\[\$xfer_0, 0x1234\]
+  a8:	000a00f0043c8581 	 \.21  immed\[\$xfer_1, 0x4321\]
+  b0:	000180f0056de1ce 	 \.22  immed\[\$xfer_30, 0x5678\]
+  b8:	0007c0f0400e8401 	 \.23  immed_w0\[gprA_1, 0xa1\]
+  c0:	000440f4400e8802 	 \.24  immed_w1\[gprA_2, 0xa2\]
+  c8:	000d00f4000e8c03 	 \.25  immed\[gprA_3, 0xa3, <<16\]
+  d0:	000520f001200334 	 \.26  immed\[gprB_0, 0x1234\]
+  d8:	000fa0f0400007b1 	 \.27  immed_w0\[gprB_1, 0xb1\]
+  e0:	000c20f440000bb2 	 \.28  immed_w1\[gprB_2, 0xb2\]
+  e8:	000560f400000fb3 	 \.29  immed\[gprB_3, 0xb3, <<16\]
+  f0:	000660f200000fb3 	 \.30  immed\[gprB_3, 0xb3, <<8\]
+  f8:	0001b0f200000fb3 	 \.31  immed\[gprB_3, 0xb3, <<8\], predicate_cc
+ 100:	0001c2f200000fb3 	 \.32  immed\[gprB_3, 0xb3, <<8\], gpr_wrboth
+ 108:	000ba0a0300c2f00 	 \.33  alu\[--, --, B, 0xb\]
+ 110:	0005a081f200da00 	 \.34  alu_shf\[--, --, B, 0x16, <<1\]
+ 118:	000be081d2018600 	 \.35  alu_shf\[--, --, B, 0x21, <<3\]
+ 120:	000240801201b200 	 \.36  alu_shf\[--, --, B, 0x2c, <<31\]
+ 128:	000fa081f800da00 	 \.37  alu_shf\[\$xfer_0, --, B, 0x16, <<1\]
+ 130:	0009e081f840da00 	 \.38  alu_shf\[\$xfer_4, --, B, 0x16, <<1\]
+ 138:	00006081fc80da00 	 \.39  alu_shf\[\$xfer_24, --, B, 0x16, <<1\]
+ 140:	000a2081fcf0da00 	 \.40  alu_shf\[\$xfer_31, --, B, 0x16, <<1\]
+ 148:	0004a0a0280c2f00 	 \.41  alu\[n\$reg_0, --, B, 0xb\]
+ 150:	0001e0a0281c2f00 	 \.42  alu\[n\$reg_1, --, B, 0xb\]
+ 158:	000880a0a00c2400 	 \.43  alu\[\*l\$index0, gprA_0, \+, 0x9\]
+ 160:	000100a0a43c2400 	 \.44  alu\[\*n\$index\+\+, gprA_0, \+, 0x9\]
+ 168:	000b208bc500a600 	 \.45  alu_shf\[\*l\$index0, gprA_0, OR, 0x9, <<4\]
+ 170:	000b00a0a20c2400 	 \.46  alu\[\*l\$index1, gprA_0, \+, 0x9\]
+ 178:	000740a0a30c2400 	 \.47  alu\[\*l\$index1\+\+, gprA_0, \+, 0x9\]
+ 180:	000200a0a31c2400 	 \.48  alu\[\*l\$index1--, gprA_0, \+, 0x9\]
+ 188:	000628a0a00c2400 	 \.49  alu\[\*l\$index2, gprA_0, \+, 0x9\]
+ 190:	000988aa210c2400 	 \.50  alu\[\*l\$index2\+\+, gprA_0, OR, 0x9\]
+ 198:	000f28a0a11c2400 	 \.51  alu\[\*l\$index2--, gprA_0, \+, 0x9\]
+ 1a0:	0005a8a0a20c2400 	 \.52  alu\[\*l\$index3, gprA_0, \+, 0x9\]
+ 1a8:	000480a0a03c2400 	 \.53  alu\[\*l\$index0\[3\], gprA_0, \+, 0x9\]
+ 1b0:	000800a0a25c2400 	 \.54  alu\[\*l\$index1\[5\], gprA_0, \+, 0x9\]
+ 1b8:	000c68a0a07c2400 	 \.55  alu\[\*l\$index2\[7\], gprA_0, \+, 0x9\]
+ 1c0:	000aa8a0a29c2400 	 \.56  alu\[\*l\$index3\[9\], gprA_0, \+, 0x9\]
+ 1c8:	000cc4b0c008a400 	 \.57  alu\[gprB_0, \*l\$index3\[9\], \+, gprA_0\]
+ 1d0:	000fe4b0c008c000 	 \.58  alu\[gprB_0, \*l\$index3\+\+, \+, gprA_0\]
+ 1d8:	000ac4b0c008c400 	 \.59  alu\[gprB_0, \*l\$index3--, \+, gprA_0\]
+ 1e0:	000bc4b080000229 	 \.60  alu\[gprB_0, \*l\$index3\[9\], \+, gprB_0\]
+ 1e8:	000724b080000230 	 \.61  alu\[gprB_0, \*l\$index3\+\+, \+, gprB_0\]
+ 1f0:	0007c4b080000231 	 \.62  alu\[gprB_0, \*l\$index3--, \+, gprB_0\]
+ 1f8:	000664b080000211 	 \.63  alu\[gprB_0, \*l\$index2--, \+, gprB_0\]
+ 200:	000a60b080000231 	 \.64  alu\[gprB_0, \*l\$index1--, \+, gprB_0\]
+ 208:	000bc0b080000211 	 \.65  alu\[gprB_0, \*l\$index0--, \+, gprB_0\]
+ 210:	000340b080000200 	 \.66  alu\[gprB_0, \*l\$index0, \+, gprB_0\]
+ 218:	000ee4b080000200 	 \.67  alu\[gprB_0, \*l\$index2, \+, gprB_0\]
+ 220:	000100b080000241 	 \.68  alu\[gprB_0, \*n\$index, \+, gprB_0\]
+ 228:	0004809bf0000241 	 \.69  alu_shf\[gprB_0, \*n\$index, OR, gprB_0, <<1\]
+ 230:	000f20a0001fff00 	 \.70  alu\[gprA_1, --, B, 0xff\]
+ 238:	0005c0b0002fff00 	 \.71  alu\[gprB_2, --, B, 0xff\]
+ 240:	000940a0000d6f00 	 \.72  alu\[gprA_0, --, B, 0x5b\]
+ 248:	000440a2000d6f00 	 \.73  alu\[gprA_0, --, ~B, 0x5b\]
+ 250:	000de081f032f200 	 \.74  alu_shf\[gprA_3, --, B, 0x5c, <<1\]
+ 258:	000de091d012f600 	 \.75  alu_shf\[gprB_1, --, B, 0x5d, <<3\]
+ 260:	000d60901022fa00 	 \.76  alu_shf\[gprB_2, --, B, 0x5e, <<31\]
+ 268:	000e40a0c0000402 	 \.77  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 270:	000340a2c0000402 	 \.78  alu\[gprA_0, gprB_1, \+16, gprA_2\]
+ 278:	000040a4c0000402 	 \.79  alu\[gprA_0, gprB_1, \+8, gprA_2\]
+ 280:	0007a0a8c0000402 	 \.80  alu\[gprA_0, gprB_1, \+carry, gprA_2\]
+ 288:	000d40a6c0000402 	 \.81  alu\[gprA_0, gprB_1, -carry, gprA_2\]
+ 290:	000aa0aac0000402 	 \.82  alu\[gprA_0, gprB_1, -, gprA_2\]
+ 298:	0009a0acc0000402 	 \.83  alu\[gprA_0, gprB_1, B-A, gprA_2\]
+ 2a0:	000da0aa40000402 	 \.84  alu\[gprA_0, gprB_1, OR, gprA_2\]
+ 2a8:	000740a440000402 	 \.85  alu\[gprA_0, gprB_1, AND, gprA_2\]
+ 2b0:	000a40a640000402 	 \.86  alu\[gprA_0, gprB_1, ~AND, gprA_2\]
+ 2b8:	0000a0a840000402 	 \.87  alu\[gprA_0, gprB_1, AND~, gprA_2\]
+ 2c0:	000ea0ac40000402 	 \.88  alu\[gprA_0, gprB_1, XOR, gprA_2\]
+ 2c8:	000321a0c0000402 	 \.89  alu\[gprA_0, gprB_1, \+, gprA_2\], no_cc
+ 2d0:	000990a0c0000402 	 \.90  alu\[gprA_0, gprB_1, \+, gprA_2\], predicate_cc
+ 2d8:	0009e2a0c0000402 	 \.91  alu\[gprA_0, gprB_1, \+, gprA_2\], gpr_wrboth
+ 2e0:	000353a0c0000402 	 \.92  alu\[gprA_0, gprB_1, \+, gprA_2\], no_cc, gpr_wrboth, predicate_cc
+ 2e8:	000d418b70080602 	 \.93  alu_shf\[gprA_0, gprB_1, OR, gprA_2, <<9\], no_cc
+ 2f0:	0006708a90080502 	 \.94  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>9\], predicate_cc
+ 2f8:	000ea28a90080402 	 \.95  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>rot9\], gpr_wrboth
+ 300:	000e138b70080402 	 \.96  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>rot23\], no_cc, gpr_wrboth, predicate_cc
+ 308:	000ba08a00080602 	 \.97  alu_shf\[gprA_0, gprB_1, OR, gprA_2, <<indirect\]
+ 310:	0000208a00080502 	 \.98  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>indirect\]
+ 318:	000ba0a0300c2f00 	 \.99  alu\[--, --, B, 0xb\]
+ 320:	000ae09d40380101 	\.100  asr\[gprB_3, gprA_1, >>20\]
+ 328:	000ba0a0300c2f00 	\.101  alu\[--, --, B, 0xb\]
+ 330:	000ea09d40310500 	\.102  asr\[gprB_3, \*n\$index, >>20\]
+ 338:	000ba0a0300c2f00 	\.103  alu\[--, --, B, 0xb\]
+ 340:	0007a09d40314100 	\.104  asr\[gprB_3, \*l\$index0, >>20\]
+ 348:	000ba0a0300c2f00 	\.105  alu\[--, --, B, 0xb\]
+ 350:	0000249d40316100 	\.106  asr\[gprB_3, \*l\$index3, >>20\]
+ 358:	000ba0a0300c2f00 	\.107  alu\[--, --, B, 0xb\]
+ 360:	000a049d40314100 	\.108  asr\[gprB_3, \*l\$index2, >>20\]
+ 368:	000ba0a0300c2f00 	\.109  alu\[--, --, B, 0xb\]
+ 370:	0004a08d45010d00 	\.110  asr\[\*l\$index0, \*n\$index\+\+, >>20\]
+ 378:	000ba0a0300c2f00 	\.111  alu\[--, --, B, 0xb\]
+ 380:	000ee08d45810d00 	\.112  asr\[\*l\$index1, \*n\$index\+\+, >>20\]
+ 388:	000ba0a0300c2f00 	\.113  alu\[--, --, B, 0xb\]
+ 390:	000a088d45010d00 	\.114  asr\[\*l\$index2, \*n\$index\+\+, >>20\]
+ 398:	000ba0a0300c2f00 	\.115  alu\[--, --, B, 0xb\]
+ 3a0:	0007819d40380101 	\.116  asr\[gprB_3, gprA_1, >>20\], no_cc
+ 3a8:	000ba0a0300c2f00 	\.117  alu\[--, --, B, 0xb\]
+ 3b0:	000d309d40380101 	\.118  asr\[gprB_3, gprA_1, >>20\], predicate_cc
+ 3b8:	000ba0a0300c2f00 	\.119  alu\[--, --, B, 0xb\]
+ 3c0:	000ba28d40380101 	\.120  asr\[gprA_3, gprA_1, >>20\], gpr_wrboth
+ 3c8:	0008c0d818c08120 	\.121  beq\[\.99\]
+ 3d0:	000d00d877c08120 	\.122  beq\[\.479\]
+ 3d8:	000440d877e08120 	\.123  beq\[\.479\], defer\[2\]
+ 3e0:	000000f0000c0300 	\.124  nop
+ 3e8:	000000f0000c0300 	\.125  nop
+ 3f0:	000540d877c08021 	\.126  bne\[\.479\]
+ 3f8:	0004c0d877c08022 	\.127  bmi\[\.479\]
+ 400:	000420d877c08023 	\.128  bpl\[\.479\]
+ 408:	0007c0d877c08024 	\.129  bcs\[\.479\]
+ 410:	0007c0d877c08024 	\.130  bcs\[\.479\]
+ 418:	000720d877c08025 	\.131  bcc\[\.479\]
+ 420:	000720d877c08025 	\.132  bcc\[\.479\]
+ 428:	0006a0d877c08026 	\.133  bvs\[\.479\]
+ 430:	000640d877c08027 	\.134  bvc\[\.479\]
+ 438:	0001c0d877c08028 	\.135  bge\[\.479\]
+ 440:	000120d877c08029 	\.136  blt\[\.479\]
+ 448:	000040d877c0802b 	\.137  bgt\[\.479\]
+ 450:	0000a0d877c0802a 	\.138  ble\[\.479\]
+ 458:	000c60d818c08038 	\.139  br\[\.99\]
+ 460:	000920d818d08038 	\.140  br\[\.99\], defer\[1\]
+ 468:	000000f0000c0300 	\.141  nop
+ 470:	000bc0d077c09000 	\.142  br_bclr\[gprA_0, 3, \.479\]
+ 478:	000980d077c0e004 	\.143  br_bclr\[gprA_4, 23, \.479\]
+ 480:	0002a0d077c0082c 	\.144  br_bclr\[gprB_2, 11, \.479\]
+ 488:	000300d077c02423 	\.145  br_bclr\[gprB_9, 2, \.479\]
+ 490:	000260d077c02421 	\.146  br_bclr\[gprB_9, 0, \.479\]
+ 498:	000280d077c02420 	\.147  br_bclr\[gprB_9, 31, \.479\]
+ 4a0:	000f00d077f02423 	\.148  br_bclr\[gprB_9, 2, \.479\], defer\[3\]
+ 4a8:	000000f0000c0300 	\.149  nop
+ 4b0:	000000f0000c0300 	\.150  nop
+ 4b8:	000000f0000c0300 	\.151  nop
+ 4c0:	000680d077c42c2b 	\.152  br_bset\[gprB_11, 10, \.479\]
+ 4c8:	0006e0d077c4ac0b 	\.153  br_bset\[gprA_11, 10, \.479\]
+ 4d0:	0002a0c877d81020 	\.154  br=byte\[gprB_4, 0, 0x0, \.479\], defer\[1\]
+ 4d8:	000000f0000c0300 	\.155  nop
+ 4e0:	000a60c877c81520 	\.156  br=byte\[gprB_5, 1, 0x0, \.479\]
+ 4e8:	0001e0c877c81620 	\.157  br=byte\[gprB_5, 2, 0x0, \.479\]
+ 4f0:	0001a4c877c94220 	\.158  br=byte\[\*l\$index2, 2, 0x0, \.479\]
+ 4f8:	000620c877c96220 	\.159  br=byte\[\*l\$index1, 2, 0x0, \.479\]
+ 500:	000540c877c81b20 	\.160  br=byte\[gprB_6, 3, 0x0, \.479\]
+ 508:	0000c0c877cc16ff 	\.161  br=byte\[gprB_5, 2, 0xff, \.479\]
+ 510:	000420c877c816a2 	\.162  br=byte\[gprB_5, 2, 0x42, \.479\]
+ 518:	000380c877c416ff 	\.163  br!=byte\[gprB_5, 2, 0xff, \.479\]
+ 520:	0002a0c877c01620 	\.164  br!=byte\[gprB_5, 2, 0x0, \.479\]
+ 528:	000c20d877c00236 	\.165  br_cls_state\[cls_ring0_status, \.479\]
+ 530:	0001a0d877e20236 	\.166  br_cls_state\[cls_ring8_status, \.479\], defer\[2\]
+ 538:	000000f0000c0300 	\.167  nop
+ 540:	000000f0000c0300 	\.168  nop
+ 548:	000be0d877c38236 	\.169  br_cls_state\[cls_ring14_status, \.479\]
+ 550:	0007c0d877c3c236 	\.170  br_cls_state\[cls_ring15_status, \.479\]
+ 558:	000720d877c3c237 	\.171  br_!cls_state\[cls_ring15_status, \.479\]
+ 560:	000cc0d877c00237 	\.172  br_!cls_state\[cls_ring0_status, \.479\]
+ 568:	000c00d877c00030 	\.173  br=ctx\[0, \.479\]
+ 570:	000dc0d877c08030 	\.174  br=ctx\[2, \.479\]
+ 578:	000f00d877c18030 	\.175  br=ctx\[6, \.479\]
+ 580:	000a40d877d18030 	\.176  br=ctx\[6, \.479\], defer\[1\]
+ 588:	000000f0000c0300 	\.177  nop
+ 590:	000d40d877c00234 	\.178  br_inp_state\[nn_empty, \.479\]
+ 598:	000160d877c04234 	\.179  br_inp_state\[nn_full, \.479\]
+ 5a0:	000c80d877c08234 	\.180  br_inp_state\[ctm_ring0_status, \.479\]
+ 5a8:	000100d877e28234 	\.181  br_inp_state\[ctm_ring8_status, \.479\], defer\[2\]
+ 5b0:	000000f0000c0300 	\.182  nop
+ 5b8:	000000f0000c0300 	\.183  nop
+ 5c0:	000a80d877c38234 	\.184  br_inp_state\[ctm_ring12_status, \.479\]
+ 5c8:	0006a0d877c3c234 	\.185  br_inp_state\[ctm_ring13_status, \.479\]
+ 5d0:	000640d877c3c235 	\.186  br_!inp_state\[ctm_ring13_status, \.479\]
+ 5d8:	000c60d877c08235 	\.187  br_!inp_state\[ctm_ring0_status, \.479\]
+ 5e0:	000260d877c04232 	\.188  br_signal\[1, \.479\]
+ 5e8:	000f80d877c08232 	\.189  br_signal\[2, \.479\]
+ 5f0:	0005a0d877c3c232 	\.190  br_signal\[15, \.479\]
+ 5f8:	000540d877c3c233 	\.191  br_!signal\[15, \.479\]
+ 600:	000b60d877f2c232 	\.192  br_signal\[11, \.479\], defer\[3\]
+ 608:	000000f0000c0300 	\.193  nop
+ 610:	000000f0000c0300 	\.194  nop
+ 618:	000000f0000c0300 	\.195  nop
+ 620:	000e40a0c0000402 	\.196  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 628:	0004408e02081200 	\.197  byte_align_le\[--, gprB_4\]
+ 630:	0008c08e00981200 	\.198  byte_align_le\[gprA_9, gprB_4\]
+ 638:	0004c08e00a81200 	\.199  byte_align_le\[gprA_10, gprB_4\]
+ 640:	0001808e00b81200 	\.200  byte_align_le\[gprA_11, gprB_4\]
+ 648:	000e40a0c0000402 	\.201  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 650:	000c808e02001100 	\.202  byte_align_be\[--, gprB_4\]
+ 658:	0000008e00901100 	\.203  byte_align_be\[gprA_9, gprB_4\]
+ 660:	000c008e00a01100 	\.204  byte_align_be\[gprA_10, gprB_4\]
+ 668:	0009408e00b01100 	\.205  byte_align_be\[gprA_11, gprB_4\]
+ 670:	000d80a0300c0300 	\.206  alu\[--, --, B, 0x0\]
+ 678:	000400a5b00c0000 	\.207  cam_clear
+ 680:	000360bb80900007 	\.208  cam_lookup\[gprB_9, gprA_7\]
+ 688:	0003a0bb80900200 	\.209  cam_lookup\[gprB_9, \*l\$index0\]
+ 690:	000e04bb80900200 	\.210  cam_lookup\[gprB_9, \*l\$index2\]
+ 698:	000f84bb80900203 	\.211  cam_lookup\[gprB_9, \*l\$index2\[3\]\]
+ 6a0:	000bc0bb80900210 	\.212  cam_lookup\[gprB_9, \*l\$index0\+\+\]
+ 6a8:	000280aba0000241 	\.213  cam_lookup\[\*l\$index0, \*n\$index\]
+ 6b0:	000ec0aba1000241 	\.214  cam_lookup\[\*l\$index0\+\+, \*n\$index\]
+ 6b8:	000288aba3000243 	\.215  cam_lookup\[\*l\$index3\+\+, \*n\$index\+\+\]
+ 6c0:	000aa0aba0200243 	\.216  cam_lookup\[\*l\$index0\[2\], \*n\$index\+\+\]
+ 6c8:	000060bb80901407 	\.217  cam_lookup\[gprB_9, gprA_7\], lm_addr0\[1\]
+ 6d0:	000060bb80902807 	\.218  cam_lookup\[gprB_9, gprA_7\], lm_addr1\[2\]
+ 6d8:	000660bb80907407 	\.219  cam_lookup\[gprB_9, gprA_7\], lm_addr2\[3\]
+ 6e0:	000660bb80904807 	\.220  cam_lookup\[gprB_9, gprA_7\], lm_addr3\[0\]
+ 6e8:	000222ab80900007 	\.221  cam_lookup\[gprA_9, gprA_7\], gpr_wrboth
+ 6f0:	0004b0bb80900007 	\.222  cam_lookup\[gprB_9, gprA_7\], predicate_cc
+ 6f8:	000a00a7809c0000 	\.223  cam_read_tag\[gprA_9, 0x0\]
+ 700:	000da2a7809c0000 	\.224  cam_read_tag\[gprA_9, 0x0\], gpr_wrboth
+ 708:	000dd0a7809c0000 	\.225  cam_read_tag\[gprA_9, 0x0\], predicate_cc
+ 710:	000900a7809c2800 	\.226  cam_read_tag\[gprA_9, 0xa\]
+ 718:	000a00a7809c3c00 	\.227  cam_read_tag\[gprA_9, 0xf\]
+ 720:	0003e0af809c0000 	\.228  cam_read_state\[gprA_9, 0x0\]
+ 728:	000442af809c0000 	\.229  cam_read_state\[gprA_9, 0x0\], gpr_wrboth
+ 730:	000392af809c0000 	\.230  cam_read_state\[gprA_9, 0x0\], gpr_wrboth, predicate_cc
+ 738:	0000e0af809c2800 	\.231  cam_read_state\[gprA_9, 0xa\]
+ 740:	0003e0af809c3c00 	\.232  cam_read_state\[gprA_9, 0xf\]
+ 748:	000920a9f0101700 	\.233  cam_write\[0x0, gprB_5, 1\]
+ 750:	000da0a9f01a0300 	\.234  cam_write\[0x0, n\$reg_0, 1\]
+ 758:	000e80a9f0190700 	\.235  cam_write\[0x0, \*n\$index, 1\]
+ 760:	0004c4a9f0180300 	\.236  cam_write\[0x0, \*l\$index2, 1\]
+ 768:	0008e4a9f0184300 	\.237  cam_write\[0x0, \*l\$index2\+\+, 1\]
+ 770:	000dc4a9f0184700 	\.238  cam_write\[0x0, \*l\$index2--, 1\]
+ 778:	000840a9f0b01704 	\.239  cam_write\[0x4, gprB_5, 11\]
+ 780:	000be0a9f0f0170f 	\.240  cam_write\[0xf, gprB_5, 15\]
+ 788:	0008a0adb01c0000 	\.241  cam_write_state\[0x0, 1\]
+ 790:	000d80adb0bc1000 	\.242  cam_write_state\[0x4, 11\]
+ 798:	000de0adb0fc3c00 	\.243  cam_write_state\[0xf, 15\]
+ 7a0:	0000c0fc142c000d 	\.244  local_csr_wr\[CRCRemainder, gprA_13\]
+ 7a8:	000d20a918060348 	\.245  crc_le\[crc_ccitt, \$xfer_0, \$xfer_0\]
+ 7b0:	000000f0000c0300 	\.246  nop
+ 7b8:	000d40a918160748 	\.247  crc_le\[crc_ccitt, \$xfer_1, \$xfer_1\]
+ 7c0:	000000f0000c0300 	\.248  nop
+ 7c8:	000d40a918260b48 	\.249  crc_le\[crc_ccitt, \$xfer_2, \$xfer_2\]
+ 7d0:	000000f0000c0300 	\.250  nop
+ 7d8:	000d20a918360f48 	\.251  crc_le\[crc_ccitt, \$xfer_3, \$xfer_3\]
+ 7e0:	000000f0000c0300 	\.252  nop
+ 7e8:	000000f0000c0300 	\.253  nop
+ 7f0:	000000f0000c0300 	\.254  nop
+ 7f8:	000000f0000c0300 	\.255  nop
+ 800:	000000f0000c0300 	\.256  nop
+ 808:	000f60fc140c0000 	\.257  local_csr_rd\[CRCRemainder\]
+ 810:	000ce0f0000c000e 	\.258  immed\[gprA_14, 0x0\]
+ 818:	000940a918060340 	\.259  crc_be\[crc_ccitt, \$xfer_0, \$xfer_0\]
+ 820:	000000f0000c0300 	\.260  nop
+ 828:	000920a918461340 	\.261  crc_be\[crc_ccitt, \$xfer_4, \$xfer_4\]
+ 830:	000000f0000c0300 	\.262  nop
+ 838:	000060a900061340 	\.263  crc_be\[crc_ccitt, gprA_0, \$xfer_4\]
+ 840:	000000f0000c0300 	\.264  nop
+ 848:	000c60a900001340 	\.265  crc_be\[crc_ccitt, gprA_0, gprB_4\]
+ 850:	000000f0000c0300 	\.266  nop
+ 858:	000000f0000c0300 	\.267  nop
+ 860:	000000f0000c0300 	\.268  nop
+ 868:	000000f0000c0300 	\.269  nop
+ 870:	000000f0000c0300 	\.270  nop
+ 878:	000600a918260380 	\.271  crc_be\[crc_32, \$xfer_2, \$xfer_0\]
+ 880:	000000f0000c0300 	\.272  nop
+ 888:	0004c0a9183613a0 	\.273  crc_be\[crc_iscsi, \$xfer_3, \$xfer_4\]
+ 890:	000000f0000c0300 	\.274  nop
+ 898:	0004c0a9000613c0 	\.275  crc_be\[crc_10, gprA_0, \$xfer_4\]
+ 8a0:	000000f0000c0300 	\.276  nop
+ 8a8:	000960a9000013e0 	\.277  crc_be\[crc_5, gprA_0, gprB_4\]
+ 8b0:	000000f0000c0300 	\.278  nop
+ 8b8:	000ea0a918862700 	\.279  crc_be\[--, \$xfer_8, \$xfer_9\]
+ 8c0:	000000f0000c0300 	\.280  nop
+ 8c8:	000240a918760784 	\.281  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_0_2
+ 8d0:	000000f0000c0300 	\.282  nop
+ 8d8:	0002a0a918760785 	\.283  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_0_1
+ 8e0:	000000f0000c0300 	\.284  nop
+ 8e8:	000320a918760786 	\.285  crc_be\[crc_32, \$xfer_7, \$xfer_1\], byte_0
+ 8f0:	000000f0000c0300 	\.286  nop
+ 8f8:	0000c0a918760781 	\.287  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_1_3
+ 900:	000000f0000c0300 	\.288  nop
+ 908:	000140a918760782 	\.289  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_2_3
+ 910:	000000f0000c0300 	\.290  nop
+ 918:	0001a0a918760783 	\.291  crc_be\[crc_32, \$xfer_7, \$xfer_1\], byte_3
+ 920:	000000f0000c0300 	\.292  nop
+ 928:	000782a900160780 	\.293  crc_be\[crc_32, gprA_1, \$xfer_1\], gpr_wrboth
+ 930:	000000f0000c0300 	\.294  nop
+ 938:	000ae3a900160780 	\.295  crc_be\[crc_32, gprA_1, \$xfer_1\], no_cc, gpr_wrboth
+ 940:	000000f0000c0300 	\.296  nop
+ 948:	000b73a900560780 	\.297  crc_be\[crc_32, gprA_5, \$xfer_1\], no_cc, gpr_wrboth, predicate_cc
+ 950:	000000f0000c0300 	\.298  nop
+ 958:	000122a900560781 	\.299  crc_be\[crc_32, gprA_5, \$xfer_1\], bytes_1_3, gpr_wrboth
+ 960:	000000f0000c0300 	\.300  nop
+ 968:	000000f0000c0300 	\.301  nop
+ 970:	000000f0000c0300 	\.302  nop
+ 978:	000000f0000c0300 	\.303  nop
+ 980:	000000f0000c0300 	\.304  nop
+ 988:	000000f0000c0300 	\.305  nop
+ 990:	0005a0e000080000 	\.306  ctx_arb\[--\]
+ 998:	000600e000000001 	\.307  ctx_arb\[voluntary\]
+ 9a0:	000220e000020000 	\.308  ctx_arb\[bpt\]
+ 9a8:	000460e000000220 	\.309  ctx_arb\[sig5, sig9\]
+ 9b0:	000d20e000200220 	\.310  ctx_arb\[sig5, sig9\], defer\[2\]
+ 9b8:	000180a0300c0f00 	\.311  alu\[--, --, B, 0x3\]
+ 9c0:	0007a0a0300c1f00 	\.312  alu\[--, --, B, 0x7\]
+ 9c8:	0006a0e000010220 	\.313  ctx_arb\[sig5, sig9\], any
+ 9d0:	000a60e077c40220 	\.314  ctx_arb\[sig5, sig9\], br\[\.479\]
+ 9d8:	0006409010500701 	\.315  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\]
+ 9e0:	000d4090a0500701 	\.316  dbl_shf\[gprB_5, gprA_1, gprB_1, >>10\]
+ 9e8:	000c4091f0500701 	\.317  dbl_shf\[gprB_5, gprA_1, gprB_1, >>31\]
+ 9f0:	000740a440000402 	\.318  alu\[gprA_0, gprB_1, AND, gprA_2\]
+ 9f8:	0000c09000500701 	\.319  dbl_shf\[gprB_5, gprA_1, gprB_1, >>indirect\]
+ a00:	000b219010500701 	\.320  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\], no_cc
+ a08:	000cf19010500701 	\.321  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\], no_cc, predicate_cc
+ a10:	0000d28010500701 	\.322  dbl_shf\[gprA_5, gprA_1, gprB_1, >>1\], gpr_wrboth, predicate_cc
+ a18:	000200a700f03f00 	\.323  ffs\[gprA_15, gprB_15\]
+ a20:	000fe0b740fc000f 	\.324  ffs\[gprB_15, gprA_15\]
+ a28:	000ec0b700f61300 	\.325  ffs\[gprB_15, \$xfer_4\]
+ a30:	000660b700f88300 	\.326  ffs\[gprB_15, \*l\$index1\]
+ a38:	0007e4b700f8c300 	\.327  ffs\[gprB_15, \*l\$index3\+\+\]
+ a40:	0002c4b700f8c700 	\.328  ffs\[gprB_15, \*l\$index3--\]
+ a48:	0004c4b700f8a700 	\.329  ffs\[gprB_15, \*l\$index3\[9\]\]
+ a50:	000880a720000300 	\.330  ffs\[\*l\$index0, gprB_0\]
+ a58:	000108a722090700 	\.331  ffs\[\*l\$index3, \*n\$index\]
+ a60:	000128a723190f00 	\.332  ffs\[\*l\$index3--, \*n\$index\+\+\]
+ a68:	0003c3a740fc000f 	\.333  ffs\[gprA_15, gprA_15\], no_cc, gpr_wrboth
+ a70:	000972a740fc000f 	\.334  ffs\[gprA_15, gprA_15\], gpr_wrboth, predicate_cc
+ a78:	000320f0000c0803 	\.335  immed\[gprA_3, 0x2\]
+ a80:	000480e8004d4803 	\.336  jump\[gprA_3, \.338\]
+ a88:	0006a0d854408038 	\.337  br\[\.337\]
+ a90:	000460f000002701 	\.338  immed\[gprB_9, 0x1\]
+ a98:	0006a0d854408038 	\.339  br\[\.337\]
+ aa0:	0005e0f000002702 	\.340  immed\[gprB_9, 0x2\]
+ aa8:	0006a0d854408038 	\.341  br\[\.337\]
+ ab0:	000500f000002703 	\.342  immed\[gprB_9, 0x3\]
+ ab8:	0006a0d854408038 	\.343  br\[\.337\]
+ ac0:	000040c001000000 	\.344  ld_field\[gprA_0, 0001, gprB_0\]
+ ac8:	0007e2c001000000 	\.345  ld_field\[gprA_0, 0001, gprB_0\], gpr_wrboth
+ ad0:	000e40c401000000 	\.346  ld_field\[gprA_0, 0001, gprB_0\], load_cc
+ ad8:	000790c001000000 	\.347  ld_field\[gprA_0, 0001, gprB_0\], predicate_cc
+ ae0:	0005c0c005000000 	\.348  ld_field\[gprA_0, 0101, gprB_0\]
+ ae8:	000080c005100000 	\.349  ld_field_w_clr\[gprA_0, 0101, gprB_0\]
+ af0:	0002a2c001100000 	\.350  ld_field_w_clr\[gprA_0, 0001, gprB_0\], gpr_wrboth
+ af8:	000b00c401100000 	\.351  ld_field_w_clr\[gprA_0, 0001, gprB_0\], load_cc
+ b00:	0002d0c001100000 	\.352  ld_field_w_clr\[gprA_0, 0001, gprB_0\], predicate_cc
+ b08:	000fc0c00f000000 	\.353  ld_field\[gprA_0, 1111, gprB_0\]
+ b10:	0005e0c1fb000200 	\.354  ld_field\[gprA_0, 1011, gprB_0, <<1\]
+ b18:	000460c01b000100 	\.355  ld_field\[gprA_0, 1011, gprB_0, >>1\]
+ b20:	000e60c1fb000100 	\.356  ld_field\[gprA_0, 1011, gprB_0, >>31\]
+ b28:	000bc0c09b000000 	\.357  ld_field\[gprA_0, 1011, gprB_0, >>rot9\]
+ b30:	000e80c09b100000 	\.358  ld_field_w_clr\[gprA_0, 1011, gprB_0, >>rot9\]
+ b38:	0001c0c17b000000 	\.359  ld_field\[gprA_0, 1011, gprB_0, >>rot23\]
+ b40:	0002c0c41b000000 	\.360  ld_field\[gprA_0, 1011, gprB_0, >>rot1\], load_cc
+ b48:	000780c41b100000 	\.361  ld_field_w_clr\[gprA_0, 1011, gprB_0, >>rot1\], load_cc
+ b50:	000400f0001f7c01 	\.362  immed\[gprA_1, 0x1df\]
+ b58:	000200f0001007df 	\.363  immed\[gprB_1, 0x1df\]
+ b60:	0005a2f0001007df 	\.364  immed\[gprB_1, 0x1df\], gpr_wrboth
+ b68:	0005d0f0001007df 	\.365  immed\[gprB_1, 0x1df\], predicate_cc
+ b70:	000020fc010c0000 	\.366  local_csr_rd\[ALUOut\]
+ b78:	000e60f0000c000b 	\.367  immed\[gprA_11, 0x0\]
+ b80:	000ce0fc160c0000 	\.368  local_csr_rd\[MiscControl\]
+ b88:	000e60f0000c000b 	\.369  immed\[gprA_11, 0x0\]
+ b90:	000ae0fc076c0b02 	\.370  local_csr_wr\[XferIndex, 0x2\]
+ b98:	0008a0fc076c0003 	\.371  local_csr_wr\[XferIndex, gprA_3\]
+ ba0:	000520fc07600f00 	\.372  local_csr_wr\[XferIndex, gprB_3\]
+ ba8:	000f20fc01a00f00 	\.373  local_csr_wr\[CtxEnables, gprB_3\]
+ bb0:	000480f800000c02 	\.374  mul_step\[gprA_2, gprB_3\], start
+ bb8:	000880f980000c02 	\.375  mul_step\[gprA_2, gprB_3\], 32x32_step1
+ bc0:	000dc0f980100c02 	\.376  mul_step\[gprA_2, gprB_3\], 32x32_step2
+ bc8:	0001c0f980200c02 	\.377  mul_step\[gprA_2, gprB_3\], 32x32_step3
+ bd0:	000480f980300c02 	\.378  mul_step\[gprA_2, gprB_3\], 32x32_step4
+ bd8:	000940f9804c0002 	\.379  mul_step\[gprA_2, --\], 32x32_last
+ be0:	000ce0f9805c0003 	\.380  mul_step\[gprA_3, --\], 32x32_last2
+ be8:	0001a0f800000802 	\.381  mul_step\[gprA_2, gprB_2\], start
+ bf0:	000aa0f900000802 	\.382  mul_step\[gprA_2, gprB_2\], 16x16_step1
+ bf8:	000fe0f900100802 	\.383  mul_step\[gprA_2, gprB_2\], 16x16_step2
+ c00:	000f20f9004c0000 	\.384  mul_step\[gprA_0, --\], 16x16_last
+ c08:	0001a0f800000802 	\.385  mul_step\[gprA_2, gprB_2\], start
+ c10:	0006a0f880000802 	\.386  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c18:	000320f8804c0000 	\.387  mul_step\[gprA_0, --\], 24x8_last
+ c20:	0001a0f800000802 	\.388  mul_step\[gprA_2, gprB_2\], start
+ c28:	0006a0f880000802 	\.389  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c30:	0004f0f8804c0000 	\.390  mul_step\[gprA_0, --\], 24x8_last, predicate_cc
+ c38:	0001a0f800000802 	\.391  mul_step\[gprA_2, gprB_2\], start
+ c40:	0006a0f880000802 	\.392  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c48:	0009e3f8804c0000 	\.393  mul_step\[gprA_0, --\], 24x8_last, no_cc, gpr_wrboth
+ c50:	000b80a330000000 	\.394  pop_count1\[gprB_0\]
+ c58:	000c80a3b0000000 	\.395  pop_count2\[gprB_0\]
+ c60:	000d80a180000000 	\.396  pop_count3\[gprA_0, gprB_0\]
+ c68:	000b80a330000000 	\.397  pop_count1\[gprB_0\]
+ c70:	000c80a3b0000000 	\.398  pop_count2\[gprB_0\]
+ c78:	000743a180000000 	\.399  pop_count3\[gprA_0, gprB_0\], no_cc, gpr_wrboth
+ c80:	0004a4a330088000 	\.400  pop_count1\[\*l\$index3\]
+ c88:	0003a4a3b0088000 	\.401  pop_count2\[\*l\$index3\]
+ c90:	0000e5a1a438c000 	\.402  pop_count3\[\*n\$index\+\+, \*l\$index3\+\+\], no_cc
+ c98:	000b80a330000000 	\.403  pop_count1\[gprB_0\]
+ ca0:	000c80a3b0000000 	\.404  pop_count2\[gprB_0\]
+ ca8:	000731a180000000 	\.405  pop_count3\[gprA_0, gprB_0\], no_cc, predicate_cc
+ cb0:	000480e8000c0000 	\.406  rtn\[gprA_0\]
+ cb8:	000620e8000a0700 	\.407  rtn\[n\$reg_1\]
+ cc0:	000600e800088300 	\.408  rtn\[\*l\$index1\]
+ cc8:	000a64e800080300 	\.409  rtn\[\*l\$index2\]
+ cd0:	000dc0e800200300 	\.410  rtn\[gprB_0\], defer\[2\]
+ cd8:	0008a0a0300c0700 	\.411  alu\[--, --, B, 0x1\]
+ ce0:	0004a0a0300c0b00 	\.412  alu\[--, --, B, 0x2\]
+ ce8:	000000f0000c0300 	\.413  nop
+ cf0:	000000f0000c0300 	\.414  nop
+ cf8:	000000f0000c0300 	\.415  nop
+ d00:	000000f0000c0300 	\.416  nop
+ d08:	0003501842300c09 	\.417  arm\[read, \$xfer_3, gprA_9, gprB_3, 2\], ctx_swap\[sig4\]
+ d10:	0005501842302403 	\.418  arm\[read, \$xfer_3, gprA_3, gprB_9, 2\], ctx_swap\[sig4\]
+ d18:	0004801842300c09 	\.419  arm\[read, \$xfer_3, gprA_9, <<8, gprB_3, 2\], ctx_swap\[sig4\]
+ d20:	000f241842302403 	\.420  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], ctx_swap\[sig4\]
+ d28:	0004a0a0300c0b00 	\.421  alu\[--, --, B, 0x2\]
+ d30:	0008861842302403 	\.422  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], indirect_ref, ctx_swap\[sig4\]
+ d38:	0004a0a0300c0b00 	\.423  alu\[--, --, B, 0x2\]
+ d40:	000e8618e2302703 	\.424  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], indirect_ref, sig_done\[sig14\]
+ d48:	0007841842302503 	\.425  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], ctx_swap\[sig4\], defer\[1\]
+ d50:	0008a0a0300c0700 	\.426  alu\[--, --, B, 0x1\]
+ d58:	000f101843c00c09 	\.427  arm\[read, \$xfer_28, gprA_9, gprB_3, 2\], ctx_swap\[sig4\]
+ d60:	000910184e800c09 	\.428  arm\[read, \$xfer_8, gprA_9, gprB_3, 8\], ctx_swap\[sig4\]
+ d68:	000a106440800c09 	\.429  cls\[add, \$xfer_8, gprA_9, gprB_3, 1\], ctx_swap\[sig4\]
+ d70:	0000f0664080a009 	\.430  cls\[sub, \$xfer_8, gprA_9, 0x8, 1\], ctx_swap\[sig4\]
+ d78:	000160644284a009 	\.431  cls\[add64, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ d80:	000404664284a408 	\.432  cls\[sub64, \$xfer_8, 0x9, <<8, gprA_8, 2\], ctx_swap\[sig4\]
+ d88:	0008a0a0300c0700 	\.433  alu\[--, --, B, 0x1\]
+ d90:	00032c650340a708 	\.434  cls\[add_imm, 0x14, 0x9, <<8, gprA_8, 2\]
+ d98:	0007506040880c09 	\.435  cls\[swap/test_compare_write, \$xfer_8, gprA_9, gprB_3, 1\], ctx_swap\[sig4\]
+ da0:	00023c6500007f9a 	\.436  cls\[add_imm, 0x1f9a, --, 1\]
+ da8:	000038653c583f14 	\.437  cls\[add_imm, 0xf14, 0xf16\]
+ db0:	000b54640013c30f 	\.438  cls\[add, \$xfer_1, 0xf00f, 1\]
+ db8:	0002901c10a08000 	\.439  ct\[xpb_read, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dc0:	0007501e10a48000 	\.440  ct\[reflect_read_sig_init, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dc8:	000a501c10a48000 	\.441  ct\[ring_get, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dd0:	000000f0000c0300 	\.442  nop
+ dd8:	000cc0474a80a009 	\.443  mem\[add64, \$xfer_8, gprA_9, <<8, 0x8, 6\], ctx_swap\[sig4\]
+ de0:	000d40404280a009 	\.444  mem\[read, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ de8:	000c405c4280a009 	\.445  mem\[read32, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ df0:	000ea0554280a009 	\.446  mem\[ctm\.pe_dma_to_memory_indirect/emem\.get/imem\.lb_bucket_read_local, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ df8:	0009204c408ca309 	\.447  mem\[lock128/lock384, \$xfer_8, gprA_9, <<8, 0x8, 1\], sig_done\[sig4\]
+ e00:	000f20e000000030 	\.448  ctx_arb\[sig4, sig5\]
+ e08:	0000a04c488ca309 	\.449  mem\[lock256/lock512, \$xfer_8, gprA_9, <<8, 0x8, 5\], sig_done\[sig4\]
+ e10:	000f20e000000030 	\.450  ctx_arb\[sig4, sig5\]
+ e18:	000ae04d4084a009 	\.451  mem\[microq128_pop, \$xfer_8, gprA_9, <<8, 0x8, 1\], ctx_swap\[sig4\]
+ e20:	0002204d4080a009 	\.452  mem\[microq128_get, \$xfer_8, gprA_9, <<8, 0x8, 1\], ctx_swap\[sig4\]
+ e28:	000ba04d4880a009 	\.453  mem\[microq256_get, \$xfer_8, gprA_9, <<8, 0x8, 5\], ctx_swap\[sig4\]
+ e30:	0003805700028309 	\.454  mem\[ctm\.pe_dma_from_memory_buffer/emem\.fast_journal/imem\.lb_push_stats_local, \$xfer_0, gprA_9, <<8, 0x40, 1\]
+ e38:	0005e04e4000a309 	\.455  mem\[queue128_lock, \$xfer_0, gprA_9, <<8, 0x8, 1\], sig_done\[sig4\]
+ e40:	000f20e000000030 	\.456  ctx_arb\[sig4, sig5\]
+ e48:	0001a04e0004a309 	\.457  mem\[queue128_unlock, \$xfer_0, gprA_9, <<8, 0x8, 1\]
+ e50:	000c604e4800a309 	\.458  mem\[queue256_lock, \$xfer_0, gprA_9, <<8, 0x8, 5\], sig_done\[sig4\]
+ e58:	000f20e000000030 	\.459  ctx_arb\[sig4, sig5\]
+ e60:	0008204e0804a309 	\.460  mem\[queue256_unlock, \$xfer_0, gprA_9, <<8, 0x8, 5\]
+ e68:	0008a05000001309 	\.461  mem\[ctm\.packet_wait_packet_status/emem\.rd_qdesc/imem\.stats_log, \$xfer_0, gprA_9, <<8, gprB_4, 1\]
+ e70:	000b840092200c02 	\.462  ila\[read, \$xfer_2, gprB_3, <<8, gprA_2, 2\], ctx_swap\[sig9\]
+ e78:	0005440182240f02 	\.463  ila\[write_check_error, \$xfer_2, gprB_3, <<8, gprA_2, 2\], sig_done\[sig8\]
+ e80:	000d60e000000300 	\.464  ctx_arb\[sig8, sig9\]
+ e88:	0007800410600000 	\.465  nbi\[read, \$xfer_6, gprA_0, <<8, gprB_0, 1\], ctx_swap\[sig1\]
+ e90:	0002600c62000000 	\.466  pcie\[read, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ e98:	0004c40d62000000 	\.467  pcie\[write, \$xfer_0, gprB_0, <<8, gprA_0, 2\], ctx_swap\[sig6\]
+ ea0:	000d601462000000 	\.468  crypto\[read, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ ea8:	0006601562000000 	\.469  crypto\[write, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ eb0:	0000601662000000 	\.470  crypto\[write_fifo, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ eb8:	000d840d60000050 	\.471  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index0, 1\], ctx_swap\[sig6\]
+ ec0:	0009e40d60000058 	\.472  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index1, 1\], ctx_swap\[sig6\]
+ ec8:	0009040d60000059 	\.473  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index1\[1\], 1\], ctx_swap\[sig6\]
+ ed0:	000000f0000c0300 	\.474  nop
+ ed8:	000000f0000c0300 	\.475  nop
+ ee0:	000000f0000c0300 	\.476  nop
+ ee8:	000000f0000c0300 	\.477  nop
+ ef0:	000000f0000c0300 	\.478  nop
+ ef8:	000060a900301340 	\.479  crc_be\[crc_ccitt, gprA_3, gprB_4\]
+ f00:	000000f0000c0300 	\.480  nop
+ f08:	000e20b9403d0004 	\.481  crc_be\[crc_ccitt, gprB_3, gprA_4\]
+ f10:	000000f0000c0300 	\.482  nop
+ f18:	000400a900301348 	\.483  crc_le\[crc_ccitt, gprA_3, gprB_4\]
+ f20:	000000f0000c0300 	\.484  nop
+ f28:	000400b9403d2004 	\.485  crc_le\[crc_ccitt, gprB_3, gprA_4\]
+ f30:	000000f0000c0300 	\.486  nop
+ f38:	0002e0b900301348 	\.487  crc_le\[crc_ccitt, gprB_3, gprB_4\]
+ f40:	000000f0000c0300 	\.488  nop
+ f48:	0002e0a9403d2004 	\.489  crc_le\[crc_ccitt, gprA_3, gprA_4\]
+ f50:	000000f0000c0300 	\.490  nop
+ f58:	000220e000020000 	\.491  ctx_arb\[bpt\]
+ f60:	000420e000010000 	\.492  ctx_arb\[kill\]
+
+Disassembly of section \.text\.i33\.me9:
+
+0000000000000000 <\.text\.i33\.me9>:
+   0:	000540f0012cd000 	  \.0  immed\[gprA_0, 0x1234\]
+   8:	0002c0f0012cd280 	  \.1  immed\[n\$reg_0, 0x1234\]
+  10:	000220f0012cd281 	  \.2  immed\[n\$reg_1, 0x1234\]
+  18:	000660f0012cd200 	  \.3  immed\[\*l\$index0, 0x1234\]
+  20:	0007c0f0012cd220 	  \.4  immed\[\*l\$index1, 0x1234\]
+  28:	000fa0f0012cd230 	  \.5  immed\[\*l\$index1\+\+, 0x1234\]
+  30:	000f40f0012cd231 	  \.6  immed\[\*l\$index1--, 0x1234\]
+  38:	0008c8f0012cd200 	  \.7  immed\[\*l\$index2, 0x1234\]
+  40:	0000a8f0012cd210 	  \.8  immed\[\*l\$index2\+\+, 0x1234\]
+  48:	000048f0012cd211 	  \.9  immed\[\*l\$index2--, 0x1234\]
+  50:	000968f0012cd220 	 \.10  immed\[\*l\$index3, 0x1234\]
+  58:	0007e0f0012cd203 	 \.11  immed\[\*l\$index0\[3\], 0x1234\]
+  60:	000540f0012cd225 	 \.12  immed\[\*l\$index1\[5\], 0x1234\]
+  68:	000b28f0012cd207 	 \.13  immed\[\*l\$index2\[7\], 0x1234\]
+  70:	000de8f0012cd229 	 \.14  immed\[\*l\$index3\[9\], 0x1234\]
+  78:	000000f00ff003ff 	 \.15  immed\[gprB_0, 0xffff\]
+  80:	000d60f220000bff 	 \.16  immed_b1\[gprB_2, 0xff\]
+  88:	000f60f6200007ff 	 \.17  immed_b3\[gprB_1, 0xff\]
+  90:	000080f080000f00 	 \.18  immed\[gprB_3, 0xffffffff\]
+  98:	000100f086600f77 	 \.19  immed\[gprB_3, 0xffff9988\]
+  a0:	000940f0012cd180 	 \.20  immed\[\$xfer_0, 0x1234\]
+  a8:	000a00f0043c8581 	 \.21  immed\[\$xfer_1, 0x4321\]
+  b0:	000b40f0056de19e 	 \.22  immed\[\$xfer_30, 0x5678\]
+  b8:	0007c0f0400e8401 	 \.23  immed_w0\[gprA_1, 0xa1\]
+  c0:	000440f4400e8802 	 \.24  immed_w1\[gprA_2, 0xa2\]
+  c8:	000d00f4000e8c03 	 \.25  immed\[gprA_3, 0xa3, <<16\]
+  d0:	000520f001200334 	 \.26  immed\[gprB_0, 0x1234\]
+  d8:	000fa0f0400007b1 	 \.27  immed_w0\[gprB_1, 0xb1\]
+  e0:	000c20f440000bb2 	 \.28  immed_w1\[gprB_2, 0xb2\]
+  e8:	000560f400000fb3 	 \.29  immed\[gprB_3, 0xb3, <<16\]
+  f0:	000660f200000fb3 	 \.30  immed\[gprB_3, 0xb3, <<8\]
+  f8:	0001b0f200000fb3 	 \.31  immed\[gprB_3, 0xb3, <<8\], predicate_cc
+ 100:	0001c2f200000fb3 	 \.32  immed\[gprB_3, 0xb3, <<8\], gpr_wrboth
+ 108:	000ba0a0300c2f00 	 \.33  alu\[--, --, B, 0xb\]
+ 110:	0005a081f200da00 	 \.34  alu_shf\[--, --, B, 0x16, <<1\]
+ 118:	000be081d2018600 	 \.35  alu_shf\[--, --, B, 0x21, <<3\]
+ 120:	000240801201b200 	 \.36  alu_shf\[--, --, B, 0x2c, <<31\]
+ 128:	000fa081f800da00 	 \.37  alu_shf\[\$xfer_0, --, B, 0x16, <<1\]
+ 130:	0009e081f840da00 	 \.38  alu_shf\[\$xfer_4, --, B, 0x16, <<1\]
+ 138:	0009a081f980da00 	 \.39  alu_shf\[\$xfer_24, --, B, 0x16, <<1\]
+ 140:	0003e081f9f0da00 	 \.40  alu_shf\[\$xfer_31, --, B, 0x16, <<1\]
+ 148:	0004a0a0280c2f00 	 \.41  alu\[n\$reg_0, --, B, 0xb\]
+ 150:	0001e0a0281c2f00 	 \.42  alu\[n\$reg_1, --, B, 0xb\]
+ 158:	000880a0a00c2400 	 \.43  alu\[\*l\$index0, gprA_0, \+, 0x9\]
+ 160:	000100a0a43c2400 	 \.44  alu\[\*n\$index\+\+, gprA_0, \+, 0x9\]
+ 168:	000b208bc500a600 	 \.45  alu_shf\[\*l\$index0, gprA_0, OR, 0x9, <<4\]
+ 170:	000b00a0a20c2400 	 \.46  alu\[\*l\$index1, gprA_0, \+, 0x9\]
+ 178:	000740a0a30c2400 	 \.47  alu\[\*l\$index1\+\+, gprA_0, \+, 0x9\]
+ 180:	000200a0a31c2400 	 \.48  alu\[\*l\$index1--, gprA_0, \+, 0x9\]
+ 188:	000628a0a00c2400 	 \.49  alu\[\*l\$index2, gprA_0, \+, 0x9\]
+ 190:	000988aa210c2400 	 \.50  alu\[\*l\$index2\+\+, gprA_0, OR, 0x9\]
+ 198:	000f28a0a11c2400 	 \.51  alu\[\*l\$index2--, gprA_0, \+, 0x9\]
+ 1a0:	0005a8a0a20c2400 	 \.52  alu\[\*l\$index3, gprA_0, \+, 0x9\]
+ 1a8:	000480a0a03c2400 	 \.53  alu\[\*l\$index0\[3\], gprA_0, \+, 0x9\]
+ 1b0:	000800a0a25c2400 	 \.54  alu\[\*l\$index1\[5\], gprA_0, \+, 0x9\]
+ 1b8:	000c68a0a07c2400 	 \.55  alu\[\*l\$index2\[7\], gprA_0, \+, 0x9\]
+ 1c0:	000aa8a0a29c2400 	 \.56  alu\[\*l\$index3\[9\], gprA_0, \+, 0x9\]
+ 1c8:	000cc4b0c008a400 	 \.57  alu\[gprB_0, \*l\$index3\[9\], \+, gprA_0\]
+ 1d0:	000fe4b0c008c000 	 \.58  alu\[gprB_0, \*l\$index3\+\+, \+, gprA_0\]
+ 1d8:	000ac4b0c008c400 	 \.59  alu\[gprB_0, \*l\$index3--, \+, gprA_0\]
+ 1e0:	000bc4b080000229 	 \.60  alu\[gprB_0, \*l\$index3\[9\], \+, gprB_0\]
+ 1e8:	000724b080000230 	 \.61  alu\[gprB_0, \*l\$index3\+\+, \+, gprB_0\]
+ 1f0:	0007c4b080000231 	 \.62  alu\[gprB_0, \*l\$index3--, \+, gprB_0\]
+ 1f8:	000664b080000211 	 \.63  alu\[gprB_0, \*l\$index2--, \+, gprB_0\]
+ 200:	000a60b080000231 	 \.64  alu\[gprB_0, \*l\$index1--, \+, gprB_0\]
+ 208:	000bc0b080000211 	 \.65  alu\[gprB_0, \*l\$index0--, \+, gprB_0\]
+ 210:	000340b080000200 	 \.66  alu\[gprB_0, \*l\$index0, \+, gprB_0\]
+ 218:	000ee4b080000200 	 \.67  alu\[gprB_0, \*l\$index2, \+, gprB_0\]
+ 220:	000100b080000241 	 \.68  alu\[gprB_0, \*n\$index, \+, gprB_0\]
+ 228:	0004809bf0000241 	 \.69  alu_shf\[gprB_0, \*n\$index, OR, gprB_0, <<1\]
+ 230:	000f20a0001fff00 	 \.70  alu\[gprA_1, --, B, 0xff\]
+ 238:	0005c0b0002fff00 	 \.71  alu\[gprB_2, --, B, 0xff\]
+ 240:	000940a0000d6f00 	 \.72  alu\[gprA_0, --, B, 0x5b\]
+ 248:	000440a2000d6f00 	 \.73  alu\[gprA_0, --, ~B, 0x5b\]
+ 250:	000de081f032f200 	 \.74  alu_shf\[gprA_3, --, B, 0x5c, <<1\]
+ 258:	000de091d012f600 	 \.75  alu_shf\[gprB_1, --, B, 0x5d, <<3\]
+ 260:	000d60901022fa00 	 \.76  alu_shf\[gprB_2, --, B, 0x5e, <<31\]
+ 268:	000e40a0c0000402 	 \.77  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 270:	000340a2c0000402 	 \.78  alu\[gprA_0, gprB_1, \+16, gprA_2\]
+ 278:	000040a4c0000402 	 \.79  alu\[gprA_0, gprB_1, \+8, gprA_2\]
+ 280:	0007a0a8c0000402 	 \.80  alu\[gprA_0, gprB_1, \+carry, gprA_2\]
+ 288:	000d40a6c0000402 	 \.81  alu\[gprA_0, gprB_1, -carry, gprA_2\]
+ 290:	000aa0aac0000402 	 \.82  alu\[gprA_0, gprB_1, -, gprA_2\]
+ 298:	0009a0acc0000402 	 \.83  alu\[gprA_0, gprB_1, B-A, gprA_2\]
+ 2a0:	000da0aa40000402 	 \.84  alu\[gprA_0, gprB_1, OR, gprA_2\]
+ 2a8:	000740a440000402 	 \.85  alu\[gprA_0, gprB_1, AND, gprA_2\]
+ 2b0:	000a40a640000402 	 \.86  alu\[gprA_0, gprB_1, ~AND, gprA_2\]
+ 2b8:	0000a0a840000402 	 \.87  alu\[gprA_0, gprB_1, AND~, gprA_2\]
+ 2c0:	000ea0ac40000402 	 \.88  alu\[gprA_0, gprB_1, XOR, gprA_2\]
+ 2c8:	000321a0c0000402 	 \.89  alu\[gprA_0, gprB_1, \+, gprA_2\], no_cc
+ 2d0:	000990a0c0000402 	 \.90  alu\[gprA_0, gprB_1, \+, gprA_2\], predicate_cc
+ 2d8:	0009e2a0c0000402 	 \.91  alu\[gprA_0, gprB_1, \+, gprA_2\], gpr_wrboth
+ 2e0:	000353a0c0000402 	 \.92  alu\[gprA_0, gprB_1, \+, gprA_2\], no_cc, gpr_wrboth, predicate_cc
+ 2e8:	000d418b70080602 	 \.93  alu_shf\[gprA_0, gprB_1, OR, gprA_2, <<9\], no_cc
+ 2f0:	0006708a90080502 	 \.94  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>9\], predicate_cc
+ 2f8:	000ea28a90080402 	 \.95  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>rot9\], gpr_wrboth
+ 300:	000e138b70080402 	 \.96  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>rot23\], no_cc, gpr_wrboth, predicate_cc
+ 308:	000ba08a00080602 	 \.97  alu_shf\[gprA_0, gprB_1, OR, gprA_2, <<indirect\]
+ 310:	0000208a00080502 	 \.98  alu_shf\[gprA_0, gprB_1, OR, gprA_2, >>indirect\]
+ 318:	000ba0a0300c2f00 	 \.99  alu\[--, --, B, 0xb\]
+ 320:	000ae09d40380101 	\.100  asr\[gprB_3, gprA_1, >>20\]
+ 328:	000ba0a0300c2f00 	\.101  alu\[--, --, B, 0xb\]
+ 330:	000ea09d40310500 	\.102  asr\[gprB_3, \*n\$index, >>20\]
+ 338:	000ba0a0300c2f00 	\.103  alu\[--, --, B, 0xb\]
+ 340:	0007a09d40314100 	\.104  asr\[gprB_3, \*l\$index0, >>20\]
+ 348:	000ba0a0300c2f00 	\.105  alu\[--, --, B, 0xb\]
+ 350:	0000249d40316100 	\.106  asr\[gprB_3, \*l\$index3, >>20\]
+ 358:	000ba0a0300c2f00 	\.107  alu\[--, --, B, 0xb\]
+ 360:	000a049d40314100 	\.108  asr\[gprB_3, \*l\$index2, >>20\]
+ 368:	000ba0a0300c2f00 	\.109  alu\[--, --, B, 0xb\]
+ 370:	0004a08d45010d00 	\.110  asr\[\*l\$index0, \*n\$index\+\+, >>20\]
+ 378:	000ba0a0300c2f00 	\.111  alu\[--, --, B, 0xb\]
+ 380:	000ee08d45810d00 	\.112  asr\[\*l\$index1, \*n\$index\+\+, >>20\]
+ 388:	000ba0a0300c2f00 	\.113  alu\[--, --, B, 0xb\]
+ 390:	000a088d45010d00 	\.114  asr\[\*l\$index2, \*n\$index\+\+, >>20\]
+ 398:	000ba0a0300c2f00 	\.115  alu\[--, --, B, 0xb\]
+ 3a0:	0007819d40380101 	\.116  asr\[gprB_3, gprA_1, >>20\], no_cc
+ 3a8:	000ba0a0300c2f00 	\.117  alu\[--, --, B, 0xb\]
+ 3b0:	000d309d40380101 	\.118  asr\[gprB_3, gprA_1, >>20\], predicate_cc
+ 3b8:	000ba0a0300c2f00 	\.119  alu\[--, --, B, 0xb\]
+ 3c0:	000ba28d40380101 	\.120  asr\[gprA_3, gprA_1, >>20\], gpr_wrboth
+ 3c8:	0008c0d818c08120 	\.121  beq\[\.99\]
+ 3d0:	000d00d877c08120 	\.122  beq\[\.479\]
+ 3d8:	000440d877e08120 	\.123  beq\[\.479\], defer\[2\]
+ 3e0:	000000f0000c0300 	\.124  nop
+ 3e8:	000000f0000c0300 	\.125  nop
+ 3f0:	000540d877c08021 	\.126  bne\[\.479\]
+ 3f8:	0004c0d877c08022 	\.127  bmi\[\.479\]
+ 400:	000420d877c08023 	\.128  bpl\[\.479\]
+ 408:	0007c0d877c08024 	\.129  bcs\[\.479\]
+ 410:	0007c0d877c08024 	\.130  bcs\[\.479\]
+ 418:	000720d877c08025 	\.131  bcc\[\.479\]
+ 420:	000720d877c08025 	\.132  bcc\[\.479\]
+ 428:	0006a0d877c08026 	\.133  bvs\[\.479\]
+ 430:	000640d877c08027 	\.134  bvc\[\.479\]
+ 438:	0001c0d877c08028 	\.135  bge\[\.479\]
+ 440:	000120d877c08029 	\.136  blt\[\.479\]
+ 448:	000040d877c0802b 	\.137  bgt\[\.479\]
+ 450:	0000a0d877c0802a 	\.138  ble\[\.479\]
+ 458:	000c60d818c08038 	\.139  br\[\.99\]
+ 460:	000920d818d08038 	\.140  br\[\.99\], defer\[1\]
+ 468:	000000f0000c0300 	\.141  nop
+ 470:	000bc0d077c09000 	\.142  br_bclr\[gprA_0, 3, \.479\]
+ 478:	000980d077c0e004 	\.143  br_bclr\[gprA_4, 23, \.479\]
+ 480:	0002a0d077c0082c 	\.144  br_bclr\[gprB_2, 11, \.479\]
+ 488:	000300d077c02423 	\.145  br_bclr\[gprB_9, 2, \.479\]
+ 490:	000260d077c02421 	\.146  br_bclr\[gprB_9, 0, \.479\]
+ 498:	000280d077c02420 	\.147  br_bclr\[gprB_9, 31, \.479\]
+ 4a0:	000f00d077f02423 	\.148  br_bclr\[gprB_9, 2, \.479\], defer\[3\]
+ 4a8:	000000f0000c0300 	\.149  nop
+ 4b0:	000000f0000c0300 	\.150  nop
+ 4b8:	000000f0000c0300 	\.151  nop
+ 4c0:	000680d077c42c2b 	\.152  br_bset\[gprB_11, 10, \.479\]
+ 4c8:	0006e0d077c4ac0b 	\.153  br_bset\[gprA_11, 10, \.479\]
+ 4d0:	0002a0c877d81020 	\.154  br=byte\[gprB_4, 0, 0x0, \.479\], defer\[1\]
+ 4d8:	000000f0000c0300 	\.155  nop
+ 4e0:	000a60c877c81520 	\.156  br=byte\[gprB_5, 1, 0x0, \.479\]
+ 4e8:	0001e0c877c81620 	\.157  br=byte\[gprB_5, 2, 0x0, \.479\]
+ 4f0:	0001a4c877c94220 	\.158  br=byte\[\*l\$index2, 2, 0x0, \.479\]
+ 4f8:	000620c877c96220 	\.159  br=byte\[\*l\$index1, 2, 0x0, \.479\]
+ 500:	000540c877c81b20 	\.160  br=byte\[gprB_6, 3, 0x0, \.479\]
+ 508:	0000c0c877cc16ff 	\.161  br=byte\[gprB_5, 2, 0xff, \.479\]
+ 510:	000420c877c816a2 	\.162  br=byte\[gprB_5, 2, 0x42, \.479\]
+ 518:	000380c877c416ff 	\.163  br!=byte\[gprB_5, 2, 0xff, \.479\]
+ 520:	0002a0c877c01620 	\.164  br!=byte\[gprB_5, 2, 0x0, \.479\]
+ 528:	000c20d877c00236 	\.165  br_cls_state\[cls_ring0_status, \.479\]
+ 530:	0001a0d877e20236 	\.166  br_cls_state\[cls_ring8_status, \.479\], defer\[2\]
+ 538:	000000f0000c0300 	\.167  nop
+ 540:	000000f0000c0300 	\.168  nop
+ 548:	000be0d877c38236 	\.169  br_cls_state\[cls_ring14_status, \.479\]
+ 550:	0007c0d877c3c236 	\.170  br_cls_state\[cls_ring15_status, \.479\]
+ 558:	000720d877c3c237 	\.171  br_!cls_state\[cls_ring15_status, \.479\]
+ 560:	000cc0d877c00237 	\.172  br_!cls_state\[cls_ring0_status, \.479\]
+ 568:	000c00d877c00030 	\.173  br=ctx\[0, \.479\]
+ 570:	000dc0d877c08030 	\.174  br=ctx\[2, \.479\]
+ 578:	000f00d877c18030 	\.175  br=ctx\[6, \.479\]
+ 580:	000a40d877d18030 	\.176  br=ctx\[6, \.479\], defer\[1\]
+ 588:	000000f0000c0300 	\.177  nop
+ 590:	000d40d877c00234 	\.178  br_inp_state\[nn_empty, \.479\]
+ 598:	000160d877c04234 	\.179  br_inp_state\[nn_full, \.479\]
+ 5a0:	000c80d877c08234 	\.180  br_inp_state\[ctm_ring0_status, \.479\]
+ 5a8:	000100d877e28234 	\.181  br_inp_state\[ctm_ring8_status, \.479\], defer\[2\]
+ 5b0:	000000f0000c0300 	\.182  nop
+ 5b8:	000000f0000c0300 	\.183  nop
+ 5c0:	000a80d877c38234 	\.184  br_inp_state\[ctm_ring12_status, \.479\]
+ 5c8:	0006a0d877c3c234 	\.185  br_inp_state\[ctm_ring13_status, \.479\]
+ 5d0:	000640d877c3c235 	\.186  br_!inp_state\[ctm_ring13_status, \.479\]
+ 5d8:	000c60d877c08235 	\.187  br_!inp_state\[ctm_ring0_status, \.479\]
+ 5e0:	000260d877c04232 	\.188  br_signal\[1, \.479\]
+ 5e8:	000f80d877c08232 	\.189  br_signal\[2, \.479\]
+ 5f0:	0005a0d877c3c232 	\.190  br_signal\[15, \.479\]
+ 5f8:	000540d877c3c233 	\.191  br_!signal\[15, \.479\]
+ 600:	000b60d877f2c232 	\.192  br_signal\[11, \.479\], defer\[3\]
+ 608:	000000f0000c0300 	\.193  nop
+ 610:	000000f0000c0300 	\.194  nop
+ 618:	000000f0000c0300 	\.195  nop
+ 620:	000e40a0c0000402 	\.196  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 628:	0004408e02081200 	\.197  byte_align_le\[--, gprB_4\]
+ 630:	0008c08e00981200 	\.198  byte_align_le\[gprA_9, gprB_4\]
+ 638:	0004c08e00a81200 	\.199  byte_align_le\[gprA_10, gprB_4\]
+ 640:	0001808e00b81200 	\.200  byte_align_le\[gprA_11, gprB_4\]
+ 648:	000e40a0c0000402 	\.201  alu\[gprA_0, gprB_1, \+, gprA_2\]
+ 650:	000c808e02001100 	\.202  byte_align_be\[--, gprB_4\]
+ 658:	0000008e00901100 	\.203  byte_align_be\[gprA_9, gprB_4\]
+ 660:	000c008e00a01100 	\.204  byte_align_be\[gprA_10, gprB_4\]
+ 668:	0009408e00b01100 	\.205  byte_align_be\[gprA_11, gprB_4\]
+ 670:	000d80a0300c0300 	\.206  alu\[--, --, B, 0x0\]
+ 678:	000400a5b00c0000 	\.207  cam_clear
+ 680:	000360bb80900007 	\.208  cam_lookup\[gprB_9, gprA_7\]
+ 688:	0003a0bb80900200 	\.209  cam_lookup\[gprB_9, \*l\$index0\]
+ 690:	000e04bb80900200 	\.210  cam_lookup\[gprB_9, \*l\$index2\]
+ 698:	000f84bb80900203 	\.211  cam_lookup\[gprB_9, \*l\$index2\[3\]\]
+ 6a0:	000bc0bb80900210 	\.212  cam_lookup\[gprB_9, \*l\$index0\+\+\]
+ 6a8:	000280aba0000241 	\.213  cam_lookup\[\*l\$index0, \*n\$index\]
+ 6b0:	000ec0aba1000241 	\.214  cam_lookup\[\*l\$index0\+\+, \*n\$index\]
+ 6b8:	000288aba3000243 	\.215  cam_lookup\[\*l\$index3\+\+, \*n\$index\+\+\]
+ 6c0:	000aa0aba0200243 	\.216  cam_lookup\[\*l\$index0\[2\], \*n\$index\+\+\]
+ 6c8:	000060bb80901407 	\.217  cam_lookup\[gprB_9, gprA_7\], lm_addr0\[1\]
+ 6d0:	000060bb80902807 	\.218  cam_lookup\[gprB_9, gprA_7\], lm_addr1\[2\]
+ 6d8:	000660bb80907407 	\.219  cam_lookup\[gprB_9, gprA_7\], lm_addr2\[3\]
+ 6e0:	000660bb80904807 	\.220  cam_lookup\[gprB_9, gprA_7\], lm_addr3\[0\]
+ 6e8:	000222ab80900007 	\.221  cam_lookup\[gprA_9, gprA_7\], gpr_wrboth
+ 6f0:	0004b0bb80900007 	\.222  cam_lookup\[gprB_9, gprA_7\], predicate_cc
+ 6f8:	000a00a7809c0000 	\.223  cam_read_tag\[gprA_9, 0x0\]
+ 700:	000da2a7809c0000 	\.224  cam_read_tag\[gprA_9, 0x0\], gpr_wrboth
+ 708:	000dd0a7809c0000 	\.225  cam_read_tag\[gprA_9, 0x0\], predicate_cc
+ 710:	000900a7809c2800 	\.226  cam_read_tag\[gprA_9, 0xa\]
+ 718:	000a00a7809c3c00 	\.227  cam_read_tag\[gprA_9, 0xf\]
+ 720:	0003e0af809c0000 	\.228  cam_read_state\[gprA_9, 0x0\]
+ 728:	000442af809c0000 	\.229  cam_read_state\[gprA_9, 0x0\], gpr_wrboth
+ 730:	000392af809c0000 	\.230  cam_read_state\[gprA_9, 0x0\], gpr_wrboth, predicate_cc
+ 738:	0000e0af809c2800 	\.231  cam_read_state\[gprA_9, 0xa\]
+ 740:	0003e0af809c3c00 	\.232  cam_read_state\[gprA_9, 0xf\]
+ 748:	000920a9f0101700 	\.233  cam_write\[0x0, gprB_5, 1\]
+ 750:	000da0a9f01a0300 	\.234  cam_write\[0x0, n\$reg_0, 1\]
+ 758:	000e80a9f0190700 	\.235  cam_write\[0x0, \*n\$index, 1\]
+ 760:	0004c4a9f0180300 	\.236  cam_write\[0x0, \*l\$index2, 1\]
+ 768:	0008e4a9f0184300 	\.237  cam_write\[0x0, \*l\$index2\+\+, 1\]
+ 770:	000dc4a9f0184700 	\.238  cam_write\[0x0, \*l\$index2--, 1\]
+ 778:	000840a9f0b01704 	\.239  cam_write\[0x4, gprB_5, 11\]
+ 780:	000be0a9f0f0170f 	\.240  cam_write\[0xf, gprB_5, 15\]
+ 788:	0008a0adb01c0000 	\.241  cam_write_state\[0x0, 1\]
+ 790:	000d80adb0bc1000 	\.242  cam_write_state\[0x4, 11\]
+ 798:	000de0adb0fc3c00 	\.243  cam_write_state\[0xf, 15\]
+ 7a0:	0000c0fc142c000d 	\.244  local_csr_wr\[CRCRemainder, gprA_13\]
+ 7a8:	000d20a918060348 	\.245  crc_le\[crc_ccitt, \$xfer_0, \$xfer_0\]
+ 7b0:	000000f0000c0300 	\.246  nop
+ 7b8:	000d40a918160748 	\.247  crc_le\[crc_ccitt, \$xfer_1, \$xfer_1\]
+ 7c0:	000000f0000c0300 	\.248  nop
+ 7c8:	000d40a918260b48 	\.249  crc_le\[crc_ccitt, \$xfer_2, \$xfer_2\]
+ 7d0:	000000f0000c0300 	\.250  nop
+ 7d8:	000d20a918360f48 	\.251  crc_le\[crc_ccitt, \$xfer_3, \$xfer_3\]
+ 7e0:	000000f0000c0300 	\.252  nop
+ 7e8:	000000f0000c0300 	\.253  nop
+ 7f0:	000000f0000c0300 	\.254  nop
+ 7f8:	000000f0000c0300 	\.255  nop
+ 800:	000000f0000c0300 	\.256  nop
+ 808:	000f60fc140c0000 	\.257  local_csr_rd\[CRCRemainder\]
+ 810:	000ce0f0000c000e 	\.258  immed\[gprA_14, 0x0\]
+ 818:	000940a918060340 	\.259  crc_be\[crc_ccitt, \$xfer_0, \$xfer_0\]
+ 820:	000000f0000c0300 	\.260  nop
+ 828:	000920a918461340 	\.261  crc_be\[crc_ccitt, \$xfer_4, \$xfer_4\]
+ 830:	000000f0000c0300 	\.262  nop
+ 838:	000060a900061340 	\.263  crc_be\[crc_ccitt, gprA_0, \$xfer_4\]
+ 840:	000000f0000c0300 	\.264  nop
+ 848:	000c60a900001340 	\.265  crc_be\[crc_ccitt, gprA_0, gprB_4\]
+ 850:	000000f0000c0300 	\.266  nop
+ 858:	000000f0000c0300 	\.267  nop
+ 860:	000000f0000c0300 	\.268  nop
+ 868:	000000f0000c0300 	\.269  nop
+ 870:	000000f0000c0300 	\.270  nop
+ 878:	000600a918260380 	\.271  crc_be\[crc_32, \$xfer_2, \$xfer_0\]
+ 880:	000000f0000c0300 	\.272  nop
+ 888:	0004c0a9183613a0 	\.273  crc_be\[crc_iscsi, \$xfer_3, \$xfer_4\]
+ 890:	000000f0000c0300 	\.274  nop
+ 898:	0004c0a9000613c0 	\.275  crc_be\[crc_10, gprA_0, \$xfer_4\]
+ 8a0:	000000f0000c0300 	\.276  nop
+ 8a8:	000960a9000013e0 	\.277  crc_be\[crc_5, gprA_0, gprB_4\]
+ 8b0:	000000f0000c0300 	\.278  nop
+ 8b8:	000ea0a918862700 	\.279  crc_be\[--, \$xfer_8, \$xfer_9\]
+ 8c0:	000000f0000c0300 	\.280  nop
+ 8c8:	000240a918760784 	\.281  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_0_2
+ 8d0:	000000f0000c0300 	\.282  nop
+ 8d8:	0002a0a918760785 	\.283  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_0_1
+ 8e0:	000000f0000c0300 	\.284  nop
+ 8e8:	000320a918760786 	\.285  crc_be\[crc_32, \$xfer_7, \$xfer_1\], byte_0
+ 8f0:	000000f0000c0300 	\.286  nop
+ 8f8:	0000c0a918760781 	\.287  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_1_3
+ 900:	000000f0000c0300 	\.288  nop
+ 908:	000140a918760782 	\.289  crc_be\[crc_32, \$xfer_7, \$xfer_1\], bytes_2_3
+ 910:	000000f0000c0300 	\.290  nop
+ 918:	0001a0a918760783 	\.291  crc_be\[crc_32, \$xfer_7, \$xfer_1\], byte_3
+ 920:	000000f0000c0300 	\.292  nop
+ 928:	000782a900160780 	\.293  crc_be\[crc_32, gprA_1, \$xfer_1\], gpr_wrboth
+ 930:	000000f0000c0300 	\.294  nop
+ 938:	000ae3a900160780 	\.295  crc_be\[crc_32, gprA_1, \$xfer_1\], no_cc, gpr_wrboth
+ 940:	000000f0000c0300 	\.296  nop
+ 948:	000b73a900560780 	\.297  crc_be\[crc_32, gprA_5, \$xfer_1\], no_cc, gpr_wrboth, predicate_cc
+ 950:	000000f0000c0300 	\.298  nop
+ 958:	000122a900560781 	\.299  crc_be\[crc_32, gprA_5, \$xfer_1\], bytes_1_3, gpr_wrboth
+ 960:	000000f0000c0300 	\.300  nop
+ 968:	000000f0000c0300 	\.301  nop
+ 970:	000000f0000c0300 	\.302  nop
+ 978:	000000f0000c0300 	\.303  nop
+ 980:	000000f0000c0300 	\.304  nop
+ 988:	000000f0000c0300 	\.305  nop
+ 990:	0005a0e000080000 	\.306  ctx_arb\[--\]
+ 998:	000600e000000001 	\.307  ctx_arb\[voluntary\]
+ 9a0:	000220e000020000 	\.308  ctx_arb\[bpt\]
+ 9a8:	000460e000000220 	\.309  ctx_arb\[sig5, sig9\]
+ 9b0:	000d20e000200220 	\.310  ctx_arb\[sig5, sig9\], defer\[2\]
+ 9b8:	000180a0300c0f00 	\.311  alu\[--, --, B, 0x3\]
+ 9c0:	0007a0a0300c1f00 	\.312  alu\[--, --, B, 0x7\]
+ 9c8:	0006a0e000010220 	\.313  ctx_arb\[sig5, sig9\], any
+ 9d0:	000a60e077c40220 	\.314  ctx_arb\[sig5, sig9\], br\[\.479\]
+ 9d8:	0006409010500701 	\.315  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\]
+ 9e0:	000d4090a0500701 	\.316  dbl_shf\[gprB_5, gprA_1, gprB_1, >>10\]
+ 9e8:	000c4091f0500701 	\.317  dbl_shf\[gprB_5, gprA_1, gprB_1, >>31\]
+ 9f0:	000740a440000402 	\.318  alu\[gprA_0, gprB_1, AND, gprA_2\]
+ 9f8:	0000c09000500701 	\.319  dbl_shf\[gprB_5, gprA_1, gprB_1, >>indirect\]
+ a00:	000b219010500701 	\.320  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\], no_cc
+ a08:	000cf19010500701 	\.321  dbl_shf\[gprB_5, gprA_1, gprB_1, >>1\], no_cc, predicate_cc
+ a10:	0000d28010500701 	\.322  dbl_shf\[gprA_5, gprA_1, gprB_1, >>1\], gpr_wrboth, predicate_cc
+ a18:	000200a700f03f00 	\.323  ffs\[gprA_15, gprB_15\]
+ a20:	000fe0b740fc000f 	\.324  ffs\[gprB_15, gprA_15\]
+ a28:	000ec0b700f61300 	\.325  ffs\[gprB_15, \$xfer_4\]
+ a30:	000660b700f88300 	\.326  ffs\[gprB_15, \*l\$index1\]
+ a38:	0007e4b700f8c300 	\.327  ffs\[gprB_15, \*l\$index3\+\+\]
+ a40:	0002c4b700f8c700 	\.328  ffs\[gprB_15, \*l\$index3--\]
+ a48:	0004c4b700f8a700 	\.329  ffs\[gprB_15, \*l\$index3\[9\]\]
+ a50:	000880a720000300 	\.330  ffs\[\*l\$index0, gprB_0\]
+ a58:	000108a722090700 	\.331  ffs\[\*l\$index3, \*n\$index\]
+ a60:	000128a723190f00 	\.332  ffs\[\*l\$index3--, \*n\$index\+\+\]
+ a68:	0003c3a740fc000f 	\.333  ffs\[gprA_15, gprA_15\], no_cc, gpr_wrboth
+ a70:	000972a740fc000f 	\.334  ffs\[gprA_15, gprA_15\], gpr_wrboth, predicate_cc
+ a78:	000320f0000c0803 	\.335  immed\[gprA_3, 0x2\]
+ a80:	000480e8004d4803 	\.336  jump\[gprA_3, \.338\]
+ a88:	0006a0d854408038 	\.337  br\[\.337\]
+ a90:	000460f000002701 	\.338  immed\[gprB_9, 0x1\]
+ a98:	0006a0d854408038 	\.339  br\[\.337\]
+ aa0:	0005e0f000002702 	\.340  immed\[gprB_9, 0x2\]
+ aa8:	0006a0d854408038 	\.341  br\[\.337\]
+ ab0:	000500f000002703 	\.342  immed\[gprB_9, 0x3\]
+ ab8:	0006a0d854408038 	\.343  br\[\.337\]
+ ac0:	000040c001000000 	\.344  ld_field\[gprA_0, 0001, gprB_0\]
+ ac8:	0007e2c001000000 	\.345  ld_field\[gprA_0, 0001, gprB_0\], gpr_wrboth
+ ad0:	000e40c401000000 	\.346  ld_field\[gprA_0, 0001, gprB_0\], load_cc
+ ad8:	000790c001000000 	\.347  ld_field\[gprA_0, 0001, gprB_0\], predicate_cc
+ ae0:	0005c0c005000000 	\.348  ld_field\[gprA_0, 0101, gprB_0\]
+ ae8:	000080c005100000 	\.349  ld_field_w_clr\[gprA_0, 0101, gprB_0\]
+ af0:	0002a2c001100000 	\.350  ld_field_w_clr\[gprA_0, 0001, gprB_0\], gpr_wrboth
+ af8:	000b00c401100000 	\.351  ld_field_w_clr\[gprA_0, 0001, gprB_0\], load_cc
+ b00:	0002d0c001100000 	\.352  ld_field_w_clr\[gprA_0, 0001, gprB_0\], predicate_cc
+ b08:	000fc0c00f000000 	\.353  ld_field\[gprA_0, 1111, gprB_0\]
+ b10:	0005e0c1fb000200 	\.354  ld_field\[gprA_0, 1011, gprB_0, <<1\]
+ b18:	000460c01b000100 	\.355  ld_field\[gprA_0, 1011, gprB_0, >>1\]
+ b20:	000e60c1fb000100 	\.356  ld_field\[gprA_0, 1011, gprB_0, >>31\]
+ b28:	000bc0c09b000000 	\.357  ld_field\[gprA_0, 1011, gprB_0, >>rot9\]
+ b30:	000e80c09b100000 	\.358  ld_field_w_clr\[gprA_0, 1011, gprB_0, >>rot9\]
+ b38:	0001c0c17b000000 	\.359  ld_field\[gprA_0, 1011, gprB_0, >>rot23\]
+ b40:	0002c0c41b000000 	\.360  ld_field\[gprA_0, 1011, gprB_0, >>rot1\], load_cc
+ b48:	000780c41b100000 	\.361  ld_field_w_clr\[gprA_0, 1011, gprB_0, >>rot1\], load_cc
+ b50:	000400f0001f7c01 	\.362  immed\[gprA_1, 0x1df\]
+ b58:	000200f0001007df 	\.363  immed\[gprB_1, 0x1df\]
+ b60:	0005a2f0001007df 	\.364  immed\[gprB_1, 0x1df\], gpr_wrboth
+ b68:	0005d0f0001007df 	\.365  immed\[gprB_1, 0x1df\], predicate_cc
+ b70:	000020fc010c0000 	\.366  local_csr_rd\[ALUOut\]
+ b78:	000e60f0000c000b 	\.367  immed\[gprA_11, 0x0\]
+ b80:	000ce0fc160c0000 	\.368  local_csr_rd\[MiscControl\]
+ b88:	000e60f0000c000b 	\.369  immed\[gprA_11, 0x0\]
+ b90:	000ae0fc076c0b02 	\.370  local_csr_wr\[XferIndex, 0x2\]
+ b98:	0008a0fc076c0003 	\.371  local_csr_wr\[XferIndex, gprA_3\]
+ ba0:	000520fc07600f00 	\.372  local_csr_wr\[XferIndex, gprB_3\]
+ ba8:	000f20fc01a00f00 	\.373  local_csr_wr\[CtxEnables, gprB_3\]
+ bb0:	000480f800000c02 	\.374  mul_step\[gprA_2, gprB_3\], start
+ bb8:	000880f980000c02 	\.375  mul_step\[gprA_2, gprB_3\], 32x32_step1
+ bc0:	000dc0f980100c02 	\.376  mul_step\[gprA_2, gprB_3\], 32x32_step2
+ bc8:	0001c0f980200c02 	\.377  mul_step\[gprA_2, gprB_3\], 32x32_step3
+ bd0:	000480f980300c02 	\.378  mul_step\[gprA_2, gprB_3\], 32x32_step4
+ bd8:	000940f9804c0002 	\.379  mul_step\[gprA_2, --\], 32x32_last
+ be0:	000ce0f9805c0003 	\.380  mul_step\[gprA_3, --\], 32x32_last2
+ be8:	0001a0f800000802 	\.381  mul_step\[gprA_2, gprB_2\], start
+ bf0:	000aa0f900000802 	\.382  mul_step\[gprA_2, gprB_2\], 16x16_step1
+ bf8:	000fe0f900100802 	\.383  mul_step\[gprA_2, gprB_2\], 16x16_step2
+ c00:	000f20f9004c0000 	\.384  mul_step\[gprA_0, --\], 16x16_last
+ c08:	0001a0f800000802 	\.385  mul_step\[gprA_2, gprB_2\], start
+ c10:	0006a0f880000802 	\.386  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c18:	000320f8804c0000 	\.387  mul_step\[gprA_0, --\], 24x8_last
+ c20:	0001a0f800000802 	\.388  mul_step\[gprA_2, gprB_2\], start
+ c28:	0006a0f880000802 	\.389  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c30:	0004f0f8804c0000 	\.390  mul_step\[gprA_0, --\], 24x8_last, predicate_cc
+ c38:	0001a0f800000802 	\.391  mul_step\[gprA_2, gprB_2\], start
+ c40:	0006a0f880000802 	\.392  mul_step\[gprA_2, gprB_2\], 24x8_step1
+ c48:	0009e3f8804c0000 	\.393  mul_step\[gprA_0, --\], 24x8_last, no_cc, gpr_wrboth
+ c50:	000b80a330000000 	\.394  pop_count1\[gprB_0\]
+ c58:	000c80a3b0000000 	\.395  pop_count2\[gprB_0\]
+ c60:	000d80a180000000 	\.396  pop_count3\[gprA_0, gprB_0\]
+ c68:	000b80a330000000 	\.397  pop_count1\[gprB_0\]
+ c70:	000c80a3b0000000 	\.398  pop_count2\[gprB_0\]
+ c78:	000743a180000000 	\.399  pop_count3\[gprA_0, gprB_0\], no_cc, gpr_wrboth
+ c80:	0004a4a330088000 	\.400  pop_count1\[\*l\$index3\]
+ c88:	0003a4a3b0088000 	\.401  pop_count2\[\*l\$index3\]
+ c90:	0000e5a1a438c000 	\.402  pop_count3\[\*n\$index\+\+, \*l\$index3\+\+\], no_cc
+ c98:	000b80a330000000 	\.403  pop_count1\[gprB_0\]
+ ca0:	000c80a3b0000000 	\.404  pop_count2\[gprB_0\]
+ ca8:	000731a180000000 	\.405  pop_count3\[gprA_0, gprB_0\], no_cc, predicate_cc
+ cb0:	000480e8000c0000 	\.406  rtn\[gprA_0\]
+ cb8:	000620e8000a0700 	\.407  rtn\[n\$reg_1\]
+ cc0:	000600e800088300 	\.408  rtn\[\*l\$index1\]
+ cc8:	000a64e800080300 	\.409  rtn\[\*l\$index2\]
+ cd0:	000dc0e800200300 	\.410  rtn\[gprB_0\], defer\[2\]
+ cd8:	0008a0a0300c0700 	\.411  alu\[--, --, B, 0x1\]
+ ce0:	0004a0a0300c0b00 	\.412  alu\[--, --, B, 0x2\]
+ ce8:	000000f0000c0300 	\.413  nop
+ cf0:	000000f0000c0300 	\.414  nop
+ cf8:	000000f0000c0300 	\.415  nop
+ d00:	000000f0000c0300 	\.416  nop
+ d08:	0003501842300c09 	\.417  arm\[read, \$xfer_3, gprA_9, gprB_3, 2\], ctx_swap\[sig4\]
+ d10:	0005501842302403 	\.418  arm\[read, \$xfer_3, gprA_3, gprB_9, 2\], ctx_swap\[sig4\]
+ d18:	0004801842300c09 	\.419  arm\[read, \$xfer_3, gprA_9, <<8, gprB_3, 2\], ctx_swap\[sig4\]
+ d20:	000f241842302403 	\.420  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], ctx_swap\[sig4\]
+ d28:	0004a0a0300c0b00 	\.421  alu\[--, --, B, 0x2\]
+ d30:	0008861842302403 	\.422  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], indirect_ref, ctx_swap\[sig4\]
+ d38:	0004a0a0300c0b00 	\.423  alu\[--, --, B, 0x2\]
+ d40:	000e8618e2302703 	\.424  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], indirect_ref, sig_done\[sig14\]
+ d48:	0007841842302503 	\.425  arm\[read, \$xfer_3, gprB_9, <<8, gprA_3, 2\], ctx_swap\[sig4\], defer\[1\]
+ d50:	0008a0a0300c0700 	\.426  alu\[--, --, B, 0x1\]
+ d58:	000f101843c00c09 	\.427  arm\[read, \$xfer_28, gprA_9, gprB_3, 2\], ctx_swap\[sig4\]
+ d60:	000910184e800c09 	\.428  arm\[read, \$xfer_8, gprA_9, gprB_3, 8\], ctx_swap\[sig4\]
+ d68:	000a106440800c09 	\.429  cls\[add, \$xfer_8, gprA_9, gprB_3, 1\], ctx_swap\[sig4\]
+ d70:	0000f0664080a009 	\.430  cls\[sub, \$xfer_8, gprA_9, 0x8, 1\], ctx_swap\[sig4\]
+ d78:	000160644284a009 	\.431  cls\[add64, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ d80:	000404664284a408 	\.432  cls\[sub64, \$xfer_8, 0x9, <<8, gprA_8, 2\], ctx_swap\[sig4\]
+ d88:	0008a0a0300c0700 	\.433  alu\[--, --, B, 0x1\]
+ d90:	00032c650340a708 	\.434  cls\[add_imm, 0x14, 0x9, <<8, gprA_8, 2\]
+ d98:	0007506040880c09 	\.435  cls\[swap/test_compare_write, \$xfer_8, gprA_9, gprB_3, 1\], ctx_swap\[sig4\]
+ da0:	00023c6500007f9a 	\.436  cls\[add_imm, 0x1f9a, --, 1\]
+ da8:	000038653c583f14 	\.437  cls\[add_imm, 0xf14, 0xf16\]
+ db0:	000b54640013c30f 	\.438  cls\[add, \$xfer_1, 0xf00f, 1\]
+ db8:	0002901c10a08000 	\.439  ct\[xpb_read, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dc0:	0007501e10a48000 	\.440  ct\[reflect_read_sig_init, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dc8:	000a501c10a48000 	\.441  ct\[ring_get, \$xfer_10, gprA_0, 0x0, 1\], ctx_swap\[sig1\]
+ dd0:	000000f0000c0300 	\.442  nop
+ dd8:	000cc0474a80a009 	\.443  mem\[add64, \$xfer_8, gprA_9, <<8, 0x8, 6\], ctx_swap\[sig4\]
+ de0:	000d40404280a009 	\.444  mem\[read, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ de8:	000c405c4280a009 	\.445  mem\[read32, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ df0:	000ea0554280a009 	\.446  mem\[ctm\.pe_dma_to_memory_indirect/emem\.get/imem\.lb_bucket_read_local, \$xfer_8, gprA_9, <<8, 0x8, 2\], ctx_swap\[sig4\]
+ df8:	0009204c408ca309 	\.447  mem\[lock128/lock384, \$xfer_8, gprA_9, <<8, 0x8, 1\], sig_done\[sig4\]
+ e00:	000f20e000000030 	\.448  ctx_arb\[sig4, sig5\]
+ e08:	0000a04c488ca309 	\.449  mem\[lock256/lock512, \$xfer_8, gprA_9, <<8, 0x8, 5\], sig_done\[sig4\]
+ e10:	000f20e000000030 	\.450  ctx_arb\[sig4, sig5\]
+ e18:	000ae04d4084a009 	\.451  mem\[microq128_pop, \$xfer_8, gprA_9, <<8, 0x8, 1\], ctx_swap\[sig4\]
+ e20:	0002204d4080a009 	\.452  mem\[microq128_get, \$xfer_8, gprA_9, <<8, 0x8, 1\], ctx_swap\[sig4\]
+ e28:	000ba04d4880a009 	\.453  mem\[microq256_get, \$xfer_8, gprA_9, <<8, 0x8, 5\], ctx_swap\[sig4\]
+ e30:	0003805700028309 	\.454  mem\[ctm\.pe_dma_from_memory_buffer/emem\.fast_journal/imem\.lb_push_stats_local, \$xfer_0, gprA_9, <<8, 0x40, 1\]
+ e38:	0005e04e4000a309 	\.455  mem\[queue128_lock, \$xfer_0, gprA_9, <<8, 0x8, 1\], sig_done\[sig4\]
+ e40:	000f20e000000030 	\.456  ctx_arb\[sig4, sig5\]
+ e48:	0001a04e0004a309 	\.457  mem\[queue128_unlock, \$xfer_0, gprA_9, <<8, 0x8, 1\]
+ e50:	000c604e4800a309 	\.458  mem\[queue256_lock, \$xfer_0, gprA_9, <<8, 0x8, 5\], sig_done\[sig4\]
+ e58:	000f20e000000030 	\.459  ctx_arb\[sig4, sig5\]
+ e60:	0008204e0804a309 	\.460  mem\[queue256_unlock, \$xfer_0, gprA_9, <<8, 0x8, 5\]
+ e68:	0008a05000001309 	\.461  mem\[ctm\.packet_wait_packet_status/emem\.rd_qdesc/imem\.stats_log, \$xfer_0, gprA_9, <<8, gprB_4, 1\]
+ e70:	000b840092200c02 	\.462  ila\[read, \$xfer_2, gprB_3, <<8, gprA_2, 2\], ctx_swap\[sig9\]
+ e78:	0005440182240f02 	\.463  ila\[write_check_error, \$xfer_2, gprB_3, <<8, gprA_2, 2\], sig_done\[sig8\]
+ e80:	000d60e000000300 	\.464  ctx_arb\[sig8, sig9\]
+ e88:	0007800410600000 	\.465  nbi\[read, \$xfer_6, gprA_0, <<8, gprB_0, 1\], ctx_swap\[sig1\]
+ e90:	0002600c62000000 	\.466  pcie\[read, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ e98:	0004c40d62000000 	\.467  pcie\[write, \$xfer_0, gprB_0, <<8, gprA_0, 2\], ctx_swap\[sig6\]
+ ea0:	000d601462000000 	\.468  crypto\[read, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ ea8:	0006601562000000 	\.469  crypto\[write, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ eb0:	0000601662000000 	\.470  crypto\[write_fifo, \$xfer_0, gprA_0, <<8, gprB_0, 2\], ctx_swap\[sig6\]
+ eb8:	000d840d60000050 	\.471  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index0, 1\], ctx_swap\[sig6\]
+ ec0:	0009e40d60000058 	\.472  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index1, 1\], ctx_swap\[sig6\]
+ ec8:	0009040d60000059 	\.473  pcie\[write, \$xfer_0, gprB_0, <<8, \*l\$index1\[1\], 1\], ctx_swap\[sig6\]
+ ed0:	000000f0000c0300 	\.474  nop
+ ed8:	000000f0000c0300 	\.475  nop
+ ee0:	000000f0000c0300 	\.476  nop
+ ee8:	000000f0000c0300 	\.477  nop
+ ef0:	000000f0000c0300 	\.478  nop
+ ef8:	000060a900301340 	\.479  crc_be\[crc_ccitt, gprA_3, gprB_4\]
+ f00:	000000f0000c0300 	\.480  nop
+ f08:	000e20b9403d0004 	\.481  crc_be\[crc_ccitt, gprB_3, gprA_4\]
+ f10:	000000f0000c0300 	\.482  nop
+ f18:	000400a900301348 	\.483  crc_le\[crc_ccitt, gprA_3, gprB_4\]
+ f20:	000000f0000c0300 	\.484  nop
+ f28:	000400b9403d2004 	\.485  crc_le\[crc_ccitt, gprB_3, gprA_4\]
+ f30:	000000f0000c0300 	\.486  nop
+ f38:	0002e0b900301348 	\.487  crc_le\[crc_ccitt, gprB_3, gprB_4\]
+ f40:	000000f0000c0300 	\.488  nop
+ f48:	0002e0a9403d2004 	\.489  crc_le\[crc_ccitt, gprA_3, gprA_4\]
+ f50:	000000f0000c0300 	\.490  nop
+ f58:	000220e000020000 	\.491  ctx_arb\[bpt\]
+ f60:	000420e000010000 	\.492  ctx_arb\[kill\]
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/binutils/testsuite/binutils-all/nfp/test2_ctx8.d	2019-03-07 14:44:05.716268317 +0000
@@ -0,0 +1,16 @@
+
+.*:     file format elf64-nfp
+
+
+Disassembly of section \.text\.i32\.me0:
+
+0000000000000000 <\.text\.i32\.me0>:
+   0:	000d80a0300c0300 	\.0  alu\[--, --, B, 0x0\]
+   8:	0008a0a0300c0700 	\.1  alu\[--, --, B, 0x1\]
+  10:	0004a0a0300c0b00 	\.2  alu\[--, --, B, 0x2\]
+  18:	000180a0300c0f00 	\.3  alu\[--, --, B, 0x3\]
+  20:	0004a0a018cc1300 	\.4  alu\[\$xfer_12, --, B, 0x4\]
+  28:	0001c0a019fc1700 	\.5  alu\[\$xfer_15, --, B, 0x5\]
+  30:	000400a0b00c198c 	\.6  alu\[--, \$xfer_12, \+, 0x6\]
+  38:	0008c0a0b00c1d9f 	\.7  alu\[--, \$xfer_15, \+, 0x7\]
+  40:	000220e000020000 	\.8  ctx_arb\[bpt\]
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/binutils/testsuite/binutils-all/nfp/test2_no-pc_ctx4.d	2019-03-07 14:44:05.716268317 +0000
@@ -0,0 +1,16 @@
+
+.*:     file format elf64-nfp
+
+
+Disassembly of section \.text\.i32\.me0:
+
+0000000000000000 <\.text\.i32\.me0>:
+   0:	000d80a0300c0300 	alu\[--, --, B, 0x0\]
+   8:	0008a0a0300c0700 	alu\[--, --, B, 0x1\]
+  10:	0004a0a0300c0b00 	alu\[--, --, B, 0x2\]
+  18:	000180a0300c0f00 	alu\[--, --, B, 0x3\]
+  20:	0004a0a018cc1300 	alu\[\$xfer_12, --, B, 0x4\]
+  28:	0001c0a019fc1700 	alu\[\$xfer_31, --, B, 0x5\]
+  30:	000400a0b00c198c 	alu\[--, \$xfer_12, \+, 0x6\]
+  38:	0008c0a0b00c1d9f 	alu\[--, \$xfer_31, \+, 0x7\]
+  40:	000220e000020000 	ctx_arb\[bpt\]
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/include/elf/nfp.h	2019-03-07 14:44:05.716268317 +0000
@@ -0,0 +1,292 @@
+/* NFP ELF support for BFD.
+   Copyright (C) 2017-2018 Free Software Foundation, Inc.
+   Contributed by Francois H. Theron <francois.theron@netronome.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_NFP_H
+#define _ELF_NFP_H
+
+#include "bfd.h"
+#include "elf/common.h"
+#include "elf/reloc-macros.h"
+#include "bfd_stdint.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define ET_NFP_PARTIAL_REL (ET_LOPROC + ET_REL)
+#define ET_NFP_PARTIAL_EXEC (ET_LOPROC + ET_EXEC)
+
+/* NFP e_flags - chip family
+   Valid values for FAMILY are:
+   0x3200 - NFP-32xx
+   0x6000 - NFP-6xxx/NFP-4xxx.  */
+#define EF_NFP_MACH(ef_nfp)        (((ef_nfp) >> 8) & 0xFFFF)
+#define EF_NFP_SET_MACH(nfp_fam)   (((nfp_fam) & 0xFFFF) << 8)
+
+#define E_NFP_MACH_3200	0x3200
+#define E_NFP_MACH_6000	0x6000
+
+#define NFP_3200_CPPTGT_MSF0     1
+#define NFP_3200_CPPTGT_QDR      2
+#define NFP_3200_CPPTGT_MSF1     3
+#define NFP_3200_CPPTGT_HASH     4
+#define NFP_3200_CPPTGT_MU       7
+#define NFP_3200_CPPTGT_GS       8
+#define NFP_3200_CPPTGT_PCIE     9
+#define NFP_3200_CPPTGT_ARM     10
+#define NFP_3200_CPPTGT_CRYPTO  12
+#define NFP_3200_CPPTGT_CAP     13
+#define NFP_3200_CPPTGT_CT      14
+#define NFP_3200_CPPTGT_CLS     15
+
+#define NFP_6000_CPPTGT_NBI      1
+#define NFP_6000_CPPTGT_VQDR     2
+#define NFP_6000_CPPTGT_ILA      6
+#define NFP_6000_CPPTGT_MU       7
+#define NFP_6000_CPPTGT_PCIE     9
+#define NFP_6000_CPPTGT_ARM     10
+#define NFP_6000_CPPTGT_CRYPTO  12
+#define NFP_6000_CPPTGT_CTXPB   14
+#define NFP_6000_CPPTGT_CLS     15
+
+/* NFP Section types
+   MECONFIG - NFP-32xx only, ME CSR configurations
+   INITREG - A generic register initialisation section (chip or ME CSRs/GPRs)
+   UDEBUG - Legacy-style debug data section.  */
+#define SHT_NFP_MECONFIG	(SHT_LOPROC + 1)
+#define SHT_NFP_INITREG		(SHT_LOPROC + 2)
+#define SHT_NFP_UDEBUG		SHT_LOUSER
+
+/* NFP SECTION flags
+     ELF-64 sh_flags is 64-bit, but there is no info on what the upper 32 bits
+     are expected to be used for, it is not marked reserved either.
+     We'll use them for NFP-specific flags since we don't use ELF-32.
+
+   INIT - Sections that are loaded and executed before the final text
+	  microcode.  Non-code INIT sections are loaded first, then other
+	  memory secions, then INIT2 sections, then INIT-code sections.
+   INIT2 - Sections that are loaded before INIT-code sections, used for
+	   transient configuration before executing INIT-code section
+	   microcode.
+   SCS - The number of additional ME codestores being shared with the group's
+	 base ME of the section, e.g. 0 for no SCS, 1 for dual and 3 for
+	 quad.  If this is 0 it is possible that stagger-style SCS codestore
+	 sections are being used.  For stagger-style each section is simply
+	 loaded directly to the ME it is assigned to.  If these flags are
+	 used, virtual address space loading will be used - one large section
+	 loaded to the group's base ME will be packed across shared MEs by
+	 hardware.  This is not available on all ME versions.
+
+    NFP_ELF_SHF_GET_SCS (val) returns the number of additional codestores
+    being shared with the group's base ME, e.g. 0 for no SCS,
+    1 for dual SCS, 3 for quad SCS.  */
+
+#define SHF_NFP_INIT		0x80000000
+#define SHF_NFP_INIT2		0x40000000
+#define SHF_NFP_SCS(shf)	(((shf) >> 32) & 0xFF)
+#define SHF_NFP_SET_SCS(v)	(((BFD_HOST_U_64_BIT)((v) & 0xFF)) << 32)
+
+/* NFP Section Info
+   For PROGBITS and NOBITS sections:
+     MEMTYPE - the memory type
+     DOMAIN - The island ID and ME number where the data will be loaded.
+	      For NFP-32xx, this is an island number or linear ME number.
+	      For NFP-6xxx, DOMAIN<15:8> == island ID, DOMAIN<7:0> is 0 based
+	      ME number (if applicable).
+   For INITREG sections:
+     ISLAND - island ID (if it's a ME target, ME numbers are in the
+	      section data)
+     CPPTGT - CPP Target ID
+     CPPACTRD - CPP Read Action
+     CPPTOKRD - CPP Read Token
+     CPPACTWR - CPP Write Action
+     CPPTOKWR - CPP Write Token
+     ORDER - Controls the order in which the loader processes sections with
+	     the same info fields.  */
+
+#define SHI_NFP_DOMAIN(shi)		(((shi) >> 16) & 0xFFFF)
+#define SHI_NFP_MEMTYPE(shi)		( (shi) & 0xFFFF)
+#define SHI_NFP_SET_DOMAIN(v)		(((v) & 0xFFFF) << 16)
+#define SHI_NFP_SET_MEMTYPE(v)		( (v) & 0xFFFF)
+
+#define SHI_NFP_IREG_ISLAND(shi)	(((shi) >> 26) & 0x3F)
+#define SHI_NFP_IREG_CPPTGT(shi)	(((shi) >> 22) &  0xF)
+#define SHI_NFP_IREG_CPPACTRD(shi)	(((shi) >> 17) & 0x1F)
+#define SHI_NFP_IREG_CPPTOKRD(shi)	(((shi) >> 15) &  0x3)
+#define SHI_NFP_IREG_CPPACTWR(shi)	(((shi) >> 10) & 0x1F)
+#define SHI_NFP_IREG_CPPTOKWR(shi)	(((shi) >> 8)  &  0x3)
+#define SHI_NFP_IREG_ORDER(shi)		( (shi) & 0xFF)
+#define SHI_NFP_SET_IREG_ISLAND(v)	(((v) & 0x3F) << 26)
+#define SHI_NFP_SET_IREG_CPPTGT(v)	(((v) &  0xF) << 22)
+#define SHI_NFP_SET_IREG_CPPACTRD(v)	(((v) & 0x1F) << 17)
+#define SHI_NFP_SET_IREG_CPPTOKRD(v)	(((v) &  0x3) << 15)
+#define SHI_NFP_SET_IREG_CPPACTWR(v)	(((v) & 0x1F) << 10)
+#define SHI_NFP_SET_IREG_CPPTOKWR(v)	(((v) &  0x3) << 8)
+#define SHI_NFP_SET_IREG_ORDER(v)	( (v) & 0xFF)
+
+/* CtXpb/reflect_read_sig_init/reflect_write_sig_init
+   identifies Init-CSR sections for ME CSRs.  */
+#define SHI_NFP_6000_IS_IREG_MECSR(shi) ( \
+  SHI_NFP_IREG_CPPTGT (shi) == NFP_6000_CPPTGT_CTXPB \
+  && SHI_NFP_IREG_CPPACTRD (shi) == 2 \
+  && SHI_NFP_IREG_CPPTOKRD (shi) == 1 \
+  && SHI_NFP_IREG_CPPACTWR (shi) == 3 \
+  && SHI_NFP_IREG_CPPTOKWR (shi) == 1 \
+)
+
+/* Transient INITREG sections will be validated against the target
+   but will not be kept - validate, write or read and discard.
+   They will still be handled last (in order).  */
+#define SHI_NFP_IREG_ORDER_TRANSIENT	0xFF
+
+/* Below are some extra macros to translate SHI fields in more specific
+   contexts.
+
+   For NFP-32xx, DOMAIN is set to a global linear ME number (0 to 39).
+   An NFP-32xx has 8 MEs per island and up to 5 islands.  */
+
+#define SHI_NFP_3200_ISLAND(shi)	((SHI_NFP_DOMAIN (shi) >> 3) & 0x7)
+#define SHI_NFP_3200_MENUM(shi)		( SHI_NFP_DOMAIN (shi)       & 0x7)
+#define SHI_NFP_SET_3200_ISLAND(v)	SHI_NFP_SET_DOMAIN (((v) & 0x7) << 3)
+#define SHI_NFP_SET_3200_MENUM(v)	SHI_NFP_SET_DOMAIN ( (v) & 0x7)
+
+#define SHI_NFP_ISLAND(shi)		((SHI_NFP_DOMAIN (shi) >> 8) & 0xFF)
+#define SHI_NFP_MENUM(shi)		( SHI_NFP_DOMAIN (shi)       & 0xFF)
+#define SHI_NFP_SET_ISLAND(shi)		SHI_NFP_SET_DOMAIN (((shi) & 0xFF) << 8)
+#define SHI_NFP_SET_MENUM(shi)		SHI_NFP_SET_DOMAIN ( (shi) & 0xFF)
+
+#define SHI_NFP_MEMTYPE_NONE 		0
+#define SHI_NFP_MEMTYPE_USTORE 		1
+#define SHI_NFP_MEMTYPE_LMEM 		2
+#define SHI_NFP_MEMTYPE_CLS 		3
+#define SHI_NFP_MEMTYPE_DRAM 		4
+#define SHI_NFP_MEMTYPE_MU 		4
+#define SHI_NFP_MEMTYPE_SRAM 		5
+#define SHI_NFP_MEMTYPE_GS 		6
+#define SHI_NFP_MEMTYPE_PPC_LMEM 	7
+#define SHI_NFP_MEMTYPE_PPC_SMEM 	8
+#define SHI_NFP_MEMTYPE_EMU_CACHE 	9
+
+/* VTP_FORCE is for use by the NFP Linker+Loader only.  */
+#define NFP_IREG_VTP_FORCE		0
+#define NFP_IREG_VTP_CONST		1
+#define NFP_IREG_VTP_REQUIRED		2
+#define NFP_IREG_VTP_VOLATILE_INIT	3
+#define NFP_IREG_VTP_VOLATILE_NOINIT	4
+#define NFP_IREG_VTP_INVALID		5
+
+/* Init-CSR entry w0 fields:
+   NLW - Not Last Word
+   CTX - ME context number (if applicable)
+   VTP - Value type
+   COH - CPP Offset High 8 bits.  */
+#define NFP_IREG_ENTRY_WO_NLW(w0) (((w0) >> 31) & 0x1)
+#define NFP_IREG_ENTRY_WO_CTX(w0) (((w0) >> 28) & 0x7)
+#define NFP_IREG_ENTRY_WO_VTP(w0) (((w0) >> 25) & 0x7)
+#define NFP_IREG_ENTRY_WO_COH(w0) (((w0) >> 0) & 0xFF)
+
+typedef struct
+{
+  uint32_t w0;
+  uint32_t cpp_offset_lo;
+  uint32_t val;
+  uint32_t mask;
+} Elf_Nfp_InitRegEntry;
+
+typedef struct
+{
+  uint32_t ctx_enables;
+  uint32_t entry;
+  uint32_t misc_control;
+  uint32_t reserved;
+} Elf_Nfp_MeConfig;
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_nfp3200_reloc_type)
+    RELOC_NUMBER (R_NFP3200_NOTYPE, 0)
+    RELOC_NUMBER (R_NFP3200_W32LE, 1)
+    RELOC_NUMBER (R_NFP3200_SRC8_A, 2)
+    RELOC_NUMBER (R_NFP3200_SRC8_B, 3)
+    RELOC_NUMBER (R_NFP3200_IMMED8_I, 4)
+    RELOC_NUMBER (R_NFP3200_SC, 5)
+    RELOC_NUMBER (R_NFP3200_IMMED_LO16_I_A, 6)
+    RELOC_NUMBER (R_NFP3200_IMMED_LO16_I_B, 7)
+    RELOC_NUMBER (R_NFP3200_SRC7_B, 8)
+    RELOC_NUMBER (R_NFP3200_SRC7_A, 9)
+    RELOC_NUMBER (R_NFP3200_SRC8_I_B, 10)
+    RELOC_NUMBER (R_NFP3200_SRC8_I_A, 11)
+    RELOC_NUMBER (R_NFP3200_IMMED_HI16_I_A, 12)
+    RELOC_NUMBER (R_NFP3200_IMMED_HI16_I_B, 13)
+    RELOC_NUMBER (R_NFP3200_RSVD_0, 14)
+    RELOC_NUMBER (R_NFP3200_RSVD_1, 15)
+    RELOC_NUMBER (R_NFP3200_RSVD_2, 16)
+    RELOC_NUMBER (R_NFP3200_RSVD_3, 17)
+    RELOC_NUMBER (R_NFP3200_RSVD_4, 18)
+    RELOC_NUMBER (R_NFP3200_RSVD_5, 19)
+    RELOC_NUMBER (R_NFP3200_RSVD_6, 20)
+    RELOC_NUMBER (R_NFP3200_W64LE, 21)
+    RELOC_NUMBER (R_NFP3200_W32BE, 22)
+    RELOC_NUMBER (R_NFP3200_W64BE, 23)
+    RELOC_NUMBER (R_NFP3200_W32LE_AND, 24)
+    RELOC_NUMBER (R_NFP3200_W32BE_AND, 25)
+    RELOC_NUMBER (R_NFP3200_W32LE_OR, 26)
+    RELOC_NUMBER (R_NFP3200_W32BE_OR, 27)
+    RELOC_NUMBER (R_NFP3200_W64LE_AND, 28)
+    RELOC_NUMBER (R_NFP3200_W64BE_AND, 29)
+    RELOC_NUMBER (R_NFP3200_W64LE_OR, 30)
+    RELOC_NUMBER (R_NFP3200_W64BE_OR, 31)
+END_RELOC_NUMBERS (R_NFP3200_MAX)
+
+START_RELOC_NUMBERS (elf_nfp_reloc_type)
+    RELOC_NUMBER (R_NFP_NOTYPE, 0)
+    RELOC_NUMBER (R_NFP_W32LE, 1)
+    RELOC_NUMBER (R_NFP_SRC8_A, 2)
+    RELOC_NUMBER (R_NFP_SRC8_B, 3)
+    RELOC_NUMBER (R_NFP_IMMED8_I, 4)
+    RELOC_NUMBER (R_NFP_SC, 5)
+    RELOC_NUMBER (R_NFP_IMMED_LO16_I_A, 6)
+    RELOC_NUMBER (R_NFP_IMMED_LO16_I_B, 7)
+    RELOC_NUMBER (R_NFP_SRC7_B, 8)
+    RELOC_NUMBER (R_NFP_SRC7_A, 9)
+    RELOC_NUMBER (R_NFP_SRC8_I_B, 10)
+    RELOC_NUMBER (R_NFP_SRC8_I_A, 11)
+    RELOC_NUMBER (R_NFP_IMMED_HI16_I_A, 12)
+    RELOC_NUMBER (R_NFP_IMMED_HI16_I_B, 13)
+    RELOC_NUMBER (R_NFP_W64LE, 14)
+    RELOC_NUMBER (R_NFP_SH_INFO, 15)
+    RELOC_NUMBER (R_NFP_W32BE, 16)
+    RELOC_NUMBER (R_NFP_W64BE, 17)
+    RELOC_NUMBER (R_NFP_W32_29_24, 18)
+    RELOC_NUMBER (R_NFP_W32LE_AND, 19)
+    RELOC_NUMBER (R_NFP_W32BE_AND, 20)
+    RELOC_NUMBER (R_NFP_W32LE_OR, 21)
+    RELOC_NUMBER (R_NFP_W32BE_OR, 22)
+    RELOC_NUMBER (R_NFP_W64LE_AND, 23)
+    RELOC_NUMBER (R_NFP_W64BE_AND, 24)
+    RELOC_NUMBER (R_NFP_W64LE_OR, 25)
+    RELOC_NUMBER (R_NFP_W64BE_OR, 26)
+END_RELOC_NUMBERS (R_NFP_MAX)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ELF_NFP_H */
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/include/opcode/nfp.h	2019-03-07 14:50:55.251991587 +0000
@@ -0,0 +1,175 @@
+/* nfp.h.  NFP opcode list.
+   Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Francois H. Theron <francois.theron@netronome.com>
+
+   This file is part of the GNU opcodes library.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef _NFP_H_
+#define _NFP_H_
+
+#include "bfd.h"
+#include "bfd_stdint.h"
+#include "elf/nfp.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* We use ME versions for most of this rather than NFP family and revision
+   numbers.  The version numbers are currently 2.7 and 2.8 and to avoid long
+   names with many underscores we'll just use 27 and 28 until some feature
+   number makes it necessary to do something different.  */
+
+#define NFP_ME27_INSTR_MASK_CMD	        ((uint64_t) 0x008000000000)
+#define NFP_ME27_INSTR_CMD		((uint64_t) 0x000000000000)
+#define NFP_ME27_INSTR_IS_CMD(instr) \
+	((instr & NFP_ME27_INSTR_MASK_CMD) == NFP_ME27_INSTR_CMD)
+
+#define NFP_ME27_INSTR_MASK_ALU_SHF	((uint64_t) 0x1ee000000000)
+#define NFP_ME27_INSTR_ALU_SHF		((uint64_t) 0x008000000000)
+#define NFP_ME27_INSTR_IS_ALU_SHF(instr) \
+	((instr & NFP_ME27_INSTR_MASK_ALU_SHF) == NFP_ME27_INSTR_ALU_SHF)
+
+#define NFP_ME27_INSTR_MASK_ALU	        ((uint64_t) 0x1ee000000000)
+#define NFP_ME27_INSTR_ALU		((uint64_t) 0x00a000000000)
+#define NFP_ME27_INSTR_IS_ALU(instr) \
+		((instr & NFP_ME27_INSTR_MASK_ALU) == NFP_ME27_INSTR_ALU)
+
+#define NFP_ME27_INSTR_MASK_IMMED	((uint64_t) 0x1ff900000000)
+#define NFP_ME27_INSTR_IMMED		((uint64_t) 0x00f000000000)
+#define NFP_ME27_INSTR_IS_IMMED(instr) \
+	((instr & NFP_ME27_INSTR_MASK_IMMED) == NFP_ME27_INSTR_IMMED)
+
+#define NFP_ME27_INSTR_MASK_LD_FIELD	((uint64_t) 0x1ffa00e00000)
+#define NFP_ME27_INSTR_LD_FIELD	        ((uint64_t) 0x00c000000000)
+#define NFP_ME27_INSTR_IS_LD_FIELD(instr) \
+	((instr & NFP_ME27_INSTR_MASK_LD_FIELD) == NFP_ME27_INSTR_LD_FIELD)
+
+#define NFP_ME27_INSTR_MASK_CTX_ARB	((uint64_t) 0x00f800000000)
+#define NFP_ME27_INSTR_CTX_ARB		((uint64_t) 0x00e000000000)
+#define NFP_ME27_INSTR_IS_CTX_ARB(instr) \
+	((instr & NFP_ME27_INSTR_MASK_CTX_ARB) == NFP_ME27_INSTR_CTX_ARB)
+
+#define NFP_ME27_INSTR_MASK_LOCAL_CSR	((uint64_t) 0x1ffe00100000)
+#define NFP_ME27_INSTR_LOCAL_CSR	((uint64_t) 0x00fc00000000)
+#define NFP_ME27_INSTR_IS_LOCAL_CSR(instr) \
+	((instr & NFP_ME27_INSTR_MASK_LOCAL_CSR) == NFP_ME27_INSTR_LOCAL_CSR)
+
+#define NFP_ME27_INSTR_MASK_BRANCH	((uint64_t) 0x00f8000c3ce0)
+#define NFP_ME27_INSTR_BRANCH		((uint64_t) 0x00d800000020)
+#define NFP_ME27_INSTR_IS_BRANCH(instr) \
+	((instr & NFP_ME27_INSTR_MASK_BRANCH) == NFP_ME27_INSTR_BRANCH)
+
+#define NFP_ME27_INSTR_MASK_BR_BYTE	((uint64_t) 0x00f800000000)
+#define NFP_ME27_INSTR_BR_BYTE		((uint64_t) 0x00c800000000)
+#define NFP_ME27_INSTR_IS_BR_BYTE(instr) \
+	((instr & NFP_ME27_INSTR_MASK_BR_BYTE) == NFP_ME27_INSTR_BR_BYTE)
+
+#define NFP_ME27_INSTR_MASK_BR_BIT	((uint64_t) 0x00f800080300)
+#define NFP_ME27_INSTR_BR_BIT		((uint64_t) 0x00d000000000)
+#define NFP_ME27_INSTR_IS_BR_BIT(instr) \
+	((instr & NFP_ME27_INSTR_MASK_BR_BIT) == NFP_ME27_INSTR_BR_BIT)
+
+#define NFP_ME27_INSTR_MASK_BR_ALU	((uint64_t) 0x1fff80000000)
+#define NFP_ME27_INSTR_BR_ALU		((uint64_t) 0x00e800000000)
+#define NFP_ME27_INSTR_IS_BR_ALU(instr) \
+	((instr & NFP_ME27_INSTR_MASK_BR_ALU) == NFP_ME27_INSTR_BR_ALU)
+
+#define NFP_ME27_INSTR_MASK_MULT	((uint64_t) 0x1efe3f000000)
+#define NFP_ME27_INSTR_MULT		((uint64_t) 0x00f800000000)
+#define NFP_ME27_INSTR_IS_MULT(instr) \
+	((instr & NFP_ME27_INSTR_MASK_MULT) == NFP_ME27_INSTR_MULT)
+
+
+#define NFP_ME28_INSTR_MASK_CMD	        ((uint64_t) 0x008000000000)
+#define NFP_ME28_INSTR_CMD		((uint64_t) 0x000000000000)
+#define NFP_ME28_INSTR_IS_CMD(instr) \
+	((instr & NFP_ME28_INSTR_MASK_CMD) == NFP_ME28_INSTR_CMD)
+
+#define NFP_ME28_INSTR_MASK_ALU_SHF	((uint64_t) 0x00e000000000)
+#define NFP_ME28_INSTR_ALU_SHF		((uint64_t) 0x008000000000)
+#define NFP_ME28_INSTR_IS_ALU_SHF(instr) \
+	((instr & NFP_ME28_INSTR_MASK_ALU_SHF) == NFP_ME28_INSTR_ALU_SHF)
+
+#define NFP_ME28_INSTR_MASK_ALU	        ((uint64_t) 0x00e000000000)
+#define NFP_ME28_INSTR_ALU		((uint64_t) 0x00a000000000)
+#define NFP_ME28_INSTR_IS_ALU(instr) \
+	((instr & NFP_ME28_INSTR_MASK_ALU) == NFP_ME28_INSTR_ALU)
+
+#define NFP_ME28_INSTR_MASK_IMMED	((uint64_t) 0x01f900000000)
+#define NFP_ME28_INSTR_IMMED		((uint64_t) 0x00f000000000)
+#define NFP_ME28_INSTR_IS_IMMED(instr) \
+	((instr & NFP_ME28_INSTR_MASK_IMMED) == NFP_ME28_INSTR_IMMED)
+
+#define NFP_ME28_INSTR_MASK_LD_FIELD	((uint64_t) 0x01fa00e00000)
+#define NFP_ME28_INSTR_LD_FIELD	        ((uint64_t) 0x00c000000000)
+#define NFP_ME28_INSTR_IS_LD_FIELD(instr) \
+	((instr & NFP_ME28_INSTR_MASK_LD_FIELD) == NFP_ME28_INSTR_LD_FIELD)
+
+#define NFP_ME28_INSTR_MASK_CTX_ARB	((uint64_t) 0x00f800000000)
+#define NFP_ME28_INSTR_CTX_ARB		((uint64_t) 0x00e000000000)
+#define NFP_ME28_INSTR_IS_CTX_ARB(instr) \
+	((instr & NFP_ME28_INSTR_MASK_CTX_ARB) == NFP_ME28_INSTR_CTX_ARB)
+
+#define NFP_ME28_INSTR_MASK_LOCAL_CSR	((uint64_t) 0x01fe00100000)
+#define NFP_ME28_INSTR_LOCAL_CSR	((uint64_t) 0x00fc00000000)
+#define NFP_ME28_INSTR_IS_LOCAL_CSR(instr) \
+	((instr & NFP_ME28_INSTR_MASK_LOCAL_CSR) == NFP_ME28_INSTR_LOCAL_CSR)
+
+#define NFP_ME28_INSTR_MASK_BRANCH	((uint64_t) 0x00f8000c3ce0)
+#define NFP_ME28_INSTR_BRANCH		((uint64_t) 0x00d800000020)
+#define NFP_ME28_INSTR_IS_BRANCH(instr) \
+	((instr & NFP_ME28_INSTR_MASK_BRANCH) == NFP_ME28_INSTR_BRANCH)
+
+#define NFP_ME28_INSTR_MASK_BR_BYTE	((uint64_t) 0x00f800000000)
+#define NFP_ME28_INSTR_BR_BYTE		((uint64_t) 0x00c800000000)
+#define NFP_ME28_INSTR_IS_BR_BYTE(instr) \
+	((instr & NFP_ME28_INSTR_MASK_BR_BYTE) == NFP_ME28_INSTR_BR_BYTE)
+
+#define NFP_ME28_INSTR_MASK_BR_BIT	((uint64_t) 0x00f800080300)
+#define NFP_ME28_INSTR_BR_BIT		((uint64_t) 0x00d000000000)
+#define NFP_ME28_INSTR_IS_BR_BIT(instr) \
+	((instr & NFP_ME28_INSTR_MASK_BR_BIT) == NFP_ME28_INSTR_BR_BIT)
+
+#define NFP_ME28_INSTR_MASK_BR_ALU	((uint64_t) 0x00ff80000000)
+#define NFP_ME28_INSTR_BR_ALU		((uint64_t) 0x00e800000000)
+#define NFP_ME28_INSTR_IS_BR_ALU(instr) \
+	((instr & NFP_ME28_INSTR_MASK_BR_ALU) == NFP_ME28_INSTR_BR_ALU)
+
+#define NFP_ME28_INSTR_MASK_MULT	((uint64_t) 0x00fe3f000000)
+#define NFP_ME28_INSTR_MULT		((uint64_t) 0x00f800000000)
+#define NFP_ME28_INSTR_IS_MULT(instr) \
+	((instr & NFP_ME28_INSTR_MASK_MULT) == NFP_ME28_INSTR_MULT)
+
+typedef struct
+{
+  int cpp_target;
+  int cpp_action;
+  int cpp_token;
+  unsigned int len_fixed;
+  unsigned int len_mask;
+  const char *mnemonic;
+}
+nfp_cmd_mnemonic;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif				/* _NFP_H_ */
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ binutils-2.30/opcodes/nfp-dis.c	2019-03-07 15:04:02.282705484 +0000
@@ -0,0 +1,2982 @@
+/* Print NFP instructions for objdump.
+   Copyright (C) 2017-2019 Free Software Foundation, Inc.
+   Contributed by Francois H. Theron <francois.theron@netronome.com>
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* There will be many magic numbers here that are based on hardware.
+   Making #define macros for each encoded bit field will probably reduce
+   readability far more than the simple numbers will, so we make sure that
+   the context of the magic numbers make it clear what they are used for.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "disassemble.h"
+#include "libiberty.h"
+#include "elf/nfp.h"
+#include "opcode/nfp.h"
+#include "opintl.h"
+#include "elf-bfd.h"
+#include "bfd.h"
+#include "bfd_stdint.h"
+
+#define _NFP_ERR_STOP -1
+#define _NFP_ERR_CONT -8
+
+#define _BTST(v, b)               (((v) >> b) & 1)
+#define _BF(v, msb, lsb)          (((v) >> (lsb)) & \
+				   ((1U << ((msb) - (lsb) + 1)) - 1))
+#define _BFS(v, msb, lsb, lshift) (_BF(v, msb, lsb) << (lshift))
+
+#define _NFP_ME27_28_CSR_CTX_ENABLES     0x18
+#define _NFP_ME27_28_CSR_MISC_CONTROL    0x160
+
+typedef struct
+{
+  unsigned char ctx4_mode:1;
+  unsigned char addr_3rdparty32:1;
+  unsigned char scs_cnt:2;
+  unsigned char _future:4;
+}
+nfp_priv_mecfg;
+
+typedef struct
+{
+  unsigned char show_pc;
+  unsigned char ctx_mode;
+}
+nfp_opts;
+
+/* mecfgs[island][menum][is-text] */
+typedef struct
+{
+  nfp_priv_mecfg mecfgs[64][12][2];
+}
+nfp_priv_data;
+
+static const char *nfp_mealu_shf_op[8] =
+{
+  /* 0b000 (0) */ "B",
+  /* 0b001 (1) */ "~B",
+  /* 0b010 (2) */ "AND",
+  /* 0b011 (3) */ "~AND",
+  /* 0b100 (4) */ "AND~",
+  /* 0b101 (5) */ "OR",
+  /* 0b110 (6) */ "asr",
+  /* 0b111 (7) */ "byte_align"
+};
+
+static const char *nfp_me27_28_alu_op[32] =
+{
+  /* 0b00000 (0) */ "B",
+  /* 0b00001 (1) */ "+",
+  NULL,
+  /* 0b00011 (3) */ "pop_count3",
+  /* 0b00100 (4) */ "~B",
+  /* 0b00101 (5) */ "+16",
+  /* 0b00110 (6) */ "pop_count1",
+  /* 0b00111 (7) */ "pop_count2",
+  /* 0b01000 (8) */ "AND",
+  /* 0b01001 (9) */ "+8",
+  NULL,
+  /* 0b01011 (11) */ "cam_clear",
+  /* 0b01100 (12) */ "~AND",
+  /* 0b01101 (13) */ "-carry",
+  /* 0b01110 (14) */ "ffs",
+  /* 0b01111 (15) */ "cam_read_tag",
+  /* 0b10000 (16) */ "AND~",
+  /* 0b10001 (17) */ "+carry",
+  /* 0b10010 (18) */ "CRC",
+  /* 0b10011 (19) */ "cam_write",
+  /* 0b10100 (20) */ "OR",
+  /* 0b10101 (21) */ "-",
+  NULL,
+  /* 0b10111 (23) */ "cam_lookup",
+  /* 0b11000 (24) */ "XOR",
+  /* 0b11001 (25) */ "B-A",
+  NULL,
+  /* 0b11011 (27) */ "cam_write_state",
+  NULL,
+  NULL,
+  NULL,
+  /* 0b11111 (31) */ "cam_read_state"
+};
+
+static const char *nfp_me27_28_crc_op[8] =
+{
+  /* 0b000 (0) */ "--",
+  NULL,
+  /* 0b010 (2) */ "crc_ccitt",
+  NULL,
+  /* 0b100 (4) */ "crc_32",
+  /* 0b101 (5) */ "crc_iscsi",
+  /* 0b110 (6) */ "crc_10",
+  /* 0b111 (7) */ "crc_5"
+};
+
+static const char *nfp_me27_28_crc_bytes[8] =
+{
+  /* 0b000 (0) */ "bytes_0_3",
+  /* 0b001 (1) */ "bytes_1_3",
+  /* 0b010 (2) */ "bytes_2_3",
+  /* 0b011 (3) */ "byte_3",
+  /* 0b100 (4) */ "bytes_0_2",
+  /* 0b101 (5) */ "bytes_0_1",
+  /* 0b110 (6) */ "byte_0"
+};
+
+static const char *nfp_me27_28_mecsrs[] =
+{
+  /* 0x000 (0) */ "UstorAddr",
+  /* 0x004 (1) */ "UstorDataLwr",
+  /* 0x008 (2) */ "UstorDataUpr",
+  /* 0x00c (3) */ "UstorErrStat",
+  /* 0x010 (4) */ "ALUOut",
+  /* 0x014 (5) */ "CtxArbCtrl",
+  /* 0x018 (6) */ "CtxEnables",
+  /* 0x01c (7) */ "CondCodeEn",
+  /* 0x020 (8) */ "CSRCtxPtr",
+  /* 0x024 (9) */ "PcBreakpoint0",
+  /* 0x028 (10) */ "PcBreakpoint1",
+  /* 0x02c (11) */ "PcBreakpointStatus",
+  /* 0x030 (12) */ "RegErrStatus",
+  /* 0x034 (13) */ "LMErrStatus",
+  /* 0x038 (14) */ "LMeccErrorMask",
+  NULL,
+  /* 0x040 (16) */ "IndCtxStatus",
+  /* 0x044 (17) */ "ActCtxStatus",
+  /* 0x048 (18) */ "IndCtxSglEvt",
+  /* 0x04c (19) */ "ActCtxSglEvt",
+  /* 0x050 (20) */ "IndCtxWkpEvt",
+  /* 0x054 (21) */ "ActCtxWkpEvt",
+  /* 0x058 (22) */ "IndCtxFtrCnt",
+  /* 0x05c (23) */ "ActCtxFtrCnt",
+  /* 0x060 (24) */ "IndLMAddr0",
+  /* 0x064 (25) */ "ActLMAddr0",
+  /* 0x068 (26) */ "IndLMAddr1",
+  /* 0x06c (27) */ "ActLMAddr1",
+  /* 0x070 (28) */ "ByteIndex",
+  /* 0x074 (29) */ "XferIndex",
+  /* 0x078 (30) */ "IndFtrCntSgl",
+  /* 0x07c (31) */ "ActFtrCntSgl",
+  /* 0x080 (32) */ "NNPut",
+  /* 0x084 (33) */ "NNGet",
+  NULL,
+  NULL,
+  /* 0x090 (36) */ "IndLMAddr2",
+  /* 0x094 (37) */ "ActLMAddr2",
+  /* 0x098 (38) */ "IndLMAddr3",
+  /* 0x09c (39) */ "ActLMAddr3",
+  /* 0x0a0 (40) */ "IndLMAddr2BytIdx",
+  /* 0x0a4 (41) */ "ActLMAddr2BytIdx",
+  /* 0x0a8 (42) */ "IndLMAddr3BytIdx",
+  /* 0x0ac (43) */ "ActLMAddr3BytIdx",
+  /* 0x0b0 (44) */ "IndPredCC",
+  NULL,
+  NULL,
+  NULL,
+  /* 0x0c0 (48) */ "TimestampLow",
+  /* 0x0c4 (49) */ "TimestampHgh",
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  /* 0x0e0 (56) */ "IndLMAddr0BytIdx",
+  /* 0x0e4 (57) */ "ActLMAddr0BytIdx",
+  /* 0x0e8 (58) */ "IndLMAddr1BytIdx",
+  /* 0x0ec (59) */ "ActLMAddr1BytIdx",
+  NULL,
+  /* 0x0f4 (61) */ "XfrAndBytIdx",
+  NULL,
+  NULL,
+  /* 0x100 (64) */ "NxtNghbrSgl",
+  /* 0x104 (65) */ "PrvNghbrSgl",
+  /* 0x108 (66) */ "SameMESignal",
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  /* 0x140 (80) */ "CRCRemainder",
+  /* 0x144 (81) */ "ProfileCnt",
+  /* 0x148 (82) */ "PseudoRndNum",
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  /* 0x160 (88) */ "MiscControl",
+  /* 0x164 (89) */ "PcBreakpoint0Mask",
+  /* 0x168 (90) */ "PcBreakpoint1Mask",
+  NULL,
+  /* 0x170 (92) */ "Mailbox0",
+  /* 0x174 (93) */ "Mailbox1",
+  /* 0x178 (94) */ "Mailbox2",
+  /* 0x17c (95) */ "Mailbox3",
+  NULL,
+  NULL,
+  NULL,
+  NULL,
+  /* 0x190 (100) */ "CmdIndirectRef0"
+};
+
+const char *nfp_me27_28_br_ops[32] =
+{
+  /* 0b00000 (0) */ "beq",
+  /* 0b00001 (1) */ "bne",
+  /* 0b00010 (2) */ "bmi",
+  /* 0b00011 (3) */ "bpl",
+  /* 0b00100 (4) */ "bcs",
+  /* 0b00101 (5) */ "bcc",
+  /* 0b00110 (6) */ "bvs",
+  /* 0b00111 (7) */ "bvc",
+  /* 0b01000 (8) */ "bge",
+  /* 0b01001 (9) */ "blt",
+  /* 0b01010 (10) */ "ble",
+  /* 0b01011 (11) */ "bgt",
+  /* (12) */ NULL,
+  /* (13) */ NULL,
+  /* (14) */ NULL,
+  /* (15) */ NULL,
+  /* 0b10000 (16) */ "br=ctx",
+  /* 0b10001 (17) */ "br!=ctx",
+  /* 0b10010 (18) */ "br_signal",
+  /* 0b10011 (19) */ "br_!signal",
+  /* 0b10100 (20) */ "br_inp_state",
+  /* 0b10101 (21) */ "br_!inp_state",
+  /* 0b10110 (22) */ "br_cls_state",
+  /* 0b10111 (23) */ "br_!cls_state",
+  /* 0b11000 (24) */ "br",
+  /* (25) */ NULL,
+  /* (26) */ NULL,
+  /* (27) */ NULL,
+  /* (28) */ NULL,
+  /* (29) */ NULL,
+  /* (30) */ NULL,
+  /* (31) */ NULL
+};
+
+static const char *nfp_me27_br_inpstates[16] =
+{
+  /* 0 */ "nn_empty",
+  /* 1 */ "nn_full",
+  /* 2 */ "scr_ring0_status",
+  /* 3 */ "scr_ring1_status",
+  /* 4 */ "scr_ring2_status",
+  /* 5 */ "scr_ring3_status",
+  /* 6 */ "scr_ring4_status",
+  /* 7 */ "scr_ring5_status",
+  /* 8 */ "scr_ring6_status",
+  /* 9 */ "scr_ring7_status",
+  /* 10 */ "scr_ring8_status",
+  /* 11 */ "scr_ring9_status",
+  /* 12 */ "scr_ring10_status",
+  /* 13 */ "scr_ring11_status",
+  /* 14 */ "fci_not_empty",
+  /* 15 */ "fci_full"
+};
+
+static const char *nfp_me28_br_inpstates[16] =
+{
+  /* 0 */ "nn_empty",
+  /* 1 */ "nn_full",
+  /* 2 */ "ctm_ring0_status",
+  /* 3 */ "ctm_ring1_status",
+  /* 4 */ "ctm_ring2_status",
+  /* 5 */ "ctm_ring3_status",
+  /* 6 */ "ctm_ring4_status",
+  /* 7 */ "ctm_ring5_status",
+  /* 8 */ "ctm_ring6_status",
+  /* 9 */ "ctm_ring7_status",
+  /* 10 */ "ctm_ring8_status",
+  /* 11 */ "ctm_ring9_status",
+  /* 12 */ "ctm_ring10_status",
+  /* 13 */ "ctm_ring11_status",
+  /* 14 */ "ctm_ring12_status",
+  /* 15 */ "ctm_ring13_status"
+};
+
+static const char *nfp_me27_28_mult_steps[8] =
+{
+  /* 0 */ "step1",
+  /* 1 */ "step2",
+  /* 2 */ "step3",
+  /* 3 */ "step4",
+  /* 4 */ "last",
+  /* 5 */ "last2",
+  NULL,
+  NULL
+};
+
+static const char *nfp_me27_28_mult_types[4] =
+{
+  "start",
+  "24x8",
+  "16x16",
+  "32x32"
+};
+
+/* The cmd_mnemonics arrays are sorted here in its definition so that we can
+   use bsearch () on the first three fields.  There can be multiple matches
+   and we assume that bsearch can return any of them, so we manually step
+   back to the first one.  */
+
+static const nfp_cmd_mnemonic nfp_me27_mnemonics[] =
+{
+  {NFP_3200_CPPTGT_MSF0, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_MSF0, 0, 2, 0, 0, "read64"},
+  {NFP_3200_CPPTGT_MSF0, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_MSF0, 1, 1, 0, 0, "fast_wr"},
+  {NFP_3200_CPPTGT_MSF0, 1, 2, 0, 0, "write64"},
+  {NFP_3200_CPPTGT_QDR, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_QDR, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_QDR, 2, 0, 0, 0, "write_atomic"},
+  {NFP_3200_CPPTGT_QDR, 2, 1, 0, 0, "swap"},
+  {NFP_3200_CPPTGT_QDR, 3, 0, 0, 0, "set"},
+  {NFP_3200_CPPTGT_QDR, 3, 1, 0, 0, "test_and_set"},
+  {NFP_3200_CPPTGT_QDR, 4, 0, 0, 0, "clr"},
+  {NFP_3200_CPPTGT_QDR, 4, 1, 0, 0, "test_and_clr"},
+  {NFP_3200_CPPTGT_QDR, 5, 0, 0, 0, "add"},
+  {NFP_3200_CPPTGT_QDR, 5, 1, 0, 0, "test_and_add"},
+  {NFP_3200_CPPTGT_QDR, 6, 0, 0, 0, "read_queue"},
+  {NFP_3200_CPPTGT_QDR, 6, 1, 0, 0, "read_queue_ring"},
+  {NFP_3200_CPPTGT_QDR, 6, 2, 0, 0, "write_queue"},
+  {NFP_3200_CPPTGT_QDR, 6, 3, 0, 0, "write_queue_ring"},
+  {NFP_3200_CPPTGT_QDR, 7, 0, 0, 0, "incr"},
+  {NFP_3200_CPPTGT_QDR, 7, 1, 0, 0, "test_and_incr"},
+  {NFP_3200_CPPTGT_QDR, 8, 0, 0, 0, "decr"},
+  {NFP_3200_CPPTGT_QDR, 8, 1, 0, 0, "test_and_decr"},
+  {NFP_3200_CPPTGT_QDR, 9, 0, 0, 0, "put"},
+  {NFP_3200_CPPTGT_QDR, 9, 1, 0, 0, "get"},
+  {NFP_3200_CPPTGT_QDR, 9, 2, 0, 0, "put_imm"},
+  {NFP_3200_CPPTGT_QDR, 9, 3, 0, 0, "pop"},
+  {NFP_3200_CPPTGT_QDR, 10, 0, 0, 0, "journal"},
+  {NFP_3200_CPPTGT_QDR, 10, 1, 0, 0, "fast_journal"},
+  {NFP_3200_CPPTGT_QDR, 11, 0, 0, 0, "dequeue"},
+  {NFP_3200_CPPTGT_QDR, 12, 0, 0, 0, "enqueue"},
+  {NFP_3200_CPPTGT_QDR, 12, 1, 0, 0, "enueue_tail"},
+  {NFP_3200_CPPTGT_QDR, 12, 2, 0, 0, "nfp_enqueue"},
+  {NFP_3200_CPPTGT_QDR, 12, 3, 0, 0, "nfp_enueue_tail"},
+  {NFP_3200_CPPTGT_QDR, 13, 0, 0, 0, "csr_wr"},
+  {NFP_3200_CPPTGT_QDR, 13, 1, 0, 0, "csr_rd"},
+  {NFP_3200_CPPTGT_QDR, 14, 0, 0, 0, "wr_qdesc"},
+  {NFP_3200_CPPTGT_QDR, 14, 1, 0, 0, "nfp_wr_qdesc"},
+  {NFP_3200_CPPTGT_QDR, 14, 2, 0, 0, "wr_qdesc_count"},
+  {NFP_3200_CPPTGT_QDR, 14, 3, 0, 0, "push_qdesc"},
+  {NFP_3200_CPPTGT_QDR, 15, 0, 0, 0, "rd_qdesc_other"},
+  {NFP_3200_CPPTGT_QDR, 15, 1, 0, 0, "rd_qdesc_tail"},
+  {NFP_3200_CPPTGT_QDR, 15, 2, 0, 0, "rd_qdesc_head"},
+  {NFP_3200_CPPTGT_QDR, 15, 3, 0, 0, "nfp_rd_qdesc"},
+  {NFP_3200_CPPTGT_MSF1, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_MSF1, 0, 2, 0, 0, "read64"},
+  {NFP_3200_CPPTGT_MSF1, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_MSF1, 1, 1, 0, 0, "fast_wr"},
+  {NFP_3200_CPPTGT_MSF1, 1, 2, 0, 0, "write64"},
+  {NFP_3200_CPPTGT_HASH, 0, 0, 0, 0, "hash_48"},
+  {NFP_3200_CPPTGT_HASH, 0, 1, 0, 0, "hash_64"},
+  {NFP_3200_CPPTGT_HASH, 0, 2, 0, 0, "hash_128"},
+  {NFP_3200_CPPTGT_MU, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_MU, 0, 1, 0, 0, "read_le"},
+  {NFP_3200_CPPTGT_MU, 0, 2, 0, 0, "read_swap"},
+  {NFP_3200_CPPTGT_MU, 0, 3, 0, 0, "read_swap_le"},
+  {NFP_3200_CPPTGT_MU, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_MU, 1, 1, 0, 0, "write_le"},
+  {NFP_3200_CPPTGT_MU, 1, 2, 0, 0, "write_swap"},
+  {NFP_3200_CPPTGT_MU, 1, 3, 0, 0, "write_swap_le"},
+  {NFP_3200_CPPTGT_MU, 2, 0, 0, 0, "write8"},
+  {NFP_3200_CPPTGT_MU, 2, 1, 0, 0, "write8_le"},
+  {NFP_3200_CPPTGT_MU, 2, 2, 0, 0, "write8_swap"},
+  {NFP_3200_CPPTGT_MU, 2, 3, 0, 0, "write8_swap_le"},
+  {NFP_3200_CPPTGT_MU, 3, 0, 0, 0, "read_atomic"},
+  {NFP_3200_CPPTGT_MU, 3, 1, 0, 0, "read8"},
+  {NFP_3200_CPPTGT_MU, 3, 2, 0, 0, "compare_write"},
+  {NFP_3200_CPPTGT_MU, 3, 3, 0, 0, "test_and_compare_write"},
+  {NFP_3200_CPPTGT_MU, 4, 0, 0, 0, "write_atomic"},
+  {NFP_3200_CPPTGT_MU, 4, 1, 0, 0, "swap"},
+  {NFP_3200_CPPTGT_MU, 4, 2, 0, 0, "write_atomic_imm"},
+  {NFP_3200_CPPTGT_MU, 4, 3, 0, 0, "swap_imm"},
+  {NFP_3200_CPPTGT_MU, 5, 0, 0, 0, "set"},
+  {NFP_3200_CPPTGT_MU, 5, 1, 0, 0, "test_and_set"},
+  {NFP_3200_CPPTGT_MU, 5, 2, 0, 0, "set_imm"},
+  {NFP_3200_CPPTGT_MU, 5, 3, 0, 0, "test_and_set_imm"},
+  {NFP_3200_CPPTGT_MU, 6, 0, 0, 0, "clr"},
+  {NFP_3200_CPPTGT_MU, 6, 1, 0, 0, "test_and_clr"},
+  {NFP_3200_CPPTGT_MU, 6, 2, 0, 0, "clr_imm"},
+  {NFP_3200_CPPTGT_MU, 6, 3, 0, 0, "test_and_clr_imm"},
+  {NFP_3200_CPPTGT_MU, 7, 0, 0, 4, "add"},
+  {NFP_3200_CPPTGT_MU, 7, 0, 4, 4, "add64"},
+  {NFP_3200_CPPTGT_MU, 7, 1, 0, 4, "test_and_add"},
+  {NFP_3200_CPPTGT_MU, 7, 1, 4, 4, "test_and_add64"},
+  {NFP_3200_CPPTGT_MU, 7, 2, 0, 4, "add_imm"},
+  {NFP_3200_CPPTGT_MU, 7, 2, 4, 4, "add64_imm"},
+  {NFP_3200_CPPTGT_MU, 7, 3, 0, 4, "test_and_add_imm"},
+  {NFP_3200_CPPTGT_MU, 7, 3, 4, 4, "test_and_add64_imm"},
+  {NFP_3200_CPPTGT_MU, 8, 0, 0, 4, "add_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 0, 4, 4, "add64_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 1, 0, 4, "test_and_add_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 1, 4, 4, "test_and_add64_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 2, 0, 4, "add_imm_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 2, 4, 4, "add_imm_sat"},
+  {NFP_3200_CPPTGT_MU, 8, 3, 0, 0, "test_and_add_sat_imm"},
+  {NFP_3200_CPPTGT_MU, 9, 0, 0, 4, "sub"},
+  {NFP_3200_CPPTGT_MU, 9, 0, 4, 4, "sub64"},
+  {NFP_3200_CPPTGT_MU, 9, 1, 0, 4, "test_and_sub"},
+  {NFP_3200_CPPTGT_MU, 9, 1, 4, 4, "test_and_sub64"},
+  {NFP_3200_CPPTGT_MU, 9, 2, 0, 4, "sub_imm"},
+  {NFP_3200_CPPTGT_MU, 9, 2, 4, 4, "sub64_imm"},
+  {NFP_3200_CPPTGT_MU, 9, 3, 0, 0, "tes_and_sub_imm"},
+  {NFP_3200_CPPTGT_MU, 10, 0, 0, 4, "sub_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 0, 4, 4, "sub64_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 1, 0, 4, "test_and_sub_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 1, 4, 4, "test_and_sub64_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 2, 0, 4, "sub_imm_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 2, 4, 4, "sub64_imm_sat"},
+  {NFP_3200_CPPTGT_MU, 10, 3, 0, 0, "test_and_sub_sat_imm"},
+  {NFP_3200_CPPTGT_MU, 11, 0, 0, 0, "release_ticket"},
+  {NFP_3200_CPPTGT_MU, 11, 1, 0, 0, "release_ticket_ind"},
+  {NFP_3200_CPPTGT_MU, 12, 0, 0, 0, "cam_lookup"},
+  {NFP_3200_CPPTGT_MU, 12, 1, 0, 0, "cam_lookup_add"},
+  {NFP_3200_CPPTGT_MU, 12, 2, 0, 0, "tcam_lookup"},
+  {NFP_3200_CPPTGT_MU, 12, 3, 0, 3, "lock"},
+  {NFP_3200_CPPTGT_MU, 12, 3, 2, 3, "cam_lookup_add_inc"},
+  {NFP_3200_CPPTGT_MU, 13, 0, 0, 4, "microq128_get"},
+  {NFP_3200_CPPTGT_MU, 13, 0, 4, 4, "microq256_get"},
+  {NFP_3200_CPPTGT_MU, 13, 1, 0, 4, "microq128_pop"},
+  {NFP_3200_CPPTGT_MU, 13, 1, 4, 4, "microq256_pop"},
+  {NFP_3200_CPPTGT_MU, 13, 2, 0, 4, "microq128_put"},
+  {NFP_3200_CPPTGT_MU, 13, 2, 4, 4, "microq256_put"},
+  {NFP_3200_CPPTGT_MU, 14, 0, 0, 4, "queue128_lock"},
+  {NFP_3200_CPPTGT_MU, 14, 0, 4, 4, "queue256_lock"},
+  {NFP_3200_CPPTGT_MU, 14, 1, 0, 4, "queue128_unlock"},
+  {NFP_3200_CPPTGT_MU, 14, 1, 4, 4, "queue256_unlock"},
+  {NFP_3200_CPPTGT_MU, 15, 0, 0, 0, "xor"},
+  {NFP_3200_CPPTGT_MU, 15, 1, 0, 0, "test_and_xor"},
+  {NFP_3200_CPPTGT_MU, 15, 2, 0, 0, "xor_imm"},
+  {NFP_3200_CPPTGT_MU, 15, 3, 0, 0, "test_and_xor_imm"},
+  {NFP_3200_CPPTGT_MU, 16, 0, 0, 0, "rd_qdesc"},
+  {NFP_3200_CPPTGT_MU, 16, 1, 0, 0, "wr_qdesc"},
+  {NFP_3200_CPPTGT_MU, 16, 2, 0, 0, "push_qdesc"},
+  {NFP_3200_CPPTGT_MU, 16, 3, 0, 0, "tag_writeback"},
+  {NFP_3200_CPPTGT_MU, 17, 0, 0, 0, "enqueue"},
+  {NFP_3200_CPPTGT_MU, 17, 1, 0, 0, "enqueue_tail"},
+  {NFP_3200_CPPTGT_MU, 17, 2, 0, 0, "dequeue"},
+  {NFP_3200_CPPTGT_MU, 18, 0, 0, 0, "read_queue"},
+  {NFP_3200_CPPTGT_MU, 18, 1, 0, 0, "read_queue_ring"},
+  {NFP_3200_CPPTGT_MU, 18, 2, 0, 0, "write_queue"},
+  {NFP_3200_CPPTGT_MU, 18, 3, 0, 0, "write_queue_ring"},
+  {NFP_3200_CPPTGT_MU, 19, 0, 0, 0, "add_tail"},
+  {NFP_3200_CPPTGT_MU, 19, 1, 0, 0, "qadd_thread"},
+  {NFP_3200_CPPTGT_MU, 19, 2, 0, 0, "qadd_work"},
+  {NFP_3200_CPPTGT_MU, 19, 3, 0, 0, "qadd_work_imm"},
+  {NFP_3200_CPPTGT_MU, 20, 0, 0, 0, "put"},
+  {NFP_3200_CPPTGT_MU, 20, 1, 0, 0, "put_tag"},
+  {NFP_3200_CPPTGT_MU, 20, 2, 0, 0, "journal"},
+  {NFP_3200_CPPTGT_MU, 20, 3, 0, 0, "journal_tag"},
+  {NFP_3200_CPPTGT_MU, 21, 0, 0, 0, "get"},
+  {NFP_3200_CPPTGT_MU, 21, 1, 0, 0, "get_eop"},
+  {NFP_3200_CPPTGT_MU, 21, 2, 0, 0, "get_safe"},
+  {NFP_3200_CPPTGT_MU, 21, 3, 0, 0, "get_tag_safe"},
+  {NFP_3200_CPPTGT_MU, 22, 0, 0, 0, "pop"},
+  {NFP_3200_CPPTGT_MU, 22, 1, 0, 0, "pop_eop"},
+  {NFP_3200_CPPTGT_MU, 22, 2, 0, 0, "pop_safe"},
+  {NFP_3200_CPPTGT_MU, 22, 3, 0, 0, "pop_tag_safe"},
+  {NFP_3200_CPPTGT_MU, 23, 0, 0, 0, "fast_journal"},
+  {NFP_3200_CPPTGT_MU, 23, 1, 0, 0, "fast_journal_sig"},
+  {NFP_3200_CPPTGT_GS, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_GS, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_GS, 2, 0, 0, 0, "write_atomic"},
+  {NFP_3200_CPPTGT_GS, 2, 1, 0, 0, "swap"},
+  {NFP_3200_CPPTGT_GS, 3, 0, 0, 0, "set"},
+  {NFP_3200_CPPTGT_GS, 3, 1, 0, 0, "test_and_set"},
+  {NFP_3200_CPPTGT_GS, 4, 0, 0, 0, "clr"},
+  {NFP_3200_CPPTGT_GS, 4, 1, 0, 0, "test_and_clr"},
+  {NFP_3200_CPPTGT_GS, 5, 0, 0, 0, "add"},
+  {NFP_3200_CPPTGT_GS, 5, 1, 0, 0, "test_and_add"},
+  {NFP_3200_CPPTGT_GS, 6, 0, 0, 0, "sub"},
+  {NFP_3200_CPPTGT_GS, 6, 1, 0, 0, "test_and_sub"},
+  {NFP_3200_CPPTGT_GS, 7, 0, 0, 0, "inc"},
+  {NFP_3200_CPPTGT_GS, 7, 1, 0, 0, "test_and_inc"},
+  {NFP_3200_CPPTGT_GS, 8, 0, 0, 0, "dec"},
+  {NFP_3200_CPPTGT_GS, 8, 1, 0, 0, "test_and_dec"},
+  {NFP_3200_CPPTGT_GS, 9, 0, 0, 0, "get"},
+  {NFP_3200_CPPTGT_GS, 10, 0, 0, 0, "put"},
+  {NFP_3200_CPPTGT_PCIE, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_PCIE, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_PCIE, 2, 0, 0, 0, "read_internal"},
+  {NFP_3200_CPPTGT_PCIE, 3, 0, 0, 0, "write_internal"},
+  {NFP_3200_CPPTGT_ARM, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_ARM, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_CRYPTO, 0, 0, 0, 0, "read"},
+  {NFP_3200_CPPTGT_CRYPTO, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_CRYPTO, 2, 0, 0, 0, "write_fifo"},
+  {NFP_3200_CPPTGT_CAP, 0, 0, 0, 0, "read_enum"},
+  {NFP_3200_CPPTGT_CAP, 0, 1, 0, 0, "read"},
+  {NFP_3200_CPPTGT_CAP, 0, 2, 0, 0, "read_reflect"},
+  {NFP_3200_CPPTGT_CAP, 1, 0, 0, 0, "write_enum"},
+  {NFP_3200_CPPTGT_CAP, 1, 1, 0, 0, "write"},
+  {NFP_3200_CPPTGT_CAP, 1, 2, 0, 0, "write_reflect"},
+  {NFP_3200_CPPTGT_CAP, 2, 0, 0, 0, "fast_wr_alu"},
+  {NFP_3200_CPPTGT_CAP, 3, 0, 0, 0, "fast_wr"},
+  {NFP_3200_CPPTGT_CT, 1, 0, 0, 0, "write"},
+  {NFP_3200_CPPTGT_CLS, 0, 0, 0, 0, "read_be"},
+  {NFP_3200_CPPTGT_CLS, 0, 1, 0, 0, "read_le"},
+  {NFP_3200_CPPTGT_CLS, 0, 2, 0, 0, "test_and_compare_write"},
+  {NFP_3200_CPPTGT_CLS, 0, 3, 0, 0, "xor"},
+  {NFP_3200_CPPTGT_CLS, 1, 0, 0, 0, "write_be"},
+  {NFP_3200_CPPTGT_CLS, 1, 1, 0, 0, "write_le"},
+  {NFP_3200_CPPTGT_CLS, 1, 2, 0, 0, "write8_be"},
+  {NFP_3200_CPPTGT_CLS, 1, 3, 0, 0, "write8_le"},
+  {NFP_3200_CPPTGT_CLS, 2, 0, 0, 0, "set"},
+  {NFP_3200_CPPTGT_CLS, 2, 1, 0, 0, "clr"},
+  {NFP_3200_CPPTGT_CLS, 2, 2, 0, 0, "test_and_set"},
+  {NFP_3200_CPPTGT_CLS, 2, 3, 0, 0, "test_and_clr"},
+  {NFP_3200_CPPTGT_CLS, 3, 0, 0, 0, "set_imm"},
+  {NFP_3200_CPPTGT_CLS, 3, 1, 0, 0, "clr_imm"},
+  {NFP_3200_CPPTGT_CLS, 3, 2, 0, 0, "test_and_set_imm"},
+  {NFP_3200_CPPTGT_CLS, 3, 3, 0, 0, "test_and_clr_imm"},
+  {NFP_3200_CPPTGT_CLS, 4, 0, 0, 0, "add"},
+  {NFP_3200_CPPTGT_CLS, 4, 1, 0, 0, "add64"},
+  {NFP_3200_CPPTGT_CLS, 4, 2, 0, 0, "add_sat"},
+  {NFP_3200_CPPTGT_CLS, 4, 3, 0, 0, "test_and_add_sat"},
+  {NFP_3200_CPPTGT_CLS, 5, 0, 0, 0, "add_imm"},
+  {NFP_3200_CPPTGT_CLS, 5, 1, 0, 0, "add64_imm"},
+  {NFP_3200_CPPTGT_CLS, 5, 2, 0, 0, "add_imm_sat"},
+  {NFP_3200_CPPTGT_CLS, 5, 3, 0, 0, "test_and_add_imm_sat"},
+  {NFP_3200_CPPTGT_CLS, 6, 0, 0, 0, "sub"},
+  {NFP_3200_CPPTGT_CLS, 6, 1, 0, 0, "sub64"},
+  {NFP_3200_CPPTGT_CLS, 6, 2, 0, 0, "sub_sat"},
+  {NFP_3200_CPPTGT_CLS, 6, 3, 0, 0, "test_and_sub_sat"},
+  {NFP_3200_CPPTGT_CLS, 7, 0, 0, 0, "sub_imm"},
+  {NFP_3200_CPPTGT_CLS, 7, 1, 0, 0, "sub64_imm"},
+  {NFP_3200_CPPTGT_CLS, 7, 2, 0, 0, "sub_imm_sat"},
+  {NFP_3200_CPPTGT_CLS, 7, 3, 0, 0, "test_and_sub_imm_sat"},
+  {NFP_3200_CPPTGT_CLS, 8, 0, 0, 0, "queue_lock"},
+  {NFP_3200_CPPTGT_CLS, 8, 1, 0, 0, "queue_unlock"},
+  {NFP_3200_CPPTGT_CLS, 8, 2, 0, 0, "hash_mask"},
+  {NFP_3200_CPPTGT_CLS, 8, 3, 0, 0, "hash_mask_clear"},
+  {NFP_3200_CPPTGT_CLS, 9, 0, 0, 0, "get"},
+  {NFP_3200_CPPTGT_CLS, 9, 1, 0, 0, "pop"},
+  {NFP_3200_CPPTGT_CLS, 9, 2, 0, 0, "get_safe"},
+  {NFP_3200_CPPTGT_CLS, 9, 3, 0, 0, "pop_safe"},
+  {NFP_3200_CPPTGT_CLS, 10, 0, 0, 0, "put"},
+  {NFP_3200_CPPTGT_CLS, 10, 1, 0, 0, "put_offset"},
+  {NFP_3200_CPPTGT_CLS, 10, 2, 0, 0, "journal"},
+  {NFP_3200_CPPTGT_CLS, 10, 3, 0, 0, "add_tail"},
+  {NFP_3200_CPPTGT_CLS, 11, 0, 0, 0, "cam_lookup32"},
+  {NFP_3200_CPPTGT_CLS, 11, 1, 0, 0, "cam_lookup32_add"},
+  {NFP_3200_CPPTGT_CLS, 11, 2, 0, 0, "cam_lookup24"},
+  {NFP_3200_CPPTGT_CLS, 11, 3, 0, 0, "cam_lookup24_add"},
+  {NFP_3200_CPPTGT_CLS, 12, 0, 0, 0, "cam_lookup8"},
+  {NFP_3200_CPPTGT_CLS, 12, 1, 0, 0, "cam_lookup8_add"},
+  {NFP_3200_CPPTGT_CLS, 12, 2, 0, 0, "cam_lookup16"},
+  {NFP_3200_CPPTGT_CLS, 12, 3, 0, 0, "cam_lookup16_add"},
+  {NFP_3200_CPPTGT_CLS, 13, 0, 0, 0, "tcam_lookup32"},
+  {NFP_3200_CPPTGT_CLS, 13, 1, 0, 0, "tcam_lookup24"},
+  {NFP_3200_CPPTGT_CLS, 13, 2, 0, 0, "tcam_lookup16"},
+  {NFP_3200_CPPTGT_CLS, 13, 3, 0, 0, "tcam_lookup8"},
+  {NFP_3200_CPPTGT_CLS, 14, 0, 0, 0, "reflect_from_sig_src"},
+  {NFP_3200_CPPTGT_CLS, 14, 1, 0, 0, "reflect_from_sig_dst"},
+  {NFP_3200_CPPTGT_CLS, 14, 2, 0, 0, "reflect_from_sig_both"},
+  {NFP_3200_CPPTGT_CLS, 15, 0, 0, 0, "reflect_to_sig_src"},
+  {NFP_3200_CPPTGT_CLS, 15, 1, 0, 0, "reflect_to_sig_dst"},
+  {NFP_3200_CPPTGT_CLS, 15, 2, 0, 0, "reflect_to_sig_both"}
+};
+
+static const nfp_cmd_mnemonic nfp_me28_mnemonics[] =
+{
+  {NFP_6000_CPPTGT_NBI, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_NBI, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_NBI, 3, 0, 0, 0, "packet_ready_drop"},
+  {NFP_6000_CPPTGT_NBI, 3, 1, 0, 0, "packet_ready_unicast"},
+  {NFP_6000_CPPTGT_NBI, 3, 2, 0, 0, "packet_ready_multicast_dont_free"},
+  {NFP_6000_CPPTGT_NBI, 3, 3, 0, 0, "packet_ready_multicast_free_on_last"},
+  {NFP_6000_CPPTGT_ILA, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_ILA, 0, 1, 0, 0, "read_check_error"},
+  {NFP_6000_CPPTGT_ILA, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_ILA, 1, 1, 0, 0, "write_check_error"},
+  {NFP_6000_CPPTGT_ILA, 2, 0, 0, 0, "read_int"},
+  {NFP_6000_CPPTGT_ILA, 3, 0, 0, 7, "write_int"},
+  {NFP_6000_CPPTGT_ILA, 3, 0, 3, 7, "write_dma"},
+  {NFP_6000_CPPTGT_MU, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_MU, 0, 1, 0, 0, "read_le"},
+  {NFP_6000_CPPTGT_MU, 0, 2, 0, 0, "read_swap"},
+  {NFP_6000_CPPTGT_MU, 0, 3, 0, 0, "read_swap_le"},
+  {NFP_6000_CPPTGT_MU, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_MU, 1, 1, 0, 0, "write_le"},
+  {NFP_6000_CPPTGT_MU, 1, 2, 0, 0, "write_swap"},
+  {NFP_6000_CPPTGT_MU, 1, 3, 0, 0, "write_swap_le"},
+  {NFP_6000_CPPTGT_MU, 2, 0, 0, 0, "write8"},
+  {NFP_6000_CPPTGT_MU, 2, 1, 0, 0, "write8_le"},
+  {NFP_6000_CPPTGT_MU, 2, 2, 0, 0, "write8_swap"},
+  {NFP_6000_CPPTGT_MU, 2, 3, 0, 0, "write8_swap_le"},
+  {NFP_6000_CPPTGT_MU, 3, 0, 0, 0, "atomic_read"},
+  {NFP_6000_CPPTGT_MU, 3, 1, 0, 0, "read8"},
+  {NFP_6000_CPPTGT_MU, 3, 2, 0, 0,
+   "compare_write_or_incr/mask_compare_write"},
+  {NFP_6000_CPPTGT_MU, 3, 3, 0, 0,
+   "test_compare_write_or_incr/test_mask_compare_write"},
+  {NFP_6000_CPPTGT_MU, 4, 0, 0, 0, "atomic_write"},
+  {NFP_6000_CPPTGT_MU, 4, 1, 0, 0, "swap"},
+  {NFP_6000_CPPTGT_MU, 4, 2, 0, 0, "atomic_write_imm"},
+  {NFP_6000_CPPTGT_MU, 4, 3, 0, 0, "swap_imm"},
+  {NFP_6000_CPPTGT_MU, 5, 0, 0, 0, "set"},
+  {NFP_6000_CPPTGT_MU, 5, 1, 0, 0, "test_set"},
+  {NFP_6000_CPPTGT_MU, 5, 2, 0, 0, "set_imm"},
+  {NFP_6000_CPPTGT_MU, 5, 3, 0, 0, "test_set_imm"},
+  {NFP_6000_CPPTGT_MU, 6, 0, 0, 0, "clr"},
+  {NFP_6000_CPPTGT_MU, 6, 1, 0, 0, "test_clr"},
+  {NFP_6000_CPPTGT_MU, 6, 2, 0, 0, "clr_imm"},
+  {NFP_6000_CPPTGT_MU, 6, 3, 0, 0, "test_clr_imm"},
+  {NFP_6000_CPPTGT_MU, 7, 0, 0, 4, "add"},
+  {NFP_6000_CPPTGT_MU, 7, 0, 4, 4, "add64"},
+  {NFP_6000_CPPTGT_MU, 7, 1, 0, 4, "test_add"},
+  {NFP_6000_CPPTGT_MU, 7, 1, 4, 4, "test_add64"},
+  {NFP_6000_CPPTGT_MU, 7, 2, 0, 4, "add_imm"},
+  {NFP_6000_CPPTGT_MU, 7, 2, 4, 4, "add64_imm"},
+  {NFP_6000_CPPTGT_MU, 7, 3, 0, 4, "test_add_imm"},
+  {NFP_6000_CPPTGT_MU, 7, 3, 4, 4, "test_add64_imm"},
+  {NFP_6000_CPPTGT_MU, 8, 0, 0, 4, "addsat"},
+  {NFP_6000_CPPTGT_MU, 8, 0, 4, 4, "addsat64"},
+  {NFP_6000_CPPTGT_MU, 8, 1, 0, 4, "test_addsat"},
+  {NFP_6000_CPPTGT_MU, 8, 1, 4, 4, "test_addsat64"},
+  {NFP_6000_CPPTGT_MU, 8, 2, 0, 4, "addsat_imm"},
+  {NFP_6000_CPPTGT_MU, 8, 2, 4, 4, "addsat64_imm"},
+  {NFP_6000_CPPTGT_MU, 8, 3, 0, 4, "test_addsat_imm"},
+  {NFP_6000_CPPTGT_MU, 8, 3, 4, 4, "test_addsat64_imm"},
+  {NFP_6000_CPPTGT_MU, 9, 0, 0, 4, "sub"},
+  {NFP_6000_CPPTGT_MU, 9, 0, 4, 4, "sub64"},
+  {NFP_6000_CPPTGT_MU, 9, 1, 0, 4, "test_sub"},
+  {NFP_6000_CPPTGT_MU, 9, 1, 4, 4, "test_sub64"},
+  {NFP_6000_CPPTGT_MU, 9, 2, 0, 4, "sub_imm"},
+  {NFP_6000_CPPTGT_MU, 9, 2, 4, 4, "sub64_imm"},
+  {NFP_6000_CPPTGT_MU, 9, 3, 0, 4, "test_sub_imm"},
+  {NFP_6000_CPPTGT_MU, 9, 3, 4, 4, "test_sub64_imm"},
+  {NFP_6000_CPPTGT_MU, 10, 0, 0, 4, "subsat"},
+  {NFP_6000_CPPTGT_MU, 10, 0, 4, 4, "subsat64"},
+  {NFP_6000_CPPTGT_MU, 10, 1, 0, 4, "test_subsat"},
+  {NFP_6000_CPPTGT_MU, 10, 1, 4, 4, "test_subsat64"},
+  {NFP_6000_CPPTGT_MU, 10, 2, 0, 4, "subsat_imm"},
+  {NFP_6000_CPPTGT_MU, 10, 2, 4, 4, "subsat64_imm"},
+  {NFP_6000_CPPTGT_MU, 10, 3, 0, 4, "test_subsat_imm"},
+  {NFP_6000_CPPTGT_MU, 10, 3, 4, 4, "test_subsat64_imm"},
+  {NFP_6000_CPPTGT_MU, 11, 0, 0, 0, "ticket_release"},
+  {NFP_6000_CPPTGT_MU, 11, 1, 0, 0, "ticket_release_ind"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 0, 7, "cam128_lookup8/cam384_lookup8"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 1, 7, "cam128_lookup16/cam384_lookup16"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 2, 7, "cam128_lookup24/cam384_lookup24"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 3, 7, "cam128_lookup32/cam384_lookup32"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 4, 7, "cam256_lookup8/cam512_lookup8"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 5, 7, "cam256_lookup16/cam512_lookup16"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 6, 7, "cam256_lookup24/cam512_lookup24"},
+  {NFP_6000_CPPTGT_MU, 12, 0, 7, 7, "cam256_lookup32/cam512_lookup32"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 0, 7,
+   "cam128_lookup8_add/cam384_lookup8_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 1, 7,
+   "cam128_lookup16_add/cam384_lookup16_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 2, 7,
+   "cam128_lookup24_add/cam384_lookup24_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 3, 7,
+   "cam128_lookup32_add/cam384_lookup32_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 4, 7,
+   "cam256_lookup8_add/cam512_lookup8_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 5, 7,
+   "cam256_lookup16_add/cam512_lookup16_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 6, 7,
+   "cam256_lookup24_add/cam512_lookup24_add"},
+  {NFP_6000_CPPTGT_MU, 12, 1, 7, 7,
+   "cam256_lookup32_add/cam512_lookup32_add"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 0, 7, "tcam128_lookup8/tcam384_lookup8"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 1, 7, "tcam128_lookup16/tcam384_lookup16"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 2, 7, "tcam128_lookup24/tcam384_lookup24"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 3, 7, "tcam128_lookup32/tcam384_lookup32"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 4, 7, "tcam256_lookup8/tcam512_lookup8"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 5, 7, "tcam256_lookup16/tcam512_lookup16"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 6, 7, "tcam256_lookup24/tcam512_lookup24"},
+  {NFP_6000_CPPTGT_MU, 12, 2, 7, 7, "tcam256_lookup32/tcam512_lookup32"},
+  {NFP_6000_CPPTGT_MU, 12, 3, 0, 7, "lock128/lock384"},
+  {NFP_6000_CPPTGT_MU, 12, 3, 2, 7,
+   "cam128_lookup24_add_inc/cam384_lookup24_add_inc"},
+  {NFP_6000_CPPTGT_MU, 12, 3, 4, 7, "lock256/lock512"},
+  {NFP_6000_CPPTGT_MU, 12, 3, 6, 7,
+   "cam256_lookup24_add_inc/cam512_lookup24_add_inc"},
+  {NFP_6000_CPPTGT_MU, 13, 0, 0, 7, "microq128_get"},
+  {NFP_6000_CPPTGT_MU, 13, 0, 4, 7, "microq256_get"},
+  {NFP_6000_CPPTGT_MU, 13, 1, 0, 7, "microq128_pop"},
+  {NFP_6000_CPPTGT_MU, 13, 1, 4, 7, "microq256_pop"},
+  {NFP_6000_CPPTGT_MU, 13, 2, 0, 7, "microq128_put"},
+  {NFP_6000_CPPTGT_MU, 13, 2, 4, 7, "microq256_put"},
+  {NFP_6000_CPPTGT_MU, 14, 0, 0, 7, "queue128_lock"},
+  {NFP_6000_CPPTGT_MU, 14, 0, 4, 7, "queue256_lock"},
+  {NFP_6000_CPPTGT_MU, 14, 1, 0, 7, "queue128_unlock"},
+  {NFP_6000_CPPTGT_MU, 14, 1, 4, 7, "queue256_unlock"},
+  {NFP_6000_CPPTGT_MU, 15, 0, 0, 0, "xor"},
+  {NFP_6000_CPPTGT_MU, 15, 1, 0, 0, "test_xor"},
+  {NFP_6000_CPPTGT_MU, 15, 2, 0, 0, "xor_imm"},
+  {NFP_6000_CPPTGT_MU, 15, 3, 0, 0, "test_xor_imm"},
+  {NFP_6000_CPPTGT_MU, 16, 0, 0, 0,
+   "ctm.packet_wait_packet_status/emem.rd_qdesc/imem.stats_log"},
+  {NFP_6000_CPPTGT_MU, 16, 1, 0, 0,
+   "ctm.packet_read_packet_status/emem.wr_qdesc/imem.stats_log_sat"},
+  {NFP_6000_CPPTGT_MU, 16, 2, 0, 0,
+   "emem.push_qdesc/imem.stats_log_event"},
+  {NFP_6000_CPPTGT_MU, 16, 3, 0, 0, "imem.stats_log_sat_event"},
+  {NFP_6000_CPPTGT_MU, 17, 0, 0, 0,
+   "ctm.packet_alloc/emem.enqueue/imem.stats_push"},
+  {NFP_6000_CPPTGT_MU, 17, 1, 0, 0,
+   "ctm.packet_credit_get/emem.enqueue_tail/imem.stats_push_clear"},
+  {NFP_6000_CPPTGT_MU, 17, 2, 0, 0, "ctm.packet_alloc_poll/emem.dequeue"},
+  {NFP_6000_CPPTGT_MU, 17, 3, 0, 0, "ctm.packet_add_thread"},
+  {NFP_6000_CPPTGT_MU, 18, 0, 0, 0,
+   "ctm.packet_free/emem.read_queue/imem.lb_write_desc"},
+  {NFP_6000_CPPTGT_MU, 18, 1, 0, 0,
+   "ctm.packet_free_and_signal/emem.read_queue_ring/imem.lb_read_desc"},
+  {NFP_6000_CPPTGT_MU, 18, 2, 0, 0,
+   "ctm.packet_free_and_return_pointer/emem.write_queue"},
+  {NFP_6000_CPPTGT_MU, 18, 3, 0, 0,
+   "ctm.packet_return_pointer/emem.write_queue_ring"},
+  {NFP_6000_CPPTGT_MU, 19, 0, 0, 0,
+   "ctm.packet_complete_drop/emem.add_tail/imem.lb_write_idtable"},
+  {NFP_6000_CPPTGT_MU, 19, 1, 0, 0,
+   "ctm.packet_complete_unicast/emem.qadd_thread/imem.lb_read_idtable"},
+  {NFP_6000_CPPTGT_MU, 19, 2, 0, 0,
+   "ctm.packet_complete_multicast/emem.qadd_work"},
+  {NFP_6000_CPPTGT_MU, 19, 3, 0, 0,
+   "ctm.packet_complete_multicast_free/emem.qadd_work_imm"},
+  {NFP_6000_CPPTGT_MU, 20, 0, 0, 0,
+   "ctm.pe_dma_to_memory_packet/emem.put/imem.lb_bucket_write_local"},
+  {NFP_6000_CPPTGT_MU, 20, 1, 0, 0,
+   "ctm.pe_dma_to_memory_packet_swap/imem.lb_bucket_write_dcache"},
+  {NFP_6000_CPPTGT_MU, 20, 2, 0, 0,
+   "ctm.pe_dma_to_memory_packet_free/emem.journal"},
+  {NFP_6000_CPPTGT_MU, 20, 3, 0, 0,
+   "ctm.pe_dma_to_memory_packet_free_swap"},
+  {NFP_6000_CPPTGT_MU, 21, 0, 0, 0,
+   "ctm.pe_dma_to_memory_indirect/emem.get/imem.lb_bucket_read_local"},
+  {NFP_6000_CPPTGT_MU, 21, 1, 0, 0,
+   "ctm.pe_dma_to_memory_indirect_swap/emem.get_eop/"
+     "imem.lb_bucket_read_dcache"},
+  {NFP_6000_CPPTGT_MU, 21, 2, 0, 0,
+   "ctm.pe_dma_to_memory_indirect_free/emem.get_freely"},
+  {NFP_6000_CPPTGT_MU, 21, 3, 0, 0,
+   "ctm.pe_dma_to_memory_indirect_free_swap"},
+  {NFP_6000_CPPTGT_MU, 22, 0, 0, 0,
+   "ctm.pe_dma_to_memory_buffer/emem.pop/imem.lb_lookup_bundleid"},
+  {NFP_6000_CPPTGT_MU, 22, 1, 0, 0,
+   "ctm.pe_dma_to_memory_buffer_le/emem.pop_eop/imem.lb_lookup_dcache"},
+  {NFP_6000_CPPTGT_MU, 22, 2, 0, 0,
+   "ctm.pe_dma_to_memory_buffer_swap/emem.pop_freely/imem.lb_lookup_idtable"},
+  {NFP_6000_CPPTGT_MU, 22, 3, 0, 0, "ctm.pe_dma_to_memory_buffer_le_swap"},
+  {NFP_6000_CPPTGT_MU, 23, 0, 0, 0,
+   "ctm.pe_dma_from_memory_buffer/emem.fast_journal/imem.lb_push_stats_local"},
+  {NFP_6000_CPPTGT_MU, 23, 1, 0, 0,
+   "ctm.pe_dma_from_memory_buffer_le/emem.fast_journal_sig/"
+     "imem.lb_push_stats_dcache"},
+  {NFP_6000_CPPTGT_MU, 23, 2, 0, 0,
+   "ctm.pe_dma_from_memory_buffer_swap/imem.lb_push_stats_local_clr"},
+  {NFP_6000_CPPTGT_MU, 23, 3, 0, 0,
+   "ctm.pe_dma_from_memory_buffer_le_swap/imem.lb_push_stats_dcache_clr"},
+  {NFP_6000_CPPTGT_MU, 26, 0, 0, 0, "emem.lookup/imem.lookup"},
+  {NFP_6000_CPPTGT_MU, 28, 0, 0, 0, "read32"},
+  {NFP_6000_CPPTGT_MU, 28, 1, 0, 0, "read32_le"},
+  {NFP_6000_CPPTGT_MU, 28, 2, 0, 0, "read32_swap"},
+  {NFP_6000_CPPTGT_MU, 28, 3, 0, 0, "read32_swap_le"},
+  {NFP_6000_CPPTGT_MU, 29, 1, 0, 0, "cam_lookup_add_lock"},
+  {NFP_6000_CPPTGT_MU, 29, 2, 0, 0, "cam_lookup_add_extend"},
+  {NFP_6000_CPPTGT_MU, 29, 3, 0, 0, "cam_lookup_add_inc"},
+  {NFP_6000_CPPTGT_MU, 30, 2, 0, 0, "meter"},
+  {NFP_6000_CPPTGT_MU, 31, 0, 0, 0, "write32"},
+  {NFP_6000_CPPTGT_MU, 31, 1, 0, 0, "write32_le"},
+  {NFP_6000_CPPTGT_MU, 31, 2, 0, 0, "write32_swap"},
+  {NFP_6000_CPPTGT_MU, 31, 3, 0, 0, "write32_swap_le"},
+  {NFP_6000_CPPTGT_PCIE, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_PCIE, 0, 1, 0, 0, "read_rid"},
+  {NFP_6000_CPPTGT_PCIE, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_PCIE, 1, 1, 0, 0, "write_rid"},
+  {NFP_6000_CPPTGT_PCIE, 1, 2, 0, 0, "write_vdm"},
+  {NFP_6000_CPPTGT_PCIE, 2, 0, 0, 0, "read_int"},
+  {NFP_6000_CPPTGT_PCIE, 3, 0, 0, 0, "write_int"},
+  {NFP_6000_CPPTGT_ARM, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_ARM, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_CRYPTO, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_CRYPTO, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_CRYPTO, 2, 0, 0, 0, "write_fifo"},
+  {NFP_6000_CPPTGT_CTXPB, 0, 0, 0, 0, "xpb_read"},
+  {NFP_6000_CPPTGT_CTXPB, 0, 1, 0, 0, "ring_get"},
+  {NFP_6000_CPPTGT_CTXPB, 0, 2, 0, 0, "interthread_signal"},
+  {NFP_6000_CPPTGT_CTXPB, 1, 0, 0, 0, "xpb_write"},
+  {NFP_6000_CPPTGT_CTXPB, 1, 1, 0, 0, "ring_put"},
+  {NFP_6000_CPPTGT_CTXPB, 1, 2, 0, 0, "ctnn_write"},
+  {NFP_6000_CPPTGT_CTXPB, 2, 0, 0, 0, "reflect_read_none"},
+  {NFP_6000_CPPTGT_CTXPB, 2, 1, 0, 0, "reflect_read_sig_init"},
+  {NFP_6000_CPPTGT_CTXPB, 2, 2, 0, 0, "reflect_read_sig_remote"},
+  {NFP_6000_CPPTGT_CTXPB, 2, 3, 0, 0, "reflect_read_sig_both"},
+  {NFP_6000_CPPTGT_CTXPB, 3, 0, 0, 0, "reflect_write_none"},
+  {NFP_6000_CPPTGT_CTXPB, 3, 1, 0, 0, "reflect_write_sig_init"},
+  {NFP_6000_CPPTGT_CTXPB, 3, 2, 0, 0, "reflect_write_sig_remote"},
+  {NFP_6000_CPPTGT_CTXPB, 3, 3, 0, 0, "reflect_write_sig_both"},
+  {NFP_6000_CPPTGT_CLS, 0, 0, 0, 0, "read"},
+  {NFP_6000_CPPTGT_CLS, 0, 1, 0, 0, "read_le"},
+  {NFP_6000_CPPTGT_CLS, 0, 2, 0, 0, "swap/test_compare_write"},
+  {NFP_6000_CPPTGT_CLS, 0, 3, 0, 0, "xor"},
+  {NFP_6000_CPPTGT_CLS, 1, 0, 0, 0, "write"},
+  {NFP_6000_CPPTGT_CLS, 1, 1, 0, 0, "write_le"},
+  {NFP_6000_CPPTGT_CLS, 1, 2, 0, 0, "write8_be"},
+  {NFP_6000_CPPTGT_CLS, 1, 3, 0, 0, "write8_le"},
+  {NFP_6000_CPPTGT_CLS, 2, 0, 0, 0, "set"},
+  {NFP_6000_CPPTGT_CLS, 2, 1, 0, 0, "clr"},
+  {NFP_6000_CPPTGT_CLS, 2, 2, 0, 0, "test_set"},
+  {NFP_6000_CPPTGT_CLS, 2, 3, 0, 0, "test_clr"},
+  {NFP_6000_CPPTGT_CLS, 3, 0, 0, 0, "set_imm"},
+  {NFP_6000_CPPTGT_CLS, 3, 1, 0, 0, "clr_imm"},
+  {NFP_6000_CPPTGT_CLS, 3, 2, 0, 0, "test_set_imm"},
+  {NFP_6000_CPPTGT_CLS, 3, 3, 0, 0, "test_clr_imm"},
+  {NFP_6000_CPPTGT_CLS, 4, 0, 0, 0, "add"},
+  {NFP_6000_CPPTGT_CLS, 4, 1, 0, 0, "add64"},
+  {NFP_6000_CPPTGT_CLS, 4, 2, 0, 0, "addsat"},
+  {NFP_6000_CPPTGT_CLS, 5, 0, 0, 0, "add_imm"},
+  {NFP_6000_CPPTGT_CLS, 5, 1, 0, 0, "add64_imm"},
+  {NFP_6000_CPPTGT_CLS, 5, 2, 0, 0, "addsat_imm"},
+  {NFP_6000_CPPTGT_CLS, 6, 0, 0, 0, "sub"},
+  {NFP_6000_CPPTGT_CLS, 6, 1, 0, 0, "sub64"},
+  {NFP_6000_CPPTGT_CLS, 6, 2, 0, 0, "subsat"},
+  {NFP_6000_CPPTGT_CLS, 7, 0, 0, 0, "sub_imm"},
+  {NFP_6000_CPPTGT_CLS, 7, 1, 0, 0, "sub64_imm"},
+  {NFP_6000_CPPTGT_CLS, 7, 2, 0, 0, "subsat_imm"},
+  {NFP_6000_CPPTGT_CLS, 8, 0, 0, 0, "queue_lock"},
+  {NFP_6000_CPPTGT_CLS, 8, 1, 0, 0, "queue_unlock"},
+  {NFP_6000_CPPTGT_CLS, 8, 2, 0, 0, "hash_mask"},
+  {NFP_6000_CPPTGT_CLS, 8, 3, 0, 0, "hash_mask_clear"},
+  {NFP_6000_CPPTGT_CLS, 9, 0, 0, 0, "get"},
+  {NFP_6000_CPPTGT_CLS, 9, 1, 0, 0, "pop"},
+  {NFP_6000_CPPTGT_CLS, 9, 2, 0, 0, "get_safe"},
+  {NFP_6000_CPPTGT_CLS, 9, 3, 0, 0, "pop_safe"},
+  {NFP_6000_CPPTGT_CLS, 10, 0, 0, 0, "ring_put"},
+  {NFP_6000_CPPTGT_CLS, 10, 2, 0, 0, "ring_journal"},
+  {NFP_6000_CPPTGT_CLS, 11, 0, 0, 0, "cam_lookup32"},
+  {NFP_6000_CPPTGT_CLS, 11, 1, 0, 0, "cam_lookup32_add"},
+  {NFP_6000_CPPTGT_CLS, 11, 2, 0, 0, "cam_lookup24"},
+  {NFP_6000_CPPTGT_CLS, 11, 3, 0, 0, "cam_lookup24_add"},
+  {NFP_6000_CPPTGT_CLS, 12, 0, 0, 0, "cam_lookup8"},
+  {NFP_6000_CPPTGT_CLS, 12, 1, 0, 0, "cam_lookup8_add"},
+  {NFP_6000_CPPTGT_CLS, 12, 2, 0, 0, "cam_lookup16"},
+  {NFP_6000_CPPTGT_CLS, 12, 3, 0, 0, "cam_lookup16_add"},
+  {NFP_6000_CPPTGT_CLS, 13, 0, 0, 0, "tcam_lookup32"},
+  {NFP_6000_CPPTGT_CLS, 13, 1, 0, 0, "tcam_lookup24"},
+  {NFP_6000_CPPTGT_CLS, 13, 2, 0, 0, "tcam_lookup16"},
+  {NFP_6000_CPPTGT_CLS, 13, 3, 0, 0, "tcam_lookup8"},
+  {NFP_6000_CPPTGT_CLS, 14, 0, 0, 0, "reflect_write_sig_local"},
+  {NFP_6000_CPPTGT_CLS, 14, 1, 0, 0, "reflect_write_sig_remote"},
+  {NFP_6000_CPPTGT_CLS, 14, 2, 0, 0, "reflect_write_sig_both"},
+  {NFP_6000_CPPTGT_CLS, 15, 0, 0, 0, "reflect_read_sig_remote"},
+  {NFP_6000_CPPTGT_CLS, 15, 1, 0, 0, "reflect_read_sig_local"},
+  {NFP_6000_CPPTGT_CLS, 15, 2, 0, 0, "reflect_read_sig_both"},
+  {NFP_6000_CPPTGT_CLS, 16, 1, 0, 0, "cam_lookup32_add_lock"},
+  {NFP_6000_CPPTGT_CLS, 16, 2, 0, 0, "cam_lookup24_add_inc"},
+  {NFP_6000_CPPTGT_CLS, 16, 3, 0, 0, "cam_lookup32_add_extend"},
+  {NFP_6000_CPPTGT_CLS, 17, 0, 0, 0, "meter"},
+  {NFP_6000_CPPTGT_CLS, 17, 2, 0, 0, "statistic"},
+  {NFP_6000_CPPTGT_CLS, 17, 3, 0, 0, "statistic_imm"},
+  {NFP_6000_CPPTGT_CLS, 20, 0, 0, 0, "test_add"},
+  {NFP_6000_CPPTGT_CLS, 20, 1, 0, 0, "test_add64"},
+  {NFP_6000_CPPTGT_CLS, 20, 2, 0, 0, "test_addsat"},
+  {NFP_6000_CPPTGT_CLS, 21, 0, 0, 0, "test_add_imm"},
+  {NFP_6000_CPPTGT_CLS, 21, 1, 0, 0, "test_add64_imm"},
+  {NFP_6000_CPPTGT_CLS, 21, 2, 0, 0, "test_addsat_imm"},
+  {NFP_6000_CPPTGT_CLS, 22, 0, 0, 0, "test_sub"},
+  {NFP_6000_CPPTGT_CLS, 22, 1, 0, 0, "test_sub64"},
+  {NFP_6000_CPPTGT_CLS, 22, 2, 0, 0, "test_subsat"},
+  {NFP_6000_CPPTGT_CLS, 23, 0, 0, 0, "test_sub_imm"},
+  {NFP_6000_CPPTGT_CLS, 23, 1, 0, 0, "test_sub64_imm"},
+  {NFP_6000_CPPTGT_CLS, 23, 2, 0, 0, "test_subsat_imm"},
+  {NFP_6000_CPPTGT_CLS, 24, 0, 0, 0, "ring_read"},
+  {NFP_6000_CPPTGT_CLS, 24, 1, 0, 0, "ring_write"},
+  {NFP_6000_CPPTGT_CLS, 24, 2, 0, 0, "ring_ordered_lock"},
+  {NFP_6000_CPPTGT_CLS, 24, 3, 0, 0, "ring_ordered_unlock"},
+  {NFP_6000_CPPTGT_CLS, 25, 0, 0, 0, "ring_workq_add_thread"},
+  {NFP_6000_CPPTGT_CLS, 25, 1, 0, 0, "ring_workq_add_work"}
+};
+
+static int
+nfp_me_print_invalid (uint64_t instr, struct disassemble_info *dinfo)
+{
+  const char * err_msg = N_("<invalid_instruction>:");
+  dinfo->fprintf_func (dinfo->stream, "%s 0x%llx", err_msg, (long long) instr);
+  return _NFP_ERR_CONT;
+}
+
+static bfd_boolean
+nfp_me_is_imm_opnd10 (unsigned int opnd)
+{
+  return _BF (opnd, 9, 8) == 0x3;
+}
+
+static bfd_boolean
+nfp_me_is_imm_opnd8 (unsigned int opnd)
+{
+  return _BTST (opnd, 5);
+}
+
+static unsigned int
+nfp_me_imm_opnd10 (unsigned int opnd)
+{
+  return nfp_me_is_imm_opnd10 (opnd) ? (opnd & 0xff) : ~0U;
+}
+
+static unsigned int
+nfp_me_imm_opnd8 (unsigned int opnd, unsigned int imm8_msb)
+{
+  unsigned int v = (imm8_msb << 7) | _BFS (opnd, 7, 6, 5) | _BF (opnd, 4, 0);
+
+  return nfp_me_is_imm_opnd8 (opnd) ? v : ~0U;
+}
+
+/* Print an unrestricted/10-bit operand.
+   This can mostly be generic across NFP families at the moment.  */
+static bfd_boolean
+nfp_me_print_opnd10 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,
+		     struct disassemble_info *dinfo)
+{
+  unsigned int n = _BF (opnd, (num_ctx == 8) ? 3 : 4, 0);
+
+  /* Absolute GPR.  */
+  if (_BF (opnd, 9, 7) == 0x1)
+    dinfo->fprintf_func (dinfo->stream, "@gpr%c_%d", bank, _BF (opnd, 6, 0));
+
+  /* Relative GPR.  */
+  else if (_BF (opnd, 9, 6) == 0x0)
+    dinfo->fprintf_func (dinfo->stream, "gpr%c_%d", bank, n);
+
+  /* Indexed Xfer.  */
+  else if (_BF (opnd, 9, 7) == 0x2)
+    {
+      dinfo->fprintf_func (dinfo->stream, "*$index");
+      if (_BF (opnd, 2, 1) == 0x1)
+	dinfo->fprintf_func (dinfo->stream, "++");
+      else if (_BF (opnd, 2, 1) == 0x2)
+	dinfo->fprintf_func (dinfo->stream, "--");
+    }
+
+  /* Relative Xfer.  */
+  else if (_BF (opnd, 9, 7) == 0x3)
+    {
+      if (_BTST (opnd, 6))
+	n += (num_ctx == 8 ? 16 : 32);
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d", n);
+    }
+
+  /* Indexed Next Neighbour.  */
+  else if (_BF (opnd, 9, 6) == 0x9)
+    {
+      dinfo->fprintf_func (dinfo->stream, "*n$index");
+      if (_BTST (opnd, 1))
+	dinfo->fprintf_func (dinfo->stream, "++");
+    }
+
+  /* Relative Next Neighbour.  */
+  else if (_BF (opnd, 9, 6) == 0xa)
+    {
+      dinfo->fprintf_func (dinfo->stream, "n$reg_%d", n);
+    }
+
+  /* Indexed LMEM.  */
+  else if (_BF (opnd, 9, 6) == 0x8)
+    {
+      n = _BF (opnd, 5, 5) + (lmem_ext * 2);
+      dinfo->fprintf_func (dinfo->stream, "*l$index%d", n);
+      if (_BTST (opnd, 4))
+	dinfo->fprintf_func (dinfo->stream, _BTST (opnd, 0) ? "--" : "++");
+      else if (_BF (opnd, 3, 0))
+	dinfo->fprintf_func (dinfo->stream, "[%d]", _BF (opnd, 3, 0));
+    }
+
+  /* 8-bit Constant value.  */
+  else if (_BF (opnd, 9, 8) == 0x3)
+    dinfo->fprintf_func (dinfo->stream, "0x%x", _BF (opnd, 7, 0));
+
+  else
+    {
+      dinfo->fprintf_func (dinfo->stream, "<opnd:0x%x>", opnd);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Print a restricted/8-bit operand.
+   This can mostly be generic across NFP families at the moment.  */
+
+static bfd_boolean
+nfp_me_print_opnd8 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,
+		    unsigned int imm8_msb, struct disassemble_info *dinfo)
+{
+  unsigned int n = _BF (opnd, (num_ctx == 8) ? 3 : 4, 0);
+
+  /* Relative GPR.  */
+  if (_BF (opnd, 7, 5) == 0x0)
+    dinfo->fprintf_func (dinfo->stream, "gpr%c_%d", bank, n);
+
+  /* Relative Xfer.  */
+  else if (_BF (opnd, 7, 5) == 0x4)
+    dinfo->fprintf_func (dinfo->stream, "$xfer_%d", n);
+
+  /* Relative Xfer.  */
+  else if (_BF (opnd, 7, 5) == 0x6)
+    {
+      n += (num_ctx == 8 ? 16 : 32);
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d", n);
+    }
+
+  /* Indexed Xfer.  */
+  else if ((_BF (opnd, 7, 4) == 0x4) && (!_BTST (opnd, 0)))
+    {
+      dinfo->fprintf_func (dinfo->stream, "*$index");
+      if (_BF (opnd, 2, 1) == 0x1)
+	dinfo->fprintf_func (dinfo->stream, "++");
+      else if (_BF (opnd, 2, 1) == 0x2)
+	dinfo->fprintf_func (dinfo->stream, "--");
+    }
+
+  /* Indexed NN.  */
+  else if ((_BF (opnd, 7, 4) == 0x4) && (_BTST (opnd, 0)))
+    {
+      dinfo->fprintf_func (dinfo->stream, "*n$index");
+      if (_BTST (opnd, 1))
+	dinfo->fprintf_func (dinfo->stream, "++");
+    }
+
+  /* Indexed LMEM.  */
+  else if (_BF (opnd, 7, 4) == 0x5)
+    {
+      n = _BF (opnd, 3, 3) + (lmem_ext * 2);
+      dinfo->fprintf_func (dinfo->stream, "*l$index%d", n);
+      if (_BF (opnd, 2, 0))
+	dinfo->fprintf_func (dinfo->stream, "[%d]", _BF (opnd, 2, 0));
+    }
+
+  /* 7+1-bit Constant value.  */
+  else if (_BTST (opnd, 5))
+    {
+      n = (imm8_msb << 7) | _BFS (opnd, 7, 6, 5) | _BF (opnd, 4, 0);
+      dinfo->fprintf_func (dinfo->stream, "0x%x", n);
+    }
+
+  else
+    {
+      dinfo->fprintf_func (dinfo->stream, "<opnd:0x%x>", opnd);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static int
+nfp_me27_28_print_alu_shf (uint64_t instr, unsigned int pred_cc,
+			   unsigned int dst_lmext, unsigned int src_lmext,
+			   unsigned int gpr_wrboth,
+			   int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int op = _BF (instr, 35, 33);
+  unsigned int srcA = _BF (instr, 7, 0);
+  unsigned int srcB = _BF (instr, 17, 10);
+  unsigned int dst = _BF (instr, 27, 20);
+  unsigned int sc = _BF (instr, 9, 8);
+  unsigned int imm_msb = _BTST (instr, 18);
+  unsigned int swap = _BTST (instr, 19);
+  unsigned int shift = _BF (instr, 32, 28);
+  char dst_bank = 'A' + _BTST (instr, 36);
+  unsigned int nocc = _BTST (instr, 40);
+  bfd_boolean err = FALSE;
+
+  if (swap)
+    {
+      unsigned int tmp = srcA;
+      srcA = srcB;
+      srcB = tmp;
+    }
+
+  /* alu_shf, dbl_shf, asr.  */
+  if (op < 7)
+    {
+      if (sc == 3)
+	dinfo->fprintf_func (dinfo->stream, "dbl_shf[");
+      else if (op == 6)
+	dinfo->fprintf_func (dinfo->stream, "asr[");
+      else
+	dinfo->fprintf_func (dinfo->stream, "alu_shf[");
+
+      /* dest operand */
+      if (nfp_me_is_imm_opnd8 (dst))
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd8 (dst, dst_bank, num_ctx,
+					  dst_lmext, imm_msb, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      /* A operand.  */
+      if (op != 6)
+	{
+	  if ((op < 2) && (sc != 3))	/* Not dbl_shf.  */
+	    dinfo->fprintf_func (dinfo->stream, "--");	/* B or ~B operator.  */
+	  else
+	    err = err || !nfp_me_print_opnd8 (srcA, (swap) ? 'B' : 'A',
+					      num_ctx, src_lmext, imm_msb,
+					      dinfo);
+
+	  dinfo->fprintf_func (dinfo->stream, ", ");
+
+	  /* Operator (not for dbl_shf).  */
+	  if (sc != 3)
+	    {
+	      dinfo->fprintf_func (dinfo->stream, "%s, ",
+				   nfp_mealu_shf_op[op]);
+	    }
+	}
+
+      /* B operand.  */
+      err = err || !nfp_me_print_opnd8 (srcB, (swap) ? 'A' : 'B',
+					num_ctx, src_lmext, imm_msb, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      /* Shift */
+      if (sc == 0)
+	dinfo->fprintf_func (dinfo->stream, ">>rot%d", shift);
+      else if (sc == 2)
+	{
+	  if (shift)
+	    dinfo->fprintf_func (dinfo->stream, "<<%d", (32 - shift));
+	  else
+	    dinfo->fprintf_func (dinfo->stream, "<<indirect");
+	}
+      else
+	{
+	  if (shift)
+	    dinfo->fprintf_func (dinfo->stream, ">>%d", shift);
+	  else
+	    dinfo->fprintf_func (dinfo->stream, ">>indirect");
+	}
+    }
+  /* Byte Align.  */
+  else if (op == 7)
+    {
+      dinfo->fprintf_func (dinfo->stream, "byte_align_%s[",
+			   ((sc == 2) ? "le" : "be"));
+
+      /* Dest operand.  */
+      if (nfp_me_is_imm_opnd8 (dst))
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd8 (dst, dst_bank, num_ctx,
+					  dst_lmext, imm_msb, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      if (sc == 2)
+	err = err || !nfp_me_print_opnd8 (srcA, (swap) ? 'B' : 'A', num_ctx,
+					  0, imm_msb, dinfo);
+      else
+	err = err || !nfp_me_print_opnd8 (srcB, (swap) ? 'A' : 'B', num_ctx,
+					  0, imm_msb, dinfo);
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+  if (nocc)
+    dinfo->fprintf_func (dinfo->stream, ", no_cc");
+  if (gpr_wrboth)
+    dinfo->fprintf_func (dinfo->stream, ", gpr_wrboth");
+  if (pred_cc)
+    dinfo->fprintf_func (dinfo->stream, ", predicate_cc");
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_alu (uint64_t instr, unsigned int pred_cc,
+		       unsigned int dst_lmext, unsigned int src_lmext,
+		       unsigned int gpr_wrboth,
+		       int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int op = _BF (instr, 35, 31);
+  unsigned int srcA = _BF (instr, 9, 0);
+  unsigned int srcB = _BF (instr, 19, 10);
+  unsigned int dst = _BF (instr, 29, 20);
+  unsigned int swap = _BTST (instr, 30);
+  char dst_bank = 'A' + _BTST (instr, 36);
+  unsigned int nocc = _BTST (instr, 40);
+  int do_close_bracket = 1;
+  bfd_boolean err = FALSE;
+
+  if (swap)
+    {
+      unsigned int tmp = srcA;
+      srcA = srcB;
+      srcB = tmp;
+    }
+
+  switch (op)
+    {
+    case 3:			/* pop_count3[dst, srcB] */
+    case 6:			/* pop_count1[srcB] */
+    case 7:			/* pop_count2[srcB] */
+    case 14:			/* ffs[dst, srcB] */
+    case 15:			/* cam_read_tag[dst, srcB] */
+    case 31:			/* cam_read_state[dst, srcB] */
+      dinfo->fprintf_func (dinfo->stream, "%s[", nfp_me27_28_alu_op[op]);
+
+      /* No dest for pop_count1/2.  */
+      if ((op != 6) && (op != 7))
+	{
+	  /* dest operand */
+	  if (nfp_me_is_imm_opnd10 (dst))
+	    dinfo->fprintf_func (dinfo->stream, "--");
+	  else
+	    err = err || !nfp_me_print_opnd10 (dst, dst_bank, num_ctx,
+					       dst_lmext, dinfo);
+
+	  dinfo->fprintf_func (dinfo->stream, ", ");
+	}
+
+      /* B operand.  */
+      err = err || !nfp_me_print_opnd10 (srcB, (swap) ? 'A' : 'B',
+					 num_ctx, src_lmext, dinfo);
+      break;
+ 
+      /* cam_clear.  */
+    case 11:
+      do_close_bracket = 0;
+      dinfo->fprintf_func (dinfo->stream, "cam_clear");
+      break;
+
+      /* cam_lookup.  */
+    case 23:
+      do_close_bracket = 0;
+      dinfo->fprintf_func (dinfo->stream, "%s[", nfp_me27_28_alu_op[op]);
+
+      /* Dest operand.  */
+      if (nfp_me_is_imm_opnd10 (dst))
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd10 (dst, dst_bank, num_ctx,
+					   dst_lmext, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      /* A operand.  */
+      err = err || !nfp_me_print_opnd10 (srcA, (swap) ? 'B' : 'A',
+					 num_ctx, src_lmext, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, "]");
+
+      if (_BF (srcB, 1, 0))
+	{
+	  unsigned int n = _BTST (srcB, 1);
+	  if (_BTST (srcB, 4))	/* Only for MEv28.  */
+	    n += 2;
+	  dinfo->fprintf_func (dinfo->stream, ", lm_addr%d[%d]", n,
+			       _BF (srcB, 3, 2));
+	}
+
+      break;
+
+    case 19:      /* cam_write.  */
+    case 27:      /* cam_write_state.  */
+      dinfo->fprintf_func (dinfo->stream, "%s[", nfp_me27_28_alu_op[op]);
+      err = err || !nfp_me_print_opnd10 (srcB, (swap) ? 'A' : 'B',
+					 num_ctx, src_lmext, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", ");
+      if (op == 19)
+	{
+	  err = err || !nfp_me_print_opnd10 (srcA, (swap) ? 'B' : 'A',
+					     num_ctx, src_lmext, dinfo);
+	  dinfo->fprintf_func (dinfo->stream, ", ");
+	}
+      dinfo->fprintf_func (dinfo->stream, "%d", (dst & 0xf));
+      break;
+
+      /* CRC.  */
+    case 18:	
+      do_close_bracket = 0;
+      dinfo->fprintf_func (dinfo->stream, "crc_%s[",
+			   _BTST (srcA, 3) ? "le" : "be");
+      if (!nfp_me27_28_crc_op[_BF (srcA, 7, 5)])
+	{
+	  dinfo->fprintf_func (dinfo->stream, _(", <invalid CRC operator>, "));
+	  err = TRUE;
+	}
+      else
+	{
+	  dinfo->fprintf_func (dinfo->stream, "%s, ",
+			       nfp_me27_28_crc_op[_BF (srcA, 7, 5)]);
+	}
+
+      /* Dest operand.  */
+      if (nfp_me_is_imm_opnd10 (dst))
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd10 (dst, dst_bank, num_ctx,
+					   dst_lmext, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      /* B operand.  */
+      err = err || !nfp_me_print_opnd10 (srcB, (swap) ? 'A' : 'B',
+					 num_ctx, src_lmext, dinfo);
+
+      dinfo->fprintf_func (dinfo->stream, "]");
+      if (_BF (srcA, 2, 0))
+	dinfo->fprintf_func (dinfo->stream, ", %s",
+			     nfp_me27_28_crc_bytes[_BF (srcA, 2, 0)]);
+      if (_BTST (srcA, 4))
+	dinfo->fprintf_func (dinfo->stream, ", bit_swap");
+      break;
+
+    default:
+      /* s += 'alu[%s, %s, %s, %s]' % (dst, srcAs, op, srcBs).  */
+      dinfo->fprintf_func (dinfo->stream, "alu[");
+
+      /* Dest operand.  */
+      if (nfp_me_is_imm_opnd10 (dst))
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd10 (dst, dst_bank, num_ctx,
+					   dst_lmext, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", ");
+
+      /* A operand.  */
+      if ((op == 0) || (op == 4))	/* B only operators.  */
+	dinfo->fprintf_func (dinfo->stream, "--");
+      else
+	err = err || !nfp_me_print_opnd10 (srcA, (swap) ? 'B' : 'A',
+					   num_ctx, src_lmext, dinfo);
+
+      if (!nfp_me27_28_alu_op[op])
+	{
+	  dinfo->fprintf_func (dinfo->stream, ", <operator:0x%x>, ", op);
+	  err = TRUE;
+	}
+      else
+	{
+	  dinfo->fprintf_func (dinfo->stream, ", %s, ",
+			       nfp_me27_28_alu_op[op]);
+	}
+
+      /* B operand.  */
+      err = err || !nfp_me_print_opnd10 (srcB, (swap) ? 'A' : 'B',
+					 num_ctx, src_lmext, dinfo);
+      break;
+    }
+
+  if (do_close_bracket)
+    dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (nocc)
+    dinfo->fprintf_func (dinfo->stream, ", no_cc");
+  if (gpr_wrboth)
+    dinfo->fprintf_func (dinfo->stream, ", gpr_wrboth");
+  if (pred_cc)
+    dinfo->fprintf_func (dinfo->stream, ", predicate_cc");
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_immed (uint64_t instr, unsigned int pred_cc,
+			 unsigned int dst_lmext,
+			 unsigned int gpr_wrboth,
+			 int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 9, 0);
+  unsigned int srcB = _BF (instr, 19, 10);
+  unsigned int imm = _BF (instr, 27, 20);
+  unsigned int by = _BTST (instr, 29);
+  unsigned int wd = _BTST (instr, 30);
+  unsigned int inv = _BTST (instr, 31);
+  unsigned int byte_shift = _BF (instr, 34, 33);
+  bfd_boolean err = FALSE;
+
+  if (nfp_me_is_imm_opnd10 (srcB))
+    {
+      imm = (imm << 8) | nfp_me_imm_opnd10 (srcB);
+      if (nfp_me_is_imm_opnd10 (srcA) && (imm == 0))
+	{
+	  dinfo->fprintf_func (dinfo->stream, "nop");
+	  return 0;
+	}
+    }
+  else
+    {
+      imm = (imm << 8) | nfp_me_imm_opnd10 (srcA);
+    }
+
+  if (inv)
+    imm = (imm ^ 0xffff) | 0xffff0000U;
+
+  if (by)
+    {
+      dinfo->fprintf_func (dinfo->stream, "immed_b%d[", byte_shift);
+      imm &= 0xff;
+    }
+  else if (wd)
+    {
+      dinfo->fprintf_func (dinfo->stream, "immed_w%d[", (byte_shift / 2));
+      imm &= 0xffff;
+    }
+  else
+    dinfo->fprintf_func (dinfo->stream, "immed[");
+
+  /* Dest.  */
+  if (nfp_me_is_imm_opnd10 (srcA) && nfp_me_is_imm_opnd10 (srcB))
+    dinfo->fprintf_func (dinfo->stream, "--");	/* No Dest.  */
+  else if (nfp_me_is_imm_opnd10 (srcA))
+    err = err || !nfp_me_print_opnd10 (srcB, 'B', num_ctx, dst_lmext, dinfo);
+  else
+    err = err || !nfp_me_print_opnd10 (srcA, 'A', num_ctx, dst_lmext, dinfo);
+
+  dinfo->fprintf_func (dinfo->stream, ", 0x%x", imm);
+
+  if ((!by) && (!wd) && (byte_shift))
+    dinfo->fprintf_func (dinfo->stream, ", <<%d", (byte_shift * 8));
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (gpr_wrboth)
+    dinfo->fprintf_func (dinfo->stream, ", gpr_wrboth");
+  if (pred_cc)
+    dinfo->fprintf_func (dinfo->stream, ", predicate_cc");
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_ld_field (uint64_t instr, unsigned int pred_cc,
+			    unsigned int dst_lmext, unsigned int src_lmext,
+			    unsigned int gpr_wrboth,
+			    int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int load_cc = _BTST (instr, 34);
+  unsigned int shift = _BF (instr, 32, 28);
+  unsigned int byte_mask = _BF (instr, 27, 24);
+  unsigned int zerof = _BTST (instr, 20);
+  unsigned int swap = _BTST (instr, 19);
+  unsigned int imm_msb = _BTST (instr, 18);
+  unsigned int src = _BF (instr, 17, 10);
+  unsigned int sc = _BF (instr, 9, 8);
+  unsigned int dst = _BF (instr, 7, 0);
+  bfd_boolean err = FALSE;
+
+  if (swap)
+    {
+      unsigned int tmp = src;
+      src = dst;
+      dst = tmp;
+    }
+
+  if (zerof)
+    dinfo->fprintf_func (dinfo->stream, "ld_field_w_clr[");
+  else
+    dinfo->fprintf_func (dinfo->stream, "ld_field[");
+
+  err = err || !nfp_me_print_opnd8 (dst, (swap) ? 'B' : 'A', num_ctx,
+				    dst_lmext, imm_msb, dinfo);
+  dinfo->fprintf_func (dinfo->stream, ", %d%d%d%d, ",
+		       _BTST (byte_mask, 3),
+		       _BTST (byte_mask, 2),
+		       _BTST (byte_mask, 1), _BTST (byte_mask, 0));
+  err = err || !nfp_me_print_opnd8 (src, (swap) ? 'A' : 'B', num_ctx,
+				    src_lmext, imm_msb, dinfo);
+
+  if ((sc == 0) && (shift != 0))
+    dinfo->fprintf_func (dinfo->stream, ", >>rot%d", shift);
+  else if (sc == 1)
+    {
+      if (shift)
+	dinfo->fprintf_func (dinfo->stream, ", >>%d", shift);
+      else
+	dinfo->fprintf_func (dinfo->stream, ", >>indirect");
+    }
+  else if (sc == 2)
+    {
+      if (shift)
+	dinfo->fprintf_func (dinfo->stream, ", <<%d", (32 - shift));
+      else
+	dinfo->fprintf_func (dinfo->stream, ", <<indirect");
+    }
+  else if (sc == 3)
+    dinfo->fprintf_func (dinfo->stream, ", >>dbl%d", shift);
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (load_cc)
+    dinfo->fprintf_func (dinfo->stream, ", load_cc");
+  if (gpr_wrboth)
+    dinfo->fprintf_func (dinfo->stream, ", gpr_wrboth");
+  if (pred_cc)
+    dinfo->fprintf_func (dinfo->stream, ", predicate_cc");
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_ctx_arb (uint64_t instr, struct disassemble_info *dinfo)
+{
+  unsigned int resume_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);
+  unsigned int defer = _BF (instr, 21, 20);
+  unsigned int no_load = _BTST (instr, 19);
+  unsigned int resume = _BTST (instr, 18);
+  unsigned int bpt = _BTST (instr, 17);
+  unsigned int sig_or = _BTST (instr, 16);
+  unsigned int ev_mask = _BF (instr, 15, 0);
+
+  dinfo->fprintf_func (dinfo->stream, "ctx_arb[");
+  if (bpt)
+    dinfo->fprintf_func (dinfo->stream, "bpt");
+  else if (ev_mask == 1)
+    dinfo->fprintf_func (dinfo->stream, "voluntary");
+  else if ((!no_load) && (ev_mask == 0))
+    {
+      dinfo->fprintf_func (dinfo->stream, "kill");
+      sig_or = 0;
+    }
+  else if (ev_mask == 0)
+    dinfo->fprintf_func (dinfo->stream, "--");
+  else
+    {
+      int first_print = 1;
+      unsigned int n;
+
+      for (n = 1; n < 16; n++)
+	{
+	  if (!_BTST (ev_mask, n))
+	    continue;
+	  dinfo->fprintf_func (dinfo->stream, "%ssig%d",
+			       (first_print) ? "" : ", ", n);
+	  first_print = 0;
+	}
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (sig_or)
+    dinfo->fprintf_func (dinfo->stream, ", any");
+  if (resume)
+    dinfo->fprintf_func (dinfo->stream, ", br[.%d]", resume_addr);
+  if (defer)
+    dinfo->fprintf_func (dinfo->stream, ", defer[%d]", defer);
+
+  return 0;
+}
+
+static int
+nfp_me27_28_print_local_csr (uint64_t instr,
+			     unsigned int src_lmext,
+			     int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 9, 0);
+  unsigned int srcB = _BF (instr, 19, 10);
+  unsigned int wr = _BTST (instr, 21);
+  unsigned int csr_num = _BF (instr, 32, 22);
+  unsigned int src = srcA;
+  char src_bank = 'A';
+  bfd_boolean err = FALSE;
+
+  if (nfp_me_is_imm_opnd10 (srcA) && !nfp_me_is_imm_opnd10 (srcB))
+    {
+      src_bank = 'B';
+      src = srcB;
+    }
+
+  /* MEv28 does not have urd/uwr.  */
+  if (csr_num == 1)
+    {
+      if (wr)
+	{
+	  dinfo->fprintf_func (dinfo->stream, "uwr[*u$index%d++, ",
+			       (int) _BTST (instr, 20));
+	  err = err || !nfp_me_print_opnd10 (src, src_bank, num_ctx,
+					     src_lmext, dinfo);
+	}
+      else
+	{
+	  dinfo->fprintf_func (dinfo->stream, "urd[");
+	  err = err || !nfp_me_print_opnd10 (src, src_bank, num_ctx,
+					     src_lmext, dinfo);
+	  dinfo->fprintf_func (dinfo->stream, ", *u$index%d++",
+			       (int) _BTST (instr, 20));
+	}
+      dinfo->fprintf_func (dinfo->stream, "]");
+    }
+  else
+    {
+      const char *nm = NULL;
+
+      if (csr_num < ARRAY_SIZE (nfp_me27_28_mecsrs))
+	nm = nfp_me27_28_mecsrs[csr_num];
+
+      dinfo->fprintf_func (dinfo->stream, "local_csr_%s[",
+			   (wr) ? "wr" : "rd");
+      if (nm)
+	dinfo->fprintf_func (dinfo->stream, "%s", nm);
+      else
+	dinfo->fprintf_func (dinfo->stream, "0x%x", (csr_num * 4));
+
+      if (wr)
+	{
+	  dinfo->fprintf_func (dinfo->stream, ", ");
+	  err = err || !nfp_me_print_opnd10 (src, src_bank, num_ctx,
+					     src_lmext, dinfo);
+	}
+      dinfo->fprintf_func (dinfo->stream, "]");
+    }
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_branch (uint64_t instr,
+			  const char *br_inpstates[16],
+			  struct disassemble_info *dinfo)
+{
+  unsigned int br_op = _BF (instr, 4, 0);
+  unsigned int ctx_sig_state = _BF (instr, 17, 14);
+  unsigned int defer = _BF (instr, 21, 20);
+  unsigned int br_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);
+  int ret = 0;
+
+  if (!nfp_me27_28_br_ops[br_op])
+    {
+      dinfo->fprintf_func (dinfo->stream, _("<invalid branch>["));
+      ret = _NFP_ERR_CONT;
+    }
+  else
+    dinfo->fprintf_func (dinfo->stream, "%s[", nfp_me27_28_br_ops[br_op]);
+
+  switch (br_op)
+    {
+    case 16:			/* br=ctx */
+    case 17:			/* br!=ctx */
+    case 18:			/* br_signal */
+    case 19:			/* br_!signal */
+      dinfo->fprintf_func (dinfo->stream, "%d, ", ctx_sig_state);
+      break;
+    case 20:			/* "br_inp_state" */
+    case 21:			/* "br_!inp_state" */
+      dinfo->fprintf_func (dinfo->stream, "%s, ",
+			   br_inpstates[ctx_sig_state]);
+      break;
+    case 22:			/* "br_cls_state" */
+    case 23:			/* "br_!cls_state" */
+      dinfo->fprintf_func (dinfo->stream, "cls_ring%d_status, ",
+			   ctx_sig_state);
+      break;
+    default:
+      break;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, ".%d]", br_addr);
+
+  if (defer)
+    dinfo->fprintf_func (dinfo->stream, ", defer[%d]", defer);
+
+  return ret;
+}
+
+static int
+nfp_me27_28_print_br_byte (uint64_t instr,
+			   unsigned int src_lmext, int num_ctx,
+			   struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 7, 0);
+  unsigned int by = _BF (instr, 9, 8);
+  unsigned int srcB = _BF (instr, 17, 10);
+  unsigned int imm_msb = _BTST (instr, 18);
+  unsigned int eq = _BTST (instr, 19);
+  unsigned int defer = _BF (instr, 21, 20);
+  unsigned int br_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);
+  bfd_boolean err = FALSE;
+
+  if (eq)
+    dinfo->fprintf_func (dinfo->stream, "br=byte[");
+  else
+    dinfo->fprintf_func (dinfo->stream, "br!=byte[");
+
+  if (nfp_me_is_imm_opnd8 (srcA))
+    err = err || !nfp_me_print_opnd8 (srcB, 'B', num_ctx,
+				      src_lmext, imm_msb, dinfo);
+  else
+    err = err || !nfp_me_print_opnd8 (srcA, 'A', num_ctx,
+				      src_lmext, imm_msb, dinfo);
+
+  dinfo->fprintf_func (dinfo->stream, ", %d, ", by);
+
+  if (nfp_me_is_imm_opnd8 (srcA))
+    err = err || !nfp_me_print_opnd8 (srcA, 'A', num_ctx,
+				      src_lmext, imm_msb, dinfo);
+  else
+    err = err || !nfp_me_print_opnd8 (srcB, 'B', num_ctx,
+				      src_lmext, imm_msb, dinfo);
+
+  dinfo->fprintf_func (dinfo->stream, ", .%d]", br_addr);
+
+  if (defer)
+    dinfo->fprintf_func (dinfo->stream, ", defer[%d]", defer);
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_br_bit (uint64_t instr, unsigned int src_lmext,
+			  int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 7, 0);
+  unsigned int srcB = _BF (instr, 17, 10);
+  unsigned int b = _BTST (instr, 18);
+  unsigned int defer = _BF (instr, 21, 20);
+  unsigned int br_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);
+  bfd_boolean err = FALSE;
+
+  if (b)
+    dinfo->fprintf_func (dinfo->stream, "br_bset[");
+  else
+    dinfo->fprintf_func (dinfo->stream, "br_bclr[");
+
+  if (nfp_me_is_imm_opnd8 (srcA))
+    {
+      err = err
+	|| !nfp_me_print_opnd8 (srcB, 'B', num_ctx, src_lmext, 0, dinfo);
+      b = (nfp_me_imm_opnd8 (srcA, 0) - 1) & 0x1f;
+    }
+  else
+    {
+      err = err
+	|| !nfp_me_print_opnd8 (srcA, 'A', num_ctx, src_lmext, 0, dinfo);
+      b = (nfp_me_imm_opnd8 (srcB, 0) - 1) & 0x1f;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, ", %d, .%d]", b, br_addr);
+
+  if (defer)
+    dinfo->fprintf_func (dinfo->stream, ", defer[%d]", defer);
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_br_alu (uint64_t instr, unsigned int src_lmext,
+			  int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 9, 0);
+  unsigned int srcB = _BF (instr, 19, 10);
+  unsigned int defer = _BF (instr, 21, 20);
+  unsigned int imm = _BF (instr, 30, 22);
+  bfd_boolean err = FALSE;
+
+  if (nfp_me_is_imm_opnd10 (srcA))
+    imm = (imm << 8) | nfp_me_imm_opnd10 (srcA);
+  else
+    imm = (imm << 8) | nfp_me_imm_opnd10 (srcB);
+
+  if (!imm)
+    dinfo->fprintf_func (dinfo->stream, "rtn[");
+  else
+    dinfo->fprintf_func (dinfo->stream, "jump[");
+
+  if (nfp_me_is_imm_opnd10 (srcA))
+    err = err || !nfp_me_print_opnd10 (srcB, 'B', num_ctx, src_lmext, dinfo);
+  else
+    err = err || !nfp_me_print_opnd10 (srcA, 'A', num_ctx, src_lmext, dinfo);
+
+  if (imm)
+    dinfo->fprintf_func (dinfo->stream, ", .%d", imm);
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (defer)
+    dinfo->fprintf_func (dinfo->stream, ", defer[%d]", defer);
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_28_print_mult (uint64_t instr, unsigned int pred_cc,
+			unsigned int dst_lmext, unsigned int src_lmext,
+			unsigned int gpr_wrboth,
+			int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 9, 0);
+  unsigned int srcB = _BF (instr, 19, 10);
+  unsigned int mstep = _BF (instr, 22, 20);
+  char dst_bank = 'A' + _BTST (instr, 23);
+  unsigned int swap = _BTST (instr, 30);
+  unsigned int mtype = _BF (instr, 32, 31);
+  unsigned int nocc = _BTST (instr, 40);
+  bfd_boolean err = FALSE;
+
+  if (swap)
+    {
+      unsigned int tmp = srcA;
+      srcA = srcB;
+      srcB = tmp;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "mul_step[");
+
+  if (mstep >= 4)
+    err = err
+      || !nfp_me_print_opnd10 (srcA, dst_bank, num_ctx, dst_lmext, dinfo);
+  else
+    err = err || !nfp_me_print_opnd10 (srcA, (swap) ? 'B' : 'A', num_ctx,
+				       src_lmext, dinfo);
+
+  dinfo->fprintf_func (dinfo->stream, ", ");
+
+  if (mstep >= 4)
+    dinfo->fprintf_func (dinfo->stream, "--");
+  else
+    err = err || !nfp_me_print_opnd10 (srcB, (swap) ? 'A' : 'B', num_ctx,
+				       src_lmext, dinfo);
+
+  dinfo->fprintf_func (dinfo->stream, "], %s", nfp_me27_28_mult_types[mtype]);
+  if (mtype > 0)
+    {
+      const char *s = nfp_me27_28_mult_steps[mstep];
+      if (!s)
+	{
+	  s = "<invalid mul_step>";
+	  err = TRUE;
+	}
+      dinfo->fprintf_func (dinfo->stream, "_%s", s);
+    }
+
+  if (nocc)
+    dinfo->fprintf_func (dinfo->stream, ", no_cc");
+  if (gpr_wrboth)
+    dinfo->fprintf_func (dinfo->stream, ", gpr_wrboth");
+  if (pred_cc)
+    dinfo->fprintf_func (dinfo->stream, ", predicate_cc");
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+_nfp_cmp_mnmnc (const void *arg_a, const void *arg_b)
+{
+  const nfp_cmd_mnemonic *a = arg_a;
+  const nfp_cmd_mnemonic *b = arg_b;
+
+  if (a->cpp_target != b->cpp_target)
+    return (a->cpp_target > b->cpp_target) - (a->cpp_target < b->cpp_target);
+
+  if (a->cpp_action != b->cpp_action)
+    return (a->cpp_action > b->cpp_action) - (a->cpp_action < b->cpp_action);
+
+  return (a->cpp_token > b->cpp_token) - (a->cpp_token < b->cpp_token);
+}
+
+static const char *
+nfp_me_find_mnemonic (unsigned int cpp_tgt, unsigned int cpp_act,
+		      unsigned int cpp_tok, unsigned int cpp_len,
+		      const nfp_cmd_mnemonic * mnemonics,
+		      size_t mnemonics_cnt)
+{
+  nfp_cmd_mnemonic search_key = { cpp_tgt, cpp_act, cpp_tok, 0, 0, NULL };
+  const nfp_cmd_mnemonic *cmd = NULL;
+
+  cmd = bsearch (&search_key, mnemonics, mnemonics_cnt,
+		 sizeof (nfp_cmd_mnemonic), _nfp_cmp_mnmnc);
+
+  if (!cmd)
+    return NULL;
+
+  /* Make sure we backtrack to the first entry that still matches the three
+     bsearched fields - then we simply iterate and compare cpp_len.  */
+  while ((cmd > mnemonics) && (_nfp_cmp_mnmnc (&cmd[-1], &search_key) == 0))
+    --cmd;
+
+  /* Now compare by cpp_len and make sure we stay in range.  */
+  for (; (cmd < (mnemonics + mnemonics_cnt))
+       && (_nfp_cmp_mnmnc (cmd, &search_key) == 0); ++cmd)
+    {
+      if ((cpp_len & cmd->len_mask) == cmd->len_fixed)
+	return cmd->mnemonic;
+    }
+
+  return NULL;
+}
+
+/* NFP-32xx (ME Version 2.7).  */
+
+static int
+nfp_me27_print_cmd (uint64_t instr, int third_party_32bit,
+		    int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 7, 0);
+  unsigned int ctxswap_defer = _BF (instr, 9, 8);
+  unsigned int srcB = _BF (instr, 17, 10);
+  unsigned int token = _BF (instr, 19, 18);
+  unsigned int xfer = _BFS (instr, 40, 40, 5) | _BF (instr, 24, 20);
+  unsigned int cpp_len = _BF (instr, 27, 25);
+  unsigned int sig = _BF (instr, 31, 28);
+  unsigned int tgtcmd = _BF (instr, 38, 32);
+  unsigned int indref = _BTST (instr, 41);
+  unsigned int mode = _BF (instr, 44, 42);
+
+  bfd_boolean err = FALSE;
+  int cpp_target = -1;
+  int cpp_action = -1;
+  const char *mnemonic = NULL;
+  unsigned int imm;
+  unsigned int valBA;
+  int visswap = ((mode == 1) || (mode == 3));
+
+  imm = (sig << 10) | (cpp_len << 7) | ((xfer & 0x1f) << 2) | token;
+  valBA = (srcB << 8) | srcA;
+
+  if (mode == 6)
+    {
+      token = 0;
+      sig = 0;
+      xfer = 0;
+    }
+
+  /* Convert tgtcmd to action/token tuple.  */
+  if (_BF (tgtcmd, 6, 5) == 0x0)
+    {
+      switch (_BF (tgtcmd, 4, 2))
+	{
+	case 0:
+	  cpp_target = NFP_3200_CPPTGT_CAP;
+	  dinfo->fprintf_func (dinfo->stream, "cap[");
+	  break;
+	case 1:
+	  cpp_target = NFP_3200_CPPTGT_MSF0;
+	  dinfo->fprintf_func (dinfo->stream, "msf0[");
+	  break;
+	case 2:
+	  cpp_target = NFP_3200_CPPTGT_MSF1;
+	  dinfo->fprintf_func (dinfo->stream, "msf1[");
+	  break;
+	case 3:
+	  cpp_target = NFP_3200_CPPTGT_PCIE;
+	  dinfo->fprintf_func (dinfo->stream, "pcie[");
+	  break;
+	case 4:
+	  cpp_target = NFP_3200_CPPTGT_HASH;
+	  break;
+	case 5:
+	  cpp_target = NFP_3200_CPPTGT_CRYPTO;
+	  dinfo->fprintf_func (dinfo->stream, "crypto[");
+	  break;
+	case 6:
+	  cpp_target = NFP_3200_CPPTGT_ARM;
+	  dinfo->fprintf_func (dinfo->stream, "arm[");
+	  break;
+	case 7:
+	  cpp_target = NFP_3200_CPPTGT_CT;
+	  dinfo->fprintf_func (dinfo->stream, "ct[");
+	  break;
+	}
+      cpp_action = _BF (tgtcmd, 1, 0);
+    }
+  else
+    {
+      switch (_BF (tgtcmd, 6, 4))
+	{
+	case 2:
+	  cpp_target = NFP_3200_CPPTGT_GS;
+	  dinfo->fprintf_func (dinfo->stream, "scratch[");
+	  break;
+	case 3:
+	  cpp_target = NFP_3200_CPPTGT_QDR;	/* A.k.a. SRAM.  */
+	  dinfo->fprintf_func (dinfo->stream, "sram[");
+	  break;
+	case 4:
+	case 5:
+	  cpp_target = NFP_3200_CPPTGT_MU;
+	  dinfo->fprintf_func (dinfo->stream, "mem[");
+	  break;
+	case 6:
+	case 7:
+	  cpp_target = NFP_3200_CPPTGT_CLS;
+	  dinfo->fprintf_func (dinfo->stream, "cls[");
+	  break;
+	}
+      cpp_action = _BF (tgtcmd, 3, 0);
+    }
+
+  if (cpp_target < 0)
+    {
+      dinfo->fprintf_func (dinfo->stream, _("<invalid cmd target %d:%d:%d>[]"),
+			   cpp_target, cpp_action, token);
+      return _NFP_ERR_CONT;
+    }
+
+  mnemonic = nfp_me_find_mnemonic (cpp_target, cpp_action, token, cpp_len,
+				   nfp_me27_mnemonics,
+				   ARRAY_SIZE (nfp_me27_mnemonics));
+
+  if (!mnemonic)
+    {
+      dinfo->fprintf_func (dinfo->stream, _("<invalid cmd action %d:%d:%d>[]"),
+			   cpp_target, cpp_action, token);
+      return _NFP_ERR_CONT;
+    }
+
+  if (cpp_target == NFP_3200_CPPTGT_HASH)
+    {
+      dinfo->fprintf_func (dinfo->stream, "%s[$xfer_%d, %d",
+			   mnemonic, xfer, cpp_len);
+      goto print_opt_toks;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "%s, ", mnemonic);
+
+  if (visswap)
+    {
+      unsigned int tmp = srcA;
+      srcA = srcB;
+      srcB = tmp;
+    }
+
+  switch (mode)
+    {
+    case 0:			/* (A << 8) + B.  */
+    case 1:			/* (B << 8) + A.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, ", xfer);
+      err = err
+	|| !nfp_me_print_opnd8 (srcA, 'A' + visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", <<8, ");
+      err = err
+	|| !nfp_me_print_opnd8 (srcB, 'B' - visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 2:			/* Accelerated 3rd party (A[ << 8]) + B.  */
+    case 3:			/* Accelerated 3rd party (B[ << 8]) + A.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, ", (indref << 6) | xfer);
+      err = err
+	|| !nfp_me_print_opnd8 (srcA, 'A' + visswap, num_ctx, 0, 0, dinfo);
+      if (third_party_32bit)
+	dinfo->fprintf_func (dinfo->stream, ", ");
+      else
+	dinfo->fprintf_func (dinfo->stream, ", <<8, ");
+      err = err
+	|| !nfp_me_print_opnd8 (srcB, 'B' - visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 4:			/* A + B.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, ", xfer);
+      err = err || !nfp_me_print_opnd8 (srcA, 'A', num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", ");
+      err = err || !nfp_me_print_opnd8 (srcB, 'B', num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 5:			/* Immediate address.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, 0x%x, %d", xfer, valBA,
+			   (cpp_len + 1));
+      break;
+    case 6:			/* Immediate address and data.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, 0x%x", valBA, imm);
+      break;
+    case 7:			/* Immediate data.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, --, %d",
+			   ((xfer << 16) | valBA), (cpp_len + 1));
+      break;
+    }
+
+ print_opt_toks:
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (indref && (mode != 2) && (mode != 3))
+    dinfo->fprintf_func (dinfo->stream, ", indirect_ref");
+
+  if (ctxswap_defer != 3)
+    {
+      dinfo->fprintf_func (dinfo->stream, ", ctx_swap[");
+      if (sig)
+	dinfo->fprintf_func (dinfo->stream, "sig%d]", sig);
+      else
+	dinfo->fprintf_func (dinfo->stream, "--]");
+
+      if (ctxswap_defer != 0)
+	dinfo->fprintf_func (dinfo->stream, ", defer[%d]", ctxswap_defer);
+    }
+  else if (sig)
+    dinfo->fprintf_func (dinfo->stream, ", sig_done[sig%d]", sig);
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me27_print_alu_shf (uint64_t instr, int num_ctx,
+			struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_alu_shf (instr, 0, 0, 0, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_alu (uint64_t instr, int num_ctx,
+		    struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_alu_shf (instr, 0, 0, 0, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_immed (uint64_t instr, int num_ctx,
+		      struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_immed (instr, 0, 0, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_ld_field (uint64_t instr, int num_ctx,
+			 struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_ld_field (instr, 0, 0, 0, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_ctx_arb (uint64_t instr, struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_ctx_arb (instr, dinfo);
+}
+
+static int
+nfp_me27_print_local_csr (uint64_t instr, int num_ctx,
+			  struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_local_csr (instr, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_branch (uint64_t instr, struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_branch (instr, nfp_me27_br_inpstates, dinfo);
+}
+
+static int
+nfp_me27_print_br_byte (uint64_t instr, int num_ctx,
+			struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_br_byte (instr, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_br_bit (uint64_t instr, int num_ctx,
+		       struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_br_bit (instr, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_br_alu (uint64_t instr, int num_ctx,
+		       struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_br_alu (instr, 0, num_ctx, dinfo);
+}
+
+static int
+nfp_me27_print_mult (uint64_t instr, int num_ctx,
+		     struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_mult (instr, 0, 0, 0, 0, num_ctx, dinfo);
+}
+
+/*NFP-6xxx/4xxx (ME Version 2.8).  */
+
+static int
+nfp_me28_print_cmd (uint64_t instr, int third_party_32bit,
+		    int num_ctx, struct disassemble_info *dinfo)
+{
+  unsigned int srcA = _BF (instr, 7, 0);
+  unsigned int ctxswap_defer = _BF (instr, 9, 8);
+  unsigned int srcB = _BF (instr, 17, 10);
+  unsigned int token = _BF (instr, 19, 18);
+  unsigned int xfer = _BFS (instr, 40, 40, 5) | _BF (instr, 24, 20);
+  unsigned int cpp_len = _BF (instr, 27, 25);
+  unsigned int sig = _BF (instr, 31, 28);
+  unsigned int tgtcmd = _BF (instr, 38, 32);
+  unsigned int indref = _BTST (instr, 41);
+  unsigned int mode = _BF (instr, 44, 42);
+
+  bfd_boolean err = FALSE;
+  int cpp_target = -1;
+  int cpp_action = -1;
+  const char *mnemonic = NULL;
+  unsigned int imm;
+  unsigned int valBA;
+  int visswap = ((mode == 1) || (mode == 3));
+
+  imm = (sig << 10) | (cpp_len << 7) | ((xfer & 0x1f) << 2) | token;
+  valBA = (srcB << 8) | srcA;
+
+  if (mode == 6)
+    {
+      token = 0;
+      sig = 0;
+      xfer = 0;
+    }
+
+  /* Convert tgtcmd to action/token tuple.  */
+  if (_BF (tgtcmd, 6, 5) == 0x0)
+    {
+      switch (_BF (tgtcmd, 4, 2))
+	{
+	case 0:
+	  cpp_target = NFP_6000_CPPTGT_ILA;
+	  dinfo->fprintf_func (dinfo->stream, "ila[");
+	  break;
+	case 1:
+	  cpp_target = NFP_6000_CPPTGT_NBI;
+	  dinfo->fprintf_func (dinfo->stream, "nbi[");
+	  break;
+	case 3:
+	  cpp_target = NFP_6000_CPPTGT_PCIE;
+	  dinfo->fprintf_func (dinfo->stream, "pcie[");
+	  break;
+	case 5:
+	  cpp_target = NFP_6000_CPPTGT_CRYPTO;
+	  dinfo->fprintf_func (dinfo->stream, "crypto[");
+	  break;
+	case 6:
+	  cpp_target = NFP_6000_CPPTGT_ARM;
+	  dinfo->fprintf_func (dinfo->stream, "arm[");
+	  break;
+	case 7:
+	  cpp_target = NFP_6000_CPPTGT_CTXPB;
+	  dinfo->fprintf_func (dinfo->stream, "ct[");
+	  break;
+	}
+      cpp_action = _BF (tgtcmd, 1, 0);
+    }
+  else
+    {
+      /* One bit overlap between "t" and "a" fields, for sram it's "t" and
+	 for mem/cls it's "a".  */
+      cpp_action = _BF (tgtcmd, 4, 0);
+      switch (_BF (tgtcmd, 6, 4))
+	{
+	case 3:
+	  cpp_target = NFP_6000_CPPTGT_VQDR;
+	  cpp_action = _BF (tgtcmd, 3, 0);
+	  dinfo->fprintf_func (dinfo->stream, "sram[");
+	  break;
+	case 4:
+	case 5:
+	  cpp_target = NFP_6000_CPPTGT_MU;
+	  dinfo->fprintf_func (dinfo->stream, "mem[");
+	  break;
+	case 6:
+	case 7:
+	  cpp_target = NFP_6000_CPPTGT_CLS;
+	  dinfo->fprintf_func (dinfo->stream, "cls[");
+	  break;
+	}
+    }
+
+  if (cpp_target < 0)
+    {
+      dinfo->fprintf_func (dinfo->stream, _("<invalid cmd target %d:%d:%d>[]"),
+			   cpp_target, cpp_action, token);
+      return _NFP_ERR_CONT;
+    }
+
+  mnemonic = nfp_me_find_mnemonic (cpp_target, cpp_action, token, cpp_len,
+				   nfp_me28_mnemonics,
+				   ARRAY_SIZE (nfp_me28_mnemonics));
+
+  if (!mnemonic)
+    {
+      dinfo->fprintf_func (dinfo->stream, _("<invalid cmd action %d:%d:%d>[]"),
+			   cpp_target, cpp_action, token);
+      return _NFP_ERR_CONT;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "%s, ", mnemonic);
+
+  if (visswap)
+    {
+      unsigned int tmp = srcA;
+      srcA = srcB;
+      srcB = tmp;
+    }
+
+  switch (mode)
+    {
+    case 0:			/* (A << 8) + B.  */
+    case 1:			/* (B << 8) + A.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, ", xfer);
+      err = err
+	|| !nfp_me_print_opnd8 (srcA, 'A' + visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", <<8, ");
+      err = err
+	|| !nfp_me_print_opnd8 (srcB, 'B' - visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 2:			/* Accelerated 3rd party (A[ << 8]) + B.  */
+    case 3:			/* Accelerated 3rd party (B[ << 8]) + A.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, ", (indref << 6) | xfer);
+      err = err
+	|| !nfp_me_print_opnd8 (srcA, 'A' + visswap, num_ctx, 0, 0, dinfo);
+      if (third_party_32bit)
+	dinfo->fprintf_func (dinfo->stream, ", ");
+      else
+	dinfo->fprintf_func (dinfo->stream, ", <<8, ");
+      err = err
+	|| !nfp_me_print_opnd8 (srcB, 'B' - visswap, num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 4:			/* A + B.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, ", xfer);
+      err = err || !nfp_me_print_opnd8 (srcA, 'A', num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", ");
+      err = err || !nfp_me_print_opnd8 (srcB, 'B', num_ctx, 0, 0, dinfo);
+      dinfo->fprintf_func (dinfo->stream, ", %d", (cpp_len + 1));
+      break;
+    case 5:			/* Immediate address.  */
+      dinfo->fprintf_func (dinfo->stream, "$xfer_%d, 0x%x, %d", xfer, valBA,
+			   (cpp_len + 1));
+      break;
+    case 6:			/* Immediate address and data.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, 0x%x", valBA, imm);
+      break;
+    case 7:			/* Immediate data.  */
+      dinfo->fprintf_func (dinfo->stream, "0x%x, --, %d",
+			   ((xfer << 16) | valBA), (cpp_len + 1));
+      break;
+    }
+
+  dinfo->fprintf_func (dinfo->stream, "]");
+
+  if (indref && (mode != 2) && (mode != 3))
+    dinfo->fprintf_func (dinfo->stream, ", indirect_ref");
+
+  if (ctxswap_defer != 3)
+    {
+      dinfo->fprintf_func (dinfo->stream, ", ctx_swap[");
+      if (sig)
+	dinfo->fprintf_func (dinfo->stream, "sig%d]", sig);
+      else
+	dinfo->fprintf_func (dinfo->stream, "--]");
+
+      if (ctxswap_defer != 0)
+	dinfo->fprintf_func (dinfo->stream, ", defer[%d]", ctxswap_defer);
+    }
+  else if (sig)
+    dinfo->fprintf_func (dinfo->stream, ", sig_done[sig%d]", sig);
+
+  if (err)
+    return _NFP_ERR_CONT;
+  return 0;
+}
+
+static int
+nfp_me28_print_alu_shf (uint64_t instr, int num_ctx,
+			struct disassemble_info *dinfo)
+{
+  unsigned int gpr_wrboth = _BTST (instr, 41);
+  unsigned int src_lmext = _BTST (instr, 42);
+  unsigned int dst_lmext = _BTST (instr, 43);
+  unsigned int pred_cc = _BTST (instr, 44);
+
+  return nfp_me27_28_print_alu_shf (instr, pred_cc, dst_lmext,
+				    src_lmext, gpr_wrboth, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_alu (uint64_t instr, int num_ctx,
+		    struct disassemble_info *dinfo)
+{
+  unsigned int gpr_wrboth = _BTST (instr, 41);
+  unsigned int src_lmext = _BTST (instr, 42);
+  unsigned int dst_lmext = _BTST (instr, 43);
+  unsigned int pred_cc = _BTST (instr, 44);
+
+  return nfp_me27_28_print_alu (instr, pred_cc, dst_lmext, src_lmext,
+				gpr_wrboth, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_immed (uint64_t instr, int num_ctx,
+		      struct disassemble_info *dinfo)
+{
+  unsigned int gpr_wrboth = _BTST (instr, 41);
+  unsigned int dst_lmext = _BTST (instr, 43);
+  unsigned int pred_cc = _BTST (instr, 44);
+
+  return nfp_me27_28_print_immed (instr, pred_cc, dst_lmext, gpr_wrboth,
+				  num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_ld_field (uint64_t instr, int num_ctx,
+			 struct disassemble_info *dinfo)
+{
+  unsigned int gpr_wrboth = _BTST (instr, 41);
+  unsigned int src_lmext = _BTST (instr, 42);
+  unsigned int dst_lmext = _BTST (instr, 43);
+  unsigned int pred_cc = _BTST (instr, 44);
+
+  return nfp_me27_28_print_ld_field (instr, pred_cc, dst_lmext,
+				     src_lmext, gpr_wrboth, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_ctx_arb (uint64_t instr, struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_ctx_arb (instr, dinfo);
+}
+
+static int
+nfp_me28_print_local_csr (uint64_t instr, int num_ctx,
+			  struct disassemble_info *dinfo)
+{
+  unsigned int src_lmext = _BTST (instr, 42);
+
+  return nfp_me27_28_print_local_csr (instr, src_lmext, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_branch (uint64_t instr, struct disassemble_info *dinfo)
+{
+  return nfp_me27_28_print_branch (instr, nfp_me28_br_inpstates, dinfo);
+}
+
+static int
+nfp_me28_print_br_byte (uint64_t instr, int num_ctx,
+			struct disassemble_info *dinfo)
+{
+  unsigned int src_lmext = _BTST (instr, 42);
+  return nfp_me27_28_print_br_byte (instr, src_lmext, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_br_bit (uint64_t instr, int num_ctx,
+		       struct disassemble_info *dinfo)
+{
+  unsigned int src_lmext = _BTST (instr, 42);
+  return nfp_me27_28_print_br_bit (instr, src_lmext, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_br_alu (uint64_t instr, int num_ctx,
+		       struct disassemble_info *dinfo)
+{
+  unsigned int src_lmext = _BTST (instr, 42);
+  return nfp_me27_28_print_br_alu (instr, src_lmext, num_ctx, dinfo);
+}
+
+static int
+nfp_me28_print_mult (uint64_t instr, int num_ctx,
+		     struct disassemble_info *dinfo)
+{
+  unsigned int gpr_wrboth = _BTST (instr, 41);
+  unsigned int src_lmext = _BTST (instr, 42);
+  unsigned int dst_lmext = _BTST (instr, 43);
+  unsigned int pred_cc = _BTST (instr, 44);
+
+  return nfp_me27_28_print_mult (instr, pred_cc, dst_lmext, src_lmext,
+				 gpr_wrboth, num_ctx, dinfo);
+}
+
+static bfd_boolean
+init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)
+{
+  Elf_Internal_Shdr *sec = NULL;
+  Elf_Nfp_MeConfig mecfg_ent;
+  unsigned char buffer[sizeof (Elf_Nfp_MeConfig)];
+  file_ptr roff = 0;
+  unsigned int sec_cnt = 0;
+  unsigned int sec_idx;
+  size_t menum_linear = 0;
+
+  if (!dinfo->section)
+    /* No section info, will use default values.  */
+    return TRUE;
+
+  sec_cnt = elf_numsections (dinfo->section->owner);
+
+  /* Find the MECONFIG section.  It's index is also in e_flags, but it has
+     a unique SHT and we'll use that.  */
+  for (sec_idx = 0; sec_idx < sec_cnt; sec_idx++)
+    {
+      sec = elf_elfsections (dinfo->section->owner)[sec_idx];
+
+      if (sec->sh_type == SHT_NFP_MECONFIG)
+	break;
+    }
+
+  if (sec_idx == sec_cnt)
+    {
+      dinfo->fprintf_func (dinfo->stream, _("File has no ME-Config section."));
+      return FALSE;
+    }
+
+  for (roff = 0; (bfd_size_type) roff < sec->sh_size;
+       roff += sec->sh_entsize, menum_linear++)
+    {
+      nfp_priv_mecfg *mecfg;
+      int isl = menum_linear >> 3;
+      int menum = menum_linear & 7;
+
+      if (menum_linear >= 40)
+	{
+	  dinfo->fprintf_func (dinfo->stream,
+			       _("File has invalid ME-Config section."));
+	  return FALSE;
+	}
+
+      mecfg = &priv->mecfgs[isl][menum][1];
+
+      if (!bfd_get_section_contents (dinfo->section->owner, sec->bfd_section,
+				     buffer, roff, sizeof (buffer)))
+	return FALSE;
+
+      mecfg_ent.ctx_enables = bfd_getl32 (buffer + offsetof (Elf_Nfp_MeConfig,
+							     ctx_enables));
+      mecfg_ent.misc_control = bfd_getl32 (buffer
+	+ offsetof (Elf_Nfp_MeConfig, misc_control));
+
+      mecfg->ctx4_mode = _BTST (mecfg_ent.ctx_enables, 31);
+      mecfg->addr_3rdparty32 = _BTST (mecfg_ent.misc_control, 4);
+      mecfg->scs_cnt = _BTST (mecfg_ent.misc_control, 2);
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,
+			int is_for_text, struct disassemble_info *dinfo)
+{
+  Elf_Nfp_InitRegEntry ireg;
+  unsigned char buffer[sizeof (Elf_Nfp_InitRegEntry)];
+  file_ptr ireg_off = 0;
+  size_t isl, menum;
+
+  if (sec->sh_entsize != sizeof (ireg))
+    return FALSE;
+
+  isl = SHI_NFP_IREG_ISLAND (sec->sh_info);
+
+  /* For these sections we know that the address will only be 32 bits
+     so we only need cpp_offset_lo.
+     Address is encoded as follows:
+     <31:30> 0
+     <29:24> island (already got this from sh_info)
+     <23:17> 0
+     <16:16> XferCsrRegSel (1 for these sections)
+     <15:14> 0
+     <13:10> DataMasterID (MEnum = this - 4)
+     <9:2> register (index)
+     <1:0> 0b0 (register byte address if appened to the previous field).  */
+  for (ireg_off = 0; (bfd_size_type) ireg_off < sec->sh_size;
+       ireg_off += sec->sh_entsize)
+    {
+      uint32_t csr_off;
+      nfp_priv_mecfg *mecfg;
+
+      if (!bfd_get_section_contents (dinfo->section->owner, sec->bfd_section,
+				     buffer, ireg_off, sizeof (buffer)))
+	return FALSE;
+
+      ireg.cpp_offset_lo = bfd_getl32 (buffer
+	+ offsetof (Elf_Nfp_InitRegEntry, cpp_offset_lo));
+      ireg.mask = bfd_getl32 (buffer + offsetof (Elf_Nfp_InitRegEntry, mask));
+      ireg.val = bfd_getl32 (buffer + offsetof (Elf_Nfp_InitRegEntry, val));
+      ireg.w0 = bfd_getl32 (buffer + offsetof (Elf_Nfp_InitRegEntry, w0));
+
+      if (NFP_IREG_ENTRY_WO_NLW (ireg.w0))
+	continue;
+
+      /* Only consider entries that are permanent for runtime.  */
+      if ((NFP_IREG_ENTRY_WO_VTP (ireg.w0) != NFP_IREG_VTP_CONST)
+	  && (NFP_IREG_ENTRY_WO_VTP (ireg.w0) != NFP_IREG_VTP_FORCE))
+	continue;
+
+      menum = _BF (ireg.cpp_offset_lo, 13, 10) - 4;
+      csr_off = _BF (ireg.cpp_offset_lo, 9, 0);
+
+      mecfg = &priv->mecfgs[isl][menum][is_for_text];
+      switch (csr_off)
+	{
+	case _NFP_ME27_28_CSR_CTX_ENABLES:
+	  mecfg->ctx4_mode = _BTST (ireg.val, 31);
+	  break;
+	case _NFP_ME27_28_CSR_MISC_CONTROL:
+	  mecfg->addr_3rdparty32 = _BTST (ireg.val, 4);
+	  mecfg->scs_cnt = _BTST (ireg.val, 2);
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+init_nfp6000_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)
+{
+  int mecfg_orders[64][2];
+  size_t isl;
+  unsigned int sec_cnt = 0;
+  unsigned int sec_idx;
+  int is_for_text;
+
+  memset (mecfg_orders, -1, sizeof (mecfg_orders));
+
+  if (!dinfo->section)
+    /* No section info, will use default values.  */
+    return TRUE;
+
+  sec_cnt = elf_numsections (dinfo->section->owner);
+
+  /* Go through all MECSR init sections to find ME configs.  */
+  for (sec_idx = 0; sec_idx < sec_cnt; sec_idx++)
+    {
+      Elf_Internal_Shdr *sec;
+      int sec_order;
+
+      sec = elf_elfsections (dinfo->section->owner)[sec_idx];
+      sec_order = (int) SHI_NFP_IREG_ORDER (sec->sh_info);
+
+      is_for_text = (sec->sh_flags & (SHF_NFP_INIT | SHF_NFP_INIT2)) == 0;
+
+      /* If we have an init2 section, that is the one that applies to the
+	 ME when executing init code.  So we make it's order higher than
+	 any plain init section.  */
+      if (sec->sh_flags & SHF_NFP_INIT2)
+	sec_order += SHI_NFP_IREG_ORDER (~0U) + 1;
+
+      if (sec->sh_type != SHT_NFP_INITREG)
+	continue;
+      if (!SHI_NFP_6000_IS_IREG_MECSR (sec->sh_info))
+	continue;
+
+      isl = SHI_NFP_IREG_ISLAND (sec->sh_info);
+      if ((sec_order < mecfg_orders[isl][is_for_text]))
+	/* Lower order or transient, skip it.  */
+	continue;
+
+      mecfg_orders[isl][is_for_text] = sec_order;
+
+      if (!init_nfp6000_mecsr_sec (priv, sec, is_for_text, dinfo))
+	{
+	  dinfo->fprintf_func (dinfo->stream,
+			       _("Error processing section %u "), sec_idx);
+	  return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+static int
+parse_disassembler_options (nfp_opts * opts, struct disassemble_info *dinfo)
+{
+  const char *option;
+
+  if (dinfo->disassembler_options == NULL)
+    return 0;
+
+  FOR_EACH_DISASSEMBLER_OPTION (option, dinfo->disassembler_options)
+  {
+    if (disassembler_options_cmp (option, "no-pc") == 0)
+      opts->show_pc = 0;
+    else if (disassembler_options_cmp (option, "ctx4") == 0)
+      {
+	if (!opts->ctx_mode)
+	  opts->ctx_mode = 4;
+      }
+    else if (disassembler_options_cmp (option, "ctx8") == 0)
+      opts->ctx_mode = 8;
+    else
+      {
+	dinfo->fprintf_func (dinfo->stream, _("Invalid NFP option: %s"), option);
+	return _NFP_ERR_STOP;
+      }
+  }
+
+  return 0;
+}
+
+/* Called on first disassembly attempt so that dinfo->section is valid
+   so that we can get the bfd owner to find ME configs.  */
+
+static nfp_priv_data *
+init_nfp_priv (struct disassemble_info *dinfo)
+{
+  nfp_priv_data *priv;
+  int ret = FALSE;
+
+  if (dinfo->private_data)
+    return (nfp_priv_data *) dinfo->private_data;
+
+#if 0  /* Right now only section-related info is kept in priv.
+	  So don't even calloc it if we don't need it.  */
+  if (!dinfo->section)
+     return NULL;
+#endif
+
+  /* Alloc with no free, seems to be either this or a static global variable
+     and this at least keeps a large struct unallocated until really needed.  */
+  priv = calloc (1, sizeof (*priv));
+  if (!priv)
+    return NULL;
+
+  switch (dinfo->mach)
+    {
+    case E_NFP_MACH_3200:
+      ret = init_nfp3200_priv (priv, dinfo);
+      break;
+    case E_NFP_MACH_6000:
+      ret = init_nfp6000_priv (priv, dinfo);
+      break;
+    }
+
+  if (!ret)
+    {
+      free (priv);
+      return NULL;
+    }
+
+  dinfo->private_data = priv;
+  return priv;
+}
+
+static int
+_print_instrs (bfd_vma addr, struct disassemble_info *dinfo, nfp_opts * opts)
+{
+  nfp_priv_data *priv = init_nfp_priv (dinfo);
+  bfd_byte buffer[8];
+  int err;
+  uint64_t instr = 0;
+  size_t island, menum;
+  int num_ctx, scs_cnt, addr_3rdparty32, pc, tmpi, tmpj;
+  int is_text = 1;
+
+  err = dinfo->read_memory_func (addr, buffer, 8, dinfo);
+  if (err)
+    return _NFP_ERR_STOP;
+
+  if (!dinfo->section)
+    {
+      num_ctx = 8;
+      scs_cnt = 0;
+      addr_3rdparty32 = 0;
+    }
+  else
+    {
+      unsigned int sh_info = 0;
+      nfp_priv_mecfg *mecfg;
+
+      /* We have a section, presumably all ELF sections.  Try to find
+	 proper ME configs to produce better disassembly.  */
+      if (!priv)
+	return _NFP_ERR_STOP;	/* Sanity check */
+
+      is_text = (elf_section_flags (dinfo->section)
+		 & (SHF_NFP_INIT | SHF_NFP_INIT2)) == 0;
+
+      sh_info = elf_section_info (dinfo->section);
+
+      switch (dinfo->mach)
+	{
+	case E_NFP_MACH_3200:
+	  island = SHI_NFP_3200_ISLAND (sh_info);
+	  menum = SHI_NFP_3200_MENUM (sh_info);
+	  break;
+	default:
+	  island = SHI_NFP_ISLAND (sh_info);
+	  menum = SHI_NFP_MENUM (sh_info);
+	  break;
+	}
+
+      mecfg = &priv->mecfgs[island][menum][is_text];
+      num_ctx = (mecfg->ctx4_mode) ? 4 : 8;
+      addr_3rdparty32 = mecfg->addr_3rdparty32;
+      scs_cnt = mecfg->scs_cnt;
+    }
+
+  if (opts->ctx_mode)
+    num_ctx = opts->ctx_mode;
+
+  dinfo->bytes_per_line = 8;
+  dinfo->bytes_per_chunk = 8;
+
+  instr = bfd_getl64 (buffer);
+
+  if (opts->show_pc)
+    {
+      pc = (int) (addr >> 3);
+
+      /* Guess max PC for formatting */
+      tmpj = (int) (dinfo->buffer_length >> 3);
+      if (scs_cnt == 1)
+	{
+	  pc *= 2;
+	  tmpj *= 2;
+	  if (! !(menum & 1))
+	    {
+	      pc++;
+	      tmpj++;
+	    }
+	}
+
+      for (tmpi = 1; tmpj > 9; tmpj /= 10)
+	tmpi++;
+
+      tmpj = pc;
+      for (; tmpj > 9; tmpj /= 10)
+	tmpi--;
+
+      dinfo->fprintf_func (dinfo->stream, "%*c%d  ", tmpi, '.', pc);
+    }
+
+  switch (dinfo->mach)
+    {
+    case E_NFP_MACH_3200:
+      if (NFP_ME27_INSTR_IS_CMD (instr))
+	err = nfp_me27_print_cmd (instr, addr_3rdparty32, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_ALU_SHF (instr))
+	err = nfp_me27_print_alu_shf (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_ALU (instr))
+	err = nfp_me27_print_alu (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_IMMED (instr))
+	err = nfp_me27_print_immed (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_LD_FIELD (instr))
+	err = nfp_me27_print_ld_field (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_CTX_ARB (instr))
+	err = nfp_me27_print_ctx_arb (instr, dinfo);
+      else if (NFP_ME27_INSTR_IS_LOCAL_CSR (instr))
+	err = nfp_me27_print_local_csr (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_BRANCH (instr))
+	err = nfp_me27_print_branch (instr, dinfo);
+      else if (NFP_ME27_INSTR_IS_BR_BYTE (instr))
+	err = nfp_me27_print_br_byte (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_BR_BIT (instr))
+	err = nfp_me27_print_br_bit (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_BR_ALU (instr))
+	err = nfp_me27_print_br_alu (instr, num_ctx, dinfo);
+      else if (NFP_ME27_INSTR_IS_MULT (instr))
+	err = nfp_me27_print_mult (instr, num_ctx, dinfo);
+      else
+	err = nfp_me_print_invalid (instr, dinfo);
+      break;
+
+    case E_NFP_MACH_6000:
+      if (NFP_ME28_INSTR_IS_CMD (instr))
+	err = nfp_me28_print_cmd (instr, addr_3rdparty32, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_ALU_SHF (instr))
+	err = nfp_me28_print_alu_shf (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_ALU (instr))
+	err = nfp_me28_print_alu (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_IMMED (instr))
+	err = nfp_me28_print_immed (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_LD_FIELD (instr))
+	err = nfp_me28_print_ld_field (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_CTX_ARB (instr))
+	err = nfp_me28_print_ctx_arb (instr, dinfo);
+      else if (NFP_ME28_INSTR_IS_LOCAL_CSR (instr))
+	err = nfp_me28_print_local_csr (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_BRANCH (instr))
+	err = nfp_me28_print_branch (instr, dinfo);
+      else if (NFP_ME28_INSTR_IS_BR_BYTE (instr))
+	err = nfp_me28_print_br_byte (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_BR_BIT (instr))
+	err = nfp_me28_print_br_bit (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_BR_ALU (instr))
+	err = nfp_me28_print_br_alu (instr, num_ctx, dinfo);
+      else if (NFP_ME28_INSTR_IS_MULT (instr))
+	err = nfp_me28_print_mult (instr, num_ctx, dinfo);
+      else
+	err = nfp_me_print_invalid (instr, dinfo);
+      break;
+    }
+
+  if (err < 0)
+    return err;
+  return 8;
+}
+
+int
+print_insn_nfp (bfd_vma addr, struct disassemble_info *dinfo)
+{
+  nfp_opts opts;
+  int err;
+
+  opts.show_pc = 1;
+  opts.ctx_mode = 0;
+  err = parse_disassembler_options (&opts, dinfo);
+  if (err < 0)
+    goto end;
+
+  err = _print_instrs (addr, dinfo, &opts);
+
+end:
+  if (err != 8)
+    dinfo->fprintf_func (dinfo->stream, "\t # ERROR");
+  if (err == _NFP_ERR_CONT)
+    return 8;
+  return err;
+}
+
+void
+print_nfp_disassembler_options (FILE * stream)
+{
+  fprintf (stream, _("\n\
+The following NFP specific disassembler options are supported for use\n\
+with the -M switch (multiple options should be separated by commas):\n"));
+
+  fprintf (stream, _("\n\
+  no-pc		    Don't print program counter prefix.\n\
+  ctx4		    Force disassembly using 4-context mode.\n\
+  ctx8		    Force 8-context mode, takes precedence."));
+
+  fprintf (stream, _("\n"));
+}
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ /binutils/testsuite/binutils-all/nfp/test2_nfp6000.nffw	2018-04-30 11:21:22.978953995 +0100
@@ -0,0 +1,11 @@
+ELF           `                   @           @     @                                                                                         @      [                                                            4                                                     Ø      0                               &                           H                              4     p   €            P                  €               ?     p   €            à                 €               K     p                ð      Ð          „ƒ                .shstrtab .note.nfp .note.build_info .text.i32.me0 .regi.xpbm .regi1.xpbm .regt.mecsr.i32              NFP               NFP                           NFP ÿLgZnfld 6.x-devel (build 3484)  0 €  0    0    0 €  Ì    ü À Œ°   Ÿ° À    à      
+`ˆR  ÿÿ      
+`&  ÿÿ      
+`°\  ÿÿ      
+` v  ÿÿ     $ 
+`„Q  ÿÿ     ( 
+`A   ÿÿ     0 
+` C  ÿÿ     8 
+`@   ÿÿ     < 
+`   ÿÿ     @ 
+`       €                U ÿs               @     ÿ?     @     ÿ?     "@     ÿ?     2@     ÿ?     B@     ÿ?     R@     ÿ?     b@     ÿ?     r@     ÿ?     D           H     þÿ     H     þÿ     "H     þÿ     2H     þÿ     BH     þÿ     RH     þÿ     bH     þÿ     rH     þÿ     P   ÿÿ    P    ÿÿ    "P   ÿÿ    2P    ÿÿ    BP   ÿÿ    RP    ÿÿ    bP   ÿÿ    rP    ÿÿ    `      
\ No newline at end of file
--- /dev/null	2019-03-07 09:27:55.425999321 +0000
+++ /binutils/testsuite/binutils-all/nfp/test1_nfp6000.nffw	2018-11-15 10:36:45.969182755 +0000
@@ -0,0 +1,75 @@
+ELF           `                   @           @     @ 
+                                                                                        À      y                                                     @      4                                                     x      d                               &                     à      h                             4                     H      h           	!                B     p   €            °"                  €               M     p   €            Ð#                  €               Y     p                ð#      Ð          „ƒ               i     p                À%      Ð          „‡                .shstrtab .note.nfp .note.build_info .text.i32.me0 .text.i33.me9 .regi.xpbm .regi1.xpbm .regt.mecsr.i32 .regt.mecsr.i33                NFP               NFP                    T      NFP ŸÛ[Toolchain: nfld 6.x-devel (build 3781)
+Name: 
+Version: 0.0.0
+Build Number: 0
+        Ð,ð@ €Ò,ðÀ Ò,ð   Ò,ð`  Ò,ðÀ 0Ò,ð  1Ò,ð@  Ò,ðÈ Ò,ð¨  Ò,ðH   Ò,ðh	 Ò,ðà %Ò,ð@ Ò,ð( )Ò,ðè ÿðð   ÿ  ò` ÿ  ö`   €ð€  w`†ð  €Ñ,ð@	 …<ð 
+ Îámð€ „@ðÀ ˆ@ô@ Œ ô  4 ð  ± @ð  ² @ô  ³  ô` ³  ò` ³  ò° ³  òÂ  /0    Ú ò   †Òà  ²€@  Ú ø   Ú@øà	  Ú€ü`   Úðü 
+  /(    /( à  $  €  $<¤    ¦ Å‹   $¢    $£ @  $£    $  (  $!ªˆ	  $¡ (  $¢ ¨  $<  €  $\¢    $|  h  $œ¢ ¨
+  ¤À°Ä  ÀÀ°ä  ÄÀ°Ä
+ ) €°Ä 0 €°$ 1 €°Ä  €°d 1 €°`
+  €°À   €°@   €°ä A €°  A ð›€  ÿ     ÿ/ °À  o  @	  o ¢@  ò2ðà  öÐ‘à  ú"`  À @  À¢@  À¤@   À¨   À¦@  Àª 
+  À¬ 	  @ª   @¤@  @¦@
+  @¨    @¬   À !  À 	  À â	  À S p‹A Šp Š¢ p‹  Š   Š    /0   8@à
+  /0    1@   /0    A1@   /0    a1@$   /0    A1@
+  /0    E   /0    Eà  /0    E
+  /0   8@  /0   8@0  /0   8@¢  ÀØÀ  ÀwØ   àwØ@   ð     ð   !€ÀwØ@ "€ÀwØÀ #€ÀwØ  $€ÀwØÀ $€ÀwØÀ %€ÀwØ  %€ÀwØ  &€ÀwØ  '€ÀwØ@ (€ÀwØÀ )€ÀwØ  +€ÀwØ@  *€ÀwØ   8€ÀØ` 8€ÐØ 	   ð    ÀwÐÀ àÀwÐ€	 ,ÀwÐ  #$ÀwÐ  !$ÀwÐ`  $ÀwÐ€ #$ðwÐ    ð     ð     ð   +,ÄwÐ€ ¬ÄwÐà  ØwÈ    ð    ÈwÈ`
+  ÈwÈà  BÉwÈ¤  bÉwÈ   ÈwÈ@ ÿÌwÈÀ  ¢ÈwÈ  ÿÄwÈ€  ÀwÈ  6ÀwØ  6âwØ    ð     ð   6‚ÃwØà 6ÂÃwØÀ 7ÂÃwØ  7ÀwØÀ 0 ÀwØ  0€ÀwØÀ 0€ÁwØ  0€ÑwØ@
+   ð   4ÀwØ@ 4BÀwØ` 4‚ÀwØ€ 4‚âwØ    ð     ð   4‚ÃwØ€
+ 4ÂÃwØ  5ÂÃwØ@ 5‚ÀwØ` 2BÀwØ` 2‚ÀwØ€ 2ÂÃwØ  3ÂÃwØ@ 2ÂòwØ`   ð     ð     ð    À @  Ž@  ˜ ŽÀ  ¨ ŽÀ  ¸ Ž€  À @   Ž€   Ž      Ž   ° Ž@	  0 €   °¥   €»`  €»   €» €»„ €»À A  «€ A ¡«À C £«ˆ C  « 
+ €»`  (€»`  t€»` H€»`  €«"  €»°   œ€§ 
+   œ€§¢   œ€§Ð  (œ€§ 	  <œ€§ 
+   œ€¯à   œ€¯B   œ€¯’  (œ€¯à   <œ€¯à  ð© 	  ð©   ð©€  ð©Ä  Cð©ä  Gð©Ä °ð©@ ðð©à   °­   ¼°­€  <ü°­à  ,üÀ  H©    ð   H©@   ð   H&©@   ð   H6©    ð     ð     ð     ð     ð     ü`   ðà @©@	   ð   @F© 	   ð   @ ©`    ð   @  ©`   ð     ð     ð     ð     ð   €&©    ð    6©À   ð   À ©À   ð   à  ©`	   ð    '†©    ð   „v©@   ð   …v©    ð   †v©    ð   v©À    ð   ‚v©@   ð   ƒv©    ð   € ©‚   ð   € ©ã
+   ð   €V ©s   ð   V ©"   ð     ð     ð     ð     ð     ð      à     à     à     à`    à   0 €  0     à   Äwà`
+ P@ P @ Pð‘@  @¤@ P À  P! Pñ P€Ò   ?ð §   ü@·à  ö ·À  ƒø ·`  Ãø ·ä  Çø ·Ä  §ø ·Ä    §€  	"§  #§(  ü@§Ã  ü@§r	  ð  HM è€ 8€@TØ  '  ð` 8€@TØ  '  ðà 8€@TØ  '  ð  8€@TØ     À@     Àâ    Ä@    À    ÀÀ   À€    À¢   Ä    ÀÐ    ÀÀ   ûÁà   À`   ûÁ`    ›ÀÀ   ›À€    {ÁÀ    ÄÀ   Ä€ | ð  ß ð  ß ð¢ ß ðÐ   ü     ð`   üà   ð` lüà
+  lü   `ü    ü    ø€  €ù€ €ùÀ  €ùÀ 0€ù€  L€ù@	  \€ùà   ø    ù 
+  ùà   L ù    ø   €ø    L€ø    ø   €ø    L€øð   ø   €ø    L€øã	    0£€    °£€    €¡€    0£€    °£€    €¡C  €0£¤  €°£¤  À8¤¡å     0£€    °£€    €¡1    è€  
+ è   ƒ è    èd
+    èÀ  0    0     ð     ð     ð     ð   	0BP $0BP 	0B€ $0B$  0   $0B†  0   '0â† %0B„  0   	ÀC 	€N	 	€@d
+ 	 €@fð  	 „Bd` ¤„Bf  0   §@e, 	ˆ@`P š  e< ?X<e8  Ã dT  €   €¤P  €¤P
+   ð   	 €JGÀ 	 €B@@ 	 €B\@ 	 €BU  	£Œ@L 	 0   à  	£ŒHL   0   à  	 „@Mà
+ 	 €@M  	 €HM  	ƒ W€ 	£ @Nà 0   à  	£ N  	£ HN` 0   à  	£N  	  P   ’ „ $‚D    à`   `€    b`    bÄ    b`    b`    b`  P  `„ X  `ä	 Y  `	   ð     ð     ð     ð     ð   @0 ©`    ð    =@¹    ð   H0 ©    ð    =@¹    ð   H0 ¹à   ð    =@©à   ð      à     à   Ð,ð@ €Ò,ðÀ Ò,ð   Ò,ð`  Ò,ðÀ 0Ò,ð  1Ò,ð@  Ò,ðÈ Ò,ð¨  Ò,ðH   Ò,ðh	 Ò,ðà %Ò,ð@ Ò,ð( )Ò,ðè ÿðð   ÿ  ò` ÿ  ö`   €ð€  w`†ð  €Ñ,ð@	 …<ð 
+ žámð@ „@ðÀ ˆ@ô@ Œ ô  4 ð  ± @ð  ² @ô  ³  ô` ³  ò` ³  ò° ³  òÂ  /0    Ú ò   †Òà  ²€@  Ú ø   Ú@øà	  Ú€ù 	  Úðùà  /(    /( à  $  €  $<¤    ¦ Å‹   $¢    $£ @  $£    $  (  $!ªˆ	  $¡ (  $¢ ¨  $<  €  $\¢    $|  h  $œ¢ ¨
+  ¤À°Ä  ÀÀ°ä  ÄÀ°Ä
+ ) €°Ä 0 €°$ 1 €°Ä  €°d 1 €°`
+  €°À   €°@   €°ä A €°  A ð›€  ÿ     ÿ/ °À  o  @	  o ¢@  ò2ðà  öÐ‘à  ú"`  À @  À¢@  À¤@   À¨   À¦@  Àª 
+  À¬ 	  @ª   @¤@  @¦@
+  @¨    @¬   À !  À 	  À â	  À S p‹A Šp Š¢ p‹  Š   Š    /0   8@à
+  /0    1@   /0    A1@   /0    a1@$   /0    A1@
+  /0    E   /0    Eà  /0    E
+  /0   8@  /0   8@0  /0   8@¢  ÀØÀ  ÀwØ   àwØ@   ð     ð   !€ÀwØ@ "€ÀwØÀ #€ÀwØ  $€ÀwØÀ $€ÀwØÀ %€ÀwØ  %€ÀwØ  &€ÀwØ  '€ÀwØ@ (€ÀwØÀ )€ÀwØ  +€ÀwØ@  *€ÀwØ   8€ÀØ` 8€ÐØ 	   ð    ÀwÐÀ àÀwÐ€	 ,ÀwÐ  #$ÀwÐ  !$ÀwÐ`  $ÀwÐ€ #$ðwÐ    ð     ð     ð   +,ÄwÐ€ ¬ÄwÐà  ØwÈ    ð    ÈwÈ`
+  ÈwÈà  BÉwÈ¤  bÉwÈ   ÈwÈ@ ÿÌwÈÀ  ¢ÈwÈ  ÿÄwÈ€  ÀwÈ  6ÀwØ  6âwØ    ð     ð   6‚ÃwØà 6ÂÃwØÀ 7ÂÃwØ  7ÀwØÀ 0 ÀwØ  0€ÀwØÀ 0€ÁwØ  0€ÑwØ@
+   ð   4ÀwØ@ 4BÀwØ` 4‚ÀwØ€ 4‚âwØ    ð     ð   4‚ÃwØ€
+ 4ÂÃwØ  5ÂÃwØ@ 5‚ÀwØ` 2BÀwØ` 2‚ÀwØ€ 2ÂÃwØ  3ÂÃwØ@ 2ÂòwØ`   ð     ð     ð    À @  Ž@  ˜ ŽÀ  ¨ ŽÀ  ¸ Ž€  À @   Ž€   Ž      Ž   ° Ž@	  0 €   °¥   €»`  €»   €» €»„ €»À A  «€ A ¡«À C £«ˆ C  « 
+ €»`  (€»`  t€»` H€»`  €«"  €»°   œ€§ 
+   œ€§¢   œ€§Ð  (œ€§ 	  <œ€§ 
+   œ€¯à   œ€¯B   œ€¯’  (œ€¯à   <œ€¯à  ð© 	  ð©   ð©€  ð©Ä  Cð©ä  Gð©Ä °ð©@ ðð©à   °­   ¼°­€  <ü°­à  ,üÀ  H©    ð   H©@   ð   H&©@   ð   H6©    ð     ð     ð     ð     ð     ü`   ðà @©@	   ð   @F© 	   ð   @ ©`    ð   @  ©`   ð     ð     ð     ð     ð   €&©    ð    6©À   ð   À ©À   ð   à  ©`	   ð    '†©    ð   „v©@   ð   …v©    ð   †v©    ð   v©À    ð   ‚v©@   ð   ƒv©    ð   € ©‚   ð   € ©ã
+   ð   €V ©s   ð   V ©"   ð     ð     ð     ð     ð     ð      à     à     à     à`    à   0 €  0     à   Äwà`
+ P@ P @ Pð‘@  @¤@ P À  P! Pñ P€Ò   ?ð §   ü@·à  ö ·À  ƒø ·`  Ãø ·ä  Çø ·Ä  §ø ·Ä    §€  	"§  #§(  ü@§Ã  ü@§r	  ð  HM è€ 8€@TØ  '  ð` 8€@TØ  '  ðà 8€@TØ  '  ð  8€@TØ     À@     Àâ    Ä@    À    ÀÀ   À€    À¢   Ä    ÀÐ    ÀÀ   ûÁà   À`   ûÁ`    ›ÀÀ   ›À€    {ÁÀ    ÄÀ   Ä€ | ð  ß ð  ß ð¢ ß ðÐ   ü     ð`   üà   ð` lüà
+  lü   `ü    ü    ø€  €ù€ €ùÀ  €ùÀ 0€ù€  L€ù@	  \€ùà   ø    ù 
+  ùà   L ù    ø   €ø    L€ø    ø   €ø    L€øð   ø   €ø    L€øã	    0£€    °£€    €¡€    0£€    °£€    €¡C  €0£¤  €°£¤  À8¤¡å     0£€    °£€    €¡1    è€  
+ è   ƒ è    èd
+    èÀ  0    0     ð     ð     ð     ð   	0BP $0BP 	0B€ $0B$  0   $0B†  0   '0â† %0B„  0   	ÀC 	€N	 	€@d
+ 	 €@fð  	 „Bd` ¤„Bf  0   §@e, 	ˆ@`P š  e< ?X<e8  Ã dT  €   €¤P  €¤P
+   ð   	 €JGÀ 	 €B@@ 	 €B\@ 	 €BU  	£Œ@L 	 0   à  	£ŒHL   0   à  	 „@Mà
+ 	 €@M  	 €HM  	ƒ W€ 	£ @Nà 0   à  	£ N  	£ HN` 0   à  	£N  	  P   ’ „ $‚D    à`   `€    b`    bÄ    b`    b`    b`  P  `„ X  `ä	 Y  `	   ð     ð     ð     ð     ð   @0 ©`    ð    =@¹    ð   H0 ©    ð    =@¹    ð   H0 ¹à   ð    =@©à   ð      à     à      
+`ˆR  ÿÿ      
+`&  ÿÿ      
+`°\  ÿÿ      
+` v  ÿÿ     $ 
+`„Q  ÿÿ     ( 
+`A   ÿÿ     0 
+` C  ÿÿ     8 
+`@   ÿÿ     < 
+`   ÿÿ      
+aˆR  ÿÿ      
+a&  ÿÿ      
+a°\  ÿÿ      
+a v  ÿÿ     $ 
+a„Q  ÿÿ     ( 
+aA   ÿÿ     0 
+a C  ÿÿ     8 
+a@   ÿÿ     < 
+a   ÿÿ     @ 
+`       €   @ 
+a       €                ÿ ÿs               @     ÿ?     @     ÿ?     "@     ÿ?     2@     ÿ?     B@     ÿ?     R@     ÿ?     b@     ÿ?     r@     ÿ?     D           H     þÿ     H     þÿ     "H     þÿ     2H     þÿ     BH     þÿ     RH     þÿ     bH     þÿ     rH     þÿ     P   ÿÿ    P   ÿÿ    "P   ÿÿ    2P   ÿÿ    BP   ÿÿ    RP   ÿÿ    bP   ÿÿ    rP   ÿÿ    `         4!          4! U ÿs   4!           @4!    ÿ?     @4!    ÿ?     "@4!    ÿ?     2@4!    ÿ?     B@4!    ÿ?     R@4!    ÿ?     b@4!    ÿ?     r@4!    ÿ?     D4!          H4!    þÿ     H4!    þÿ     "H4!    þÿ     2H4!    þÿ     BH4!    þÿ     RH4!    þÿ     bH4!    þÿ     rH4!    þÿ     P4!  ÿÿ    P4!   ÿÿ    "P4!  ÿÿ    2P4!   ÿÿ    BP4!  ÿÿ    RP4!   ÿÿ    bP4!  ÿÿ    rP4!   ÿÿ    `5!     
\ No newline at end of file
